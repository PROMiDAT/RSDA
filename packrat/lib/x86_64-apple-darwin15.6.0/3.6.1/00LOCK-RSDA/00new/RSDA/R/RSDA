.packageName <- "RSDA"
#line 1 "/private/var/folders/x1/bc7ln59d11jddyfmvq0f4mwm0000gn/T/RtmpK8STdo/R.INSTALL582a7c381cc/RSDA/R/R2.L.R"
#' Lower boundary correlation coefficient.
#' @name R2.L
#' @aliases R2.L
#' @author Oldemar Rodriguez Rojas
#' @description Compute the lower boundary correlation coefficient for two interval variables.
#' @usage R2.L(sym.var, prediction)
#' @param sym.var Variable that was predicted.
#' @param prediction The prediction given by the model.
#'
#' @return The lower boundary correlation coefficient.
#' @references
#' LIMA-NETO, E.A., DE CARVALHO, F.A.T., (2008). Centre and range method
#' to fitting a linear regression model on symbolic interval data. Computational
#' Statistics and Data Analysis 52, 1500-1515.
#'
#' LIMA-NETO, E.A., DE CARVALHO, F.A.T., (2010). Constrained linear regression models
#' for symbolic interval-valued variables. Computational Statistics and
#' Data Analysis 54, 333-347.
#' @seealso sym.glm
#' @examples
#' data(int_prost_train)
#' data(int_prost_test)
#' res.cm<-sym.lm(lpsa~.,sym.data=int_prost_train,method='cm')
#' pred.cm<-predictsym.lm(res.cm,int_prost_test,method='cm')
#' R2.L(sym.var(int_prost_test,9),pred.cm$Fitted)
#'
#' res.cm.lasso<-sym.glm(sym.data=int_prost_train,response=9,method='cm',
#'                       alpha=1,nfolds=10,grouped=TRUE)
#' pred.cm.lasso<-predictsym.glm(res.cm.lasso,response=9,int_prost_test,method='cm')
#' R2.L(sym.var(int_prost_test,9),pred.cm.lasso)
#' @keywords lower correlation
#' @importFrom stats cor
#' @export
R2.L <- function(sym.var, prediction) {
  pvar <- sym.var
  pred <- prediction
  return(cor(pvar$var.data.vector[, 1], pred[, 1])^2)
}
#line 1 "/private/var/folders/x1/bc7ln59d11jddyfmvq0f4mwm0000gn/T/RtmpK8STdo/R.INSTALL582a7c381cc/RSDA/R/R2.U.R"
#' Upper boundary correlation coefficient.
#' @name R2.U
#' @aliases R2.U
#' @author Oldemar Rodriguez Rojas
#' @description Compute the upper boundary correlation coefficient for two interval variables.
#' @usage R2.U(sym.var, prediction)
#' @param sym.var Variable that was predicted.
#' @param prediction The prediction given by the model.
#'
#' @return The upper boundary correlation coefficient.
#' @references LIMA-NETO, E.A., DE CARVALHO, F.A.T., (2008). Centre and range method
#' to fitting a linear regression model on symbolic interval data. Computational
#' Statistics and Data Analysis 52, 1500-1515.
#'
#' LIMA-NETO, E.A., DE CARVALHO, F.A.T., (2010). Constrained linear regression models
#' for symbolic interval-valued variables. Computational Statistics and
#' Data Analysis 54, 333-347.
#' @seealso sym.glm
#' @examples
#' data(int_prost_train)
#' data(int_prost_test)
#' res.cm<-sym.lm(lpsa~.,sym.data=int_prost_train,method='cm')
#' pred.cm<-predictsym.lm(res.cm,int_prost_test,method='cm')
#' R2.U(sym.var(int_prost_test,9),pred.cm$Fitted)
#'
#' res.cm.lasso<-sym.glm(sym.data=int_prost_train,response=9,method='cm',
#'                       alpha=1,nfolds=10,grouped=TRUE)
#' pred.cm.lasso<-predictsym.glm(res.cm.lasso,response=9,int_prost_test,method='cm')
#' R2.U(sym.var(int_prost_test,9),pred.cm.lasso)
#' @keywords upper correlation
#' @export
#' @importFrom stats cor
#'
R2.U <- function(sym.var, prediction) {
  pvar <- sym.var
  pred <- prediction
  return(cor(pvar$var.data.vector[, 2], pred[, 2])^2)
}
#line 1 "/private/var/folders/x1/bc7ln59d11jddyfmvq0f4mwm0000gn/T/RtmpK8STdo/R.INSTALL582a7c381cc/RSDA/R/RMSE.L.R"
#' Lower boundary root-mean-square error
#' @name RMSE.L
#' @aliases RMSE.L
#' @author Oldemar Rodriguez Rojas.
#' @description Compute the lower boundary root-mean-square error.
#' @usage RMSE.L(sym.var, prediction)
#' @param sym.var Variable that was predicted.
#' @param prediction The prediction given by the model.
#'
#' @return The lower boundary root-mean-square error.
#' @references
#' LIMA-NETO, E.A., DE CARVALHO, F.A.T., (2008). Centre and range method
#' to fitting a linear regression model on symbolic interval data. Computational
#' Statistics and Data Analysis 52, 1500-1515.
#'
#' LIMA-NETO, E.A., DE CARVALHO, F.A.T., (2010). Constrained linear regression models
#' for symbolic interval-valued variables. Computational Statistics and
#' Data Analysis 54, 333-347.
#' @seealso sym.glm
#' @examples
#' data(int_prost_train)
#' data(int_prost_test)
#' res.cm<-sym.lm(lpsa~.,sym.data=int_prost_train,method='cm')
#' pred.cm<-predictsym.lm(res.cm,int_prost_test,method='cm')
#' RMSE.L(sym.var(int_prost_test,9),pred.cm$Fitted)
#'
#' res.cm.lasso<-sym.glm(sym.data=int_prost_train,response=9,method='cm',
#'                       alpha=1,nfolds=10,grouped=TRUE)
#' pred.cm.lasso<-predictsym.glm(res.cm.lasso,response=9,int_prost_test,method='cm')
#' RMSE.L(sym.var(int_prost_test,9),pred.cm.lasso)
#' @keywords lower root-mean-square
#' @export
#'
RMSE.L <- function(sym.var, prediction) {
  pvar <- sym.var
  pred <- prediction
  nn <- pvar$N
  res <- sqrt(sum((pvar$var.data.vector[, 1] - pred[, 1])^2) / nn)
  # res<-sum((pvar$var.data.vector[,1]-pred[,1])^2)/nn
  return(res)
}
#line 1 "/private/var/folders/x1/bc7ln59d11jddyfmvq0f4mwm0000gn/T/RtmpK8STdo/R.INSTALL582a7c381cc/RSDA/R/RMSE.U.R"
#' Upper boundary root-mean-square error
#' @name RMSE.U
#' @aliases RMSE.U
#' @author Oldemar Rodriguez Rojas
#' @description Compute the upper boundary root-mean-square error.
#' @usage RMSE.U(sym.var, prediction)
#' @param sym.var Variable that was predicted.
#' @param prediction The prediction given by the model.
#'
#' @return The upper boundary root-mean-square error.
#' @references
#' LIMA-NETO, E.A., DE CARVALHO, F.A.T., (2008). Centre and range method
#' to fitting a linear regression model on symbolic interval data. Computational
#' Statistics and Data Analysis 52, 1500-1515.
#'
#' LIMA-NETO, E.A., DE CARVALHO, F.A.T., (2010). Constrained linear regression models
#' for symbolic interval-valued variables. Computational Statistics and
#' Data Analysis 54, 333-347.
#' @seealso sym.glm
#' @examples
#' data(int_prost_train)
#' data(int_prost_test)
#' res.cm<-sym.lm(lpsa~.,sym.data=int_prost_train,method='cm')
#' pred.cm<-predictsym.lm(res.cm,int_prost_test,method='cm')
#' RMSE.U(sym.var(int_prost_test,9),pred.cm$Fitted)
#'
#' res.cm.lasso<-sym.glm(sym.data=int_prost_train,response=9,method='cm',
#'                       alpha=1,nfolds=10,grouped=TRUE)
#' pred.cm.lasso<-predictsym.glm(res.cm.lasso,response=9,int_prost_test,method='cm')
#' RMSE.U(sym.var(int_prost_test,9),pred.cm.lasso)
#' @keywords upper root-mean-square
#' @export
#'
RMSE.U <- function(sym.var, prediction) {
  pvar <- sym.var
  pred <- prediction
  nn <- pvar$N
  res <- sqrt(sum((pvar$var.data.vector[, 2] - pred[, 2])^2) / nn)
  # res<-sum((pvar$var.data.vector[,2]-pred[,2])^2)/nn
  return(res)
}
#line 1 "/private/var/folders/x1/bc7ln59d11jddyfmvq0f4mwm0000gn/T/RtmpK8STdo/R.INSTALL582a7c381cc/RSDA/R/RSDA.R"
#' @name RSDA
#' @aliases RSDA
#' @docType package
#' @title R to Symbolic Data Analysis
#' @author Oldemar Rodriguez Rojas \cr
#' Maintainer: Oldemar Rodriguez Rojas <oldemar.rodriguez@ucr.ac.cr>
#' @description
#' This work is framed inside the Symbolic Data Analysis (SDA). The objective of this
#' work is to implement in R to the symbolic case certain techniques of the
#' automatic classification, as well as some lineal models. These
#' implementations will always be made following two fundamental principles in
#' Symbolic Data Analysis like they are: Classic Data Analysis should always be
#' a case particular case of the Symbolic Data Analysis and both, the exit as
#' the input in an Symbolic Data Analysis should be symbolic. We implement
#' for variables of type interval the mean, the median, the mean of the
#' extreme values, the standard deviation, the deviation quartil, the
#' dispersion boxes and the correlation also three new methods are also
#' presented to carry out the lineal regression for variables of type interval.
#' We also implement in this R package the method of Principal Components
#' Analysis in two senses: First, we propose three ways to project the
#' interval variables in the circle of correlations in such way
#' that is reflected the variation or the inexactness of the variables. Second,
#' we propose an algorithm to make the Principal Components Analysis for
#' variables of type histogram. We implement a method for multidimensional
#' scaling of interval data, denominated INTERSCAL.
#' @details
#' \tabular{ll}{
#' Package: \tab RSDA\cr
#' Type: \tab Package\cr
#' Version: \tab 2.0.8\cr
#' Date: \tab 2018-10-10\cr
#' License: \tab GPL (>=2)\cr
#' }
#' Most of the function of the package stars from a symbolic data table that can be store in
#' a CSV file withe follwing forma: In the first row the labels $C means that follows a
#' continuous variable, $I means an interval variable, $H means a histogram variables and
#' $S means set variable. In the first row each labels should be follow of a name to
#' variable and to the case of histogram a set variables types the names of the modalities
#' (categories) . In data rows for continuous variables we have just one value, for
#' interval variables we have the minimum and the maximum of the interval, for histogram
#' variables we have the number of modalities and then the probability of each modality
#' and for set variables we have the cardinality of the set and next the elements of
#' the set.
#' @references
#' Billard L. and  Diday E. (2006).
#' Symbolic data analysis: Conceptual statistics and data mining. Wiley, Chichester.
#'
#' Billard L., Douzal-Chouakria A. and Diday E. (2011)
#' Symbolic Principal Components For Interval-Valued Observations, Statistical Analysis and
#' Data Mining. 4 (2), 229-246. Wiley.
#'
#' Bock H-H. and Diday E. (eds.) (2000).
#' Analysis of Symbolic Data. Exploratory methods for extracting statistical information
#' from complex data. Springer, Germany.
#'
#' Carvalho F., Souza R.,Chavent M., and Lechevallier Y. (2006)
#' Adaptive Hausdorff distances and dynamic clustering of symbolic interval data. Pattern
#' Recognition Letters Volume 27, Issue 3, February 2006, Pages 167-179
#'
#' Cazes P., Chouakria A., Diday E. et Schektman Y. (1997).  Extension de l'analyse en
#' composantes principales a des donnees de type intervalle, Rev. Statistique Appliquee,
#' Vol. XLV Num. 3 pag. 5-24, France.
#'
#' Diday, E., Rodriguez O. and Winberg S. (2000).
#' Generalization of the Principal Components Analysis to Histogram
#' Data, 4th European Conference on Principles and Practice of Knowledge Discovery in
#' Data Bases, September 12-16, 2000, Lyon, France.
#'
#' Chouakria A. (1998)
#' Extension des methodes d'analysis factorialle a des
#' donnees de type intervalle, Ph.D. Thesis, Paris IX Dauphine University.
#'
#' Makosso-Kallyth S. and Diday E. (2012).  Adaptation of interval PCA to symbolic histogram
#' variables, Advances in Data Analysis and Classification July, Volume 6, Issue 2, pp 147-159.
#'
#' Rodriguez, O. (2000).
#' Classification et Modeles Lineaires en Analyse des Donnees Symboliques. Ph.D. Thesis,
#' Paris IX-Dauphine University.
#'
#'
#' @keywords package
#' @docType package
#' @examples
#' data(example3)
#' sym.data<-example3
#' class(sym.data) <- c('sym.data.table')
#' display.sym.table(sym.data)
#' sym.scatterplot(sym.data[,1], sym.data[,4], col='blue',main='Main Title')
#'
#' data(oils)
#' class(oils) <- c('sym.data.table')
#' res<-sym.interval.pca(oils,'centers')
#' sym.scatterplot(res$Sym.Components[,1],res$Sym.Components[,2],
#'                 labels=TRUE,col='red',main='PCA Oils Data')
#' sym.scatterplot3d(res$Sym.Components[,1], res$Sym.Components[,2],
#'                   res$Sym.Components[,3],color='blue',main='PCA Oils Data')
#' sym.scatterplot.ggplot(res$Sym.Components[,1],
#'                        res$Sym.Components[,2], labels=TRUE)
#' sym.circle.plot(res$Sym.Prin.Correlations)
#'
#' res<-sym.interval.pca(oils,'classic')
#' plot(res,choix='ind')
#' plot(res,choix='var')
#'
#' data(lynne2)
#' res<-sym.interval.pca(lynne2,'centers')
#' class(res$Sym.Components) <- c('sym.data.table')
#' sym.scatterplot(res$Sym.Components[,1], res$Sym.Components[,2],
#'                 labels=TRUE, col='red',main='PCA Lynne Data')
#' sym.scatterplot3d(res$Sym.Components[,1],res$Sym.Components[,2],
#'                   res$Sym.Components[,3],color='blue', main='PCA Lynne Data')
#' sym.scatterplot.ggplot(res$Sym.Components[,1],res$Sym.Components[,2],
#'                        labels=TRUE)
#' sym.circle.plot(res$Sym.Prin.Correlations)
NULL
utils::globalVariables(c(
  "to", "from", "interval", "n", "prob", "pca.max", "N", "M",
  "<<-", ".", "do", "quo", "concept", "Variables", "value", "Individuals", "pos.var","cfa.minmax","distinctColorPalette","cfa.MatrixZ", "cfa.totals",
   "C1","C1.1", "C2", "C2.1", "cat.name", "var.name"
))
#line 1 "/private/var/folders/x1/bc7ln59d11jddyfmvq0f4mwm0000gn/T/RtmpK8STdo/R.INSTALL582a7c381cc/RSDA/R/RSDA.to.latex.j.r"
#' RSDA.to.latex
#' @keywords internal
RSDA.to.latex <- function(sym.data) {
  return(xtable(generate.sym.table(sym.data)))
}
#line 1 "/private/var/folders/x1/bc7ln59d11jddyfmvq0f4mwm0000gn/T/RtmpK8STdo/R.INSTALL582a7c381cc/RSDA/R/SDS.to.RSDA.R"
#' SDS SODAS files to RSDA files.
#' @name SDS.to.RSDA
#' @aliases SDS.to.RSDA
#' @author Olger Calderon and Roberto Zuniga.
#' @description To convert SDS SODAS files to RSDA files.
#' @usage SDS.to.RSDA(file.path, labels = FALSE)
#' @param file.path Disk path where the SODAS *.SDA file is.
#' @param labels If we want to include SODAS SDA files lebels in RSDA file.
#'
#' @return A RSDA symbolic data file.
#' @references Bock H-H. and Diday E. (eds.) (2000).
#' Analysis of Symbolic Data. Exploratory methods for extracting statistical information from
#' complex data. Springer, Germany.
#' @seealso SODAS.to.RSDA
#' @examples
#' \dontrun{
#' # We can read the file directly from the SODAS SDA file as follows:
#' # We can save the file in CSV to RSDA format as follows:
#' setwd('C:/Program Files (x86)/DECISIA/SODAS version 2.0/bases/')
#' result <- SDS.to.RSDA(file.path='hani3101.sds')
#' # We can save the file in CSV to RSDA format as follows:
#' write.sym.table(result, file='hani3101.csv', sep=';',dec='.', row.names=TRUE,
# col.names=TRUE)
#' }
#' @keywords Symbolic data table
#' @export
#' @importFrom RJSONIO fromJSON
#'
SDS.to.RSDA <- function(file.path, labels = FALSE) {
  get.last <- function(X) {
    return(X[[length(X)]])
  }

  regex.preprocess <- function(SdsData) {
    SdsData <- paste(SdsData, collapse = " ") # It joins the lines of the file with whitespaces. The processing starts using one string with all the data.
    SdsData <- gsub(pattern = "\\\\\"", replacement = "'", x = SdsData, perl = TRUE) # Replaces escaped double quotes with single quotes.
    SdsData <- gsub(
      pattern = " ?(=|\\(|\\)|,|\\:)(?=(?:(?:[^\"]*\"){2})*[^\"]*$) ?",
      replacement = " \\1 ", x = SdsData, perl = TRUE
    ) # It isolates certain special characters like: (, ), : and = from the adjacent strings, so we can later decompose the string in separate tokens (we split the string using whitespaces).
    SdsData <- gsub(
      pattern = "(?:(\\d+)\\s*\\(\\s*((?:1|0)(?:\\.\\d+)?)\\s*\\)\\s*)(?=(?:(?:[^\"]*\"){2})*[^\"]*$)",
      replacement = " \"\\1\" = \\2 ", x = SdsData, perl = TRUE
    ) # This converts the data of histograms variables in RECTANGLE_MATRIX to valid JSON objects.
    SdsData <- gsub(
      pattern = "(\\b\\w+\\b) =(?=(?:(?:[^\"]*\"){2})*[^\"]*$)",
      replacement = "\"\\1\" =", x = SdsData, perl = TRUE
    ) # It quotes the names for properties on objects.
    SdsData <- gsub(
      pattern = "\"VAR\"\\s*=\\s*(\\d+)\\s*,\\s*(\\d+)(?=(?:(?:[^\"]*\"){2})*[^\"]*$)",
      replacement = "\\1 , \\2 , ", x = SdsData, perl = TRUE
    ) # This convert the data in hierarchies into valid JSON data.
    SdsData <- strsplit(
      x = SdsData, split = "\\s+(?=(?:(?:[^\"]*\"){2})*[^\"]*$)",
      perl = TRUE
    ) # We split the string into separate tokens.
    SdsData <- sub(pattern = "^:$", replacement = ",", x = SdsData[[1]], perl = TRUE) # We replace the ':' characters (on intervals data) with commas.
    SdsData <- sub(pattern = "^=$", replacement = ":", x = SdsData, perl = TRUE) # We replace the '=' characters with ':'.
    SdsData <- sub(
      pattern = "^(?:NA|NU)$", replacement = "null", x = SdsData,
      perl = TRUE
    ) # We replace NA and NU with nulls.
    SdsData <- sub(
      pattern = "^\\.(\\d+)$", replacement = "0.\\1", x = SdsData,
      perl = TRUE
    ) # We fill numbers that do not have the integer part (for example we replace .12 with 0.12).
    SdsData <- sub(
      pattern = "^(FILES|HEADER|INDIVIDUALS|VARIABLES|RECTANGLE_MATRIX|DIST_MATRIX|HIERARCHIE|RULES|proba|inter_cont(?:inue)?|nominal|continue?|mult_nominal(?:_Modif)?)$",
      replacement = "\"\\1\"", x = SdsData, perl = TRUE
    ) # We quote certain special words like: INDIVIDUALS, nominal, continue, among others.
    SdsData <- append(x = SdsData, values = "(", after = 0) # We add as a first token a '(' character. So it marks the beginning of the data.
    SdsData[length(SdsData)] <- ")" # We replace the final END token with a ')' character, marking the end of the data.
    return(SdsData)
  }

  # See step 2 above. The function replaces the () pairs of characters with [] or {}
  # according to the context.
  preprocessed.sds.to.json <- function(SdsData) {
    pStack <- list() # We have a stack that keeps tracking the parenthesis open, but that are not closed.
    for (i in 1:length(SdsData)) {
      # We iterate over every token in the string, doing the proper replacements
      # according to the context.
      currentToken <- SdsData[i]
      switch(currentToken, `(` = {
        pStack[length(pStack) + 1] <- i
      }, `)` = {
        if (pStack[[length(pStack)]] == "[") {
          SdsData[i] <- "]"
        } else if (pStack[[length(pStack)]] == "{") {
          SdsData[i] <- "}"
        } else {
          SdsData[pStack[[length(pStack)]]] <- "["
          SdsData[i] <- "]"
        }
        pStack[[length(pStack)]] <- NULL
      }, `:` = {
        if (mode(pStack[[length(pStack)]]) == "numeric") {
          SdsData[pStack[[length(pStack)]]] <- "{"
          pStack[[length(pStack)]] <- "{"
        }
      }, `,` = {
        if (mode(pStack[[length(pStack)]]) == "numeric") {
          SdsData[pStack[[length(pStack)]]] <- "["
          pStack[[length(pStack)]] == "["
        }
      })
    }
    SdsData <- paste(SdsData, collapse = " ")
    return(fromJSON(SdsData)) # We return the parsed JSON data, ready to be processed. This corresponds to step 3.
  }

  process.continue.variable <- function(number.of.rows, data, variable.index, variable.name) {
    aux <- list()
    aux[[1]] <- rep("$C", number.of.rows)
    aux[[2]] <- sapply(X = data$SODAS$RECTANGLE_MATRIX, FUN = function(dat.ind) {
      if (is.null(dat.ind[[variable.index]])) {
        return(NA)
      } else {
        return(round(dat.ind[[variable.index]], 3))
      }
    })

    aux <- data.frame(aux)
    colnames(aux) <- c("$C", make.names(names = variable.name))
    return(aux)
  }

  process.inter.cont.variable <- function(number.of.rows, data, variable.index, variable.name) {
    aux <- list()
    aux[[1]] <- rep("$I", number.of.rows)

    aux[[2]] <- sapply(X = data$SODAS$RECTANGLE_MATRIX, FUN = function(dat.ind) {
      if (is.null(dat.ind[[variable.index]])) {
        return(NA)
      } else {
        return(round(dat.ind[[variable.index]][[1]], 3))
      }
    })
    aux[[3]] <- sapply(X = data$SODAS$RECTANGLE_MATRIX, FUN = function(dat.ind) {
      if (is.null(dat.ind[[variable.index]])) {
        return(NA)
      } else {
        return(round(dat.ind[[variable.index]][[2]], 3))
      }
    })

    aux <- data.frame(aux)
    colnames(aux) <- c("$I", make.names(names = variable.name), make.names(names = variable.name))
    return(aux)
  }

  process.nominal.variable <- function(labels, number.of.rows, data, variable.index,
                                         variable.name) {
    aux <- list()
    aux[[1]] <- rep("$S", number.of.rows)

    categories <- sapply(
      X = get.last(data$SODAS$VARIABLES[[variable.index]]),
      FUN = function(cat) {
        cat[[3]]
      }
    )
    categories.labels <- sapply(
      X = get.last(data$SODAS$VARIABLES[[variable.index]]),
      FUN = function(cat) {
        cat[[2]]
      }
    )

    aux[[2]] <- rep(length(categories), number.of.rows)

    categories.data <- sapply(X = data$SODAS$RECTANGLE_MATRIX, FUN = function(dat.ind) {
      if (is.null(dat.ind[[variable.index]])) {
        return(rep(x = NA, times = length(categories)))
      } else {
        categories.for.individual <- rep(x = 0, times = length(categories))
        present.categories <- dat.ind[[variable.index]]
        categories.for.individual[present.categories] <- 1
        return(categories.for.individual)
      }
    })

    aux <- data.frame(aux, as.data.frame(t(x = categories.data)))
    if (labels) {
      colnames(aux) <- c("$S", make.names(names = variable.name), make.names(names = categories.labels))
    } else {
      colnames(aux) <- c("$S", make.names(names = variable.name), make.names(names = categories))
    }
    return(aux)
  }

  process.mult.nominal.modif.variable <- function(labels, number.of.rows, data, variable.index,
                                                    variable.name) {
    aux <- list()
    aux[[1]] <- rep("$M", number.of.rows)

    categories <- sapply(
      X = get.last(data$SODAS$VARIABLES[[variable.index]]),
      FUN = function(cat) {
        cat[[3]]
      }
    )
    categories.labels <- sapply(
      X = get.last(data$SODAS$VARIABLES[[variable.index]]),
      FUN = function(cat) {
        cat[[2]]
      }
    )

    aux[[2]] <- rep(length(categories), number.of.rows)

    for (i in 1:length(categories)) {
      aux[[i + 2]] <- sapply(X = data$SODAS$RECTANGLE_MATRIX, FUN = function(dat.ind) {
        val <- dat.ind[[variable.index]][as.character(i)]
        if (is.null(val)) {
          return(NA)
        } else {
          return(ifelse(test = is.na(val), yes = 0, no = round(val, 3)))
        }
      })
    }

    aux <- data.frame(aux)
    if (labels) {
      colnames(aux) <- c("$M", make.names(names = variable.name), make.names(names = categories.labels))
    } else {
      colnames(aux) <- c("$M", make.names(names = variable.name), make.names(names = categories))
    }
    return(aux)
  }

  # -------------------- Main function Logic --------------------

  data <- readLines(con = file.path, warn = FALSE)

  cat("Preprocessing file\n")
  data <- regex.preprocess(data)

  cat("Converting data to JSON format\n")
  data <- preprocessed.sds.to.json(data)

  if (labels) {
    sym.obj.names <- sapply(X = data$SODAS$INDIVIDUALS, FUN = function(ind) {
      ind[[2]]
    })
  } else {
    sym.obj.names <- sapply(X = data$SODAS$INDIVIDUALS, FUN = function(ind) {
      ind[[3]]
    })
  }

  variables.names <- sapply(X = data$SODAS$VARIABLES, FUN = function(var) {
    var[[5]]
  })
  variables.types <- sapply(X = data$SODAS$VARIABLES, FUN = function(var) {
    var[[2]]
  })
  result <- data.frame(row.names = make.names(names = sym.obj.names, unique = TRUE))
  number.of.rows <- nrow(result)

  for (i in 1:length(variables.types)) {
    cat(paste0("Processing variable ", i, ": ", variables.names[[i]], "\n"))

    switch(variables.types[[i]], inter_continue = {
      result <- cbind(result, process.inter.cont.variable(
        number.of.rows, data,
        i, variables.names[[i]]
      ))
    }, inter_cont = {
      result <- cbind(result, process.inter.cont.variable(
        number.of.rows, data,
        i, variables.names[[i]]
      ))
    }, continue = {
      result <- cbind(result, process.continue.variable(
        number.of.rows, data,
        i, variables.names[[i]]
      ))
    }, continu = {
      result <- cbind(result, process.continue.variable(
        number.of.rows, data,
        i, variables.names[[i]]
      ))
    }, nominal = {
      result <- cbind(result, process.nominal.variable(
        labels, number.of.rows,
        data, i, variables.names[[i]]
      ))
    }, mult_nominal = {
      result <- cbind(result, process.nominal.variable(
        labels, number.of.rows,
        data, i, variables.names[[i]]
      ))
    }, mult_nominal_Modif = {
      result <- cbind(result, process.mult.nominal.modif.variable(
        labels, number.of.rows,
        data, i, variables.names[[i]]
      ))
    }, cat(paste0("Variable type not supported:"), variables.types[[i]], "\n"))
  }

  out. <- newSobject(result)
  class(out.) <- "sym.data.table"
  return(out.)
}
#line 1 "/private/var/folders/x1/bc7ln59d11jddyfmvq0f4mwm0000gn/T/RtmpK8STdo/R.INSTALL582a7c381cc/RSDA/R/SODAS.to.RSDA.R"
#' XML SODAS files to RSDA files.
#' @name SODAS.to.RSDA
#' @aliases SODAS.to.RSDA
#' @author Olger Calderon and Roberto Zuniga.
#' @description To convert XML SODAS files to RSDA files.
#' @param XMLPath Disk path where the SODAS *.XML file is.
#' @param labels If we want to include SODAS XML files lebels in RSDA file.
#'
#' @return A RSDA symbolic data file.
#' @references
#' Bock H-H. and Diday E. (eds.) (2000).
#' Analysis of Symbolic Data. Exploratory methods for extracting statistical information from
#' complex data. Springer, Germany.
#' @seealso SDS.to.RSDA
#' @examples
#' \dontrun{
#' # We can read the file directly from the SODAS XML file as follows:
#' # abalone<-SODAS.to.RSDA('C:/Program Files (x86)/DECISIA/SODAS version 2.0/bases/abalone.xml)
#' # We can save the file in CSV to RSDA format as follows:
#' # write.sym.table(sodas.ex1, file='abalone.csv', sep=';',dec='.', row.names=TRUE,
#' #               col.names=TRUE)
#' # We read the file from the CSV file,
#' # this is not necessary if the file is read directly from
#' # XML using SODAS.to.RSDA as in the first statement in this example.
#' data(abalone)
#' res<-sym.interval.pca(abalone,'centers')
#' sym.scatterplot(sym.var(res$Sym.Components,1),sym.var(res$Sym.Components,2),
#'                labels=TRUE,col='red',main='PCA Oils Data')
#' sym.scatterplot3d(sym.var(res$Sym.Components,1),sym.var(res$Sym.Components,2),
#'                  sym.var(res$Sym.Components,3),color='blue',main='PCA Oils Data')
#' sym.scatterplot.ggplot(sym.var(res$Sym.Components,1),sym.var(res$Sym.Components,2),
#'                       labels=TRUE)
#' sym.circle.plot(res$Sym.Prin.Correlations)
#'
#' }
#' @keywords Symbolic data table
#' @export
#' @importFrom XML xmlInternalTreeParse getNodeSet xmlGetAttr xpathSApply xmlValue xmlName
#'
SODAS.to.RSDA <- function(XMLPath, labels = T) {
  parsed.xml <- xmlInternalTreeParse(XMLPath)

  containsNode <- getNodeSet(parsed.xml, "/assofile/contains")
  if (length(containsNode) == 0) {
    stop("No 'contains' tag is present in the XML file")
  }
  containsNode <- containsNode[[1]]
  if (xmlGetAttr(containsNode, "INDIVIDUALS") != "YES" || xmlGetAttr(
    containsNode,
    "VARIABLES"
  ) != "YES" || xmlGetAttr(containsNode, "RECTANGLE_MATRIX") != "YES") {
    stop("Insufficient data in XML file")
  }

  if (labels) {
    sym.obj.names <- xpathSApply(
      parsed.xml, "/assofile/individus/stindiv/label",
      xmlValue
    )
    variables.names <- xpathSApply(
      parsed.xml, "/assofile/variables/stvar/ident/label",
      xmlValue
    )
  } else {
    sym.obj.names <- xpathSApply(
      parsed.xml, "/assofile/individus/stindiv/name",
      xmlValue
    )
    variables.names <- xpathSApply(
      parsed.xml, "/assofile/variables/stvar/ident/name",
      xmlValue
    )
  }

  variables.types <- xpathSApply(parsed.xml, "/assofile/variables/stvar/*[2]", xmlName)
  result <- data.frame(row.names = sym.obj.names)
  number.of.rows <- nrow(result)

  for (i in 1:length(variables.types)) {
    cat(paste0("Processing variable ", i, ": ", variables.names[[i]], "\n"))

    switch(variables.types[[i]], `inter-cont` = {
      result <- cbind(result, process.inter.cont.variable(
        number.of.rows, parsed.xml,
        i, variables.names[[i]]
      ))
    }, continue = {
      result <- cbind(result, process.continue.variable(
        number.of.rows, parsed.xml,
        i, variables.names[[i]]
      ))
    }, nominal = {
      result <- cbind(result, process.nominal.variable(
        labels, number.of.rows,
        parsed.xml, i, variables.names[[i]]
      ))
    }, mult_nominal = {
      result <- cbind(result, process.mult.nominal.variable(
        labels, number.of.rows,
        parsed.xml, i, variables.names[[i]]
      ))
    }, mult_nominal_Modif = {
      type.modif <- xpathSApply(parsed.xml, paste0(
        "/assofile/variables/stvar[",
        i, "]/mult_nominal_Modif/type_modif"
      ), xmlValue)
      if (type.modif != "proba") {
        cat(
          paste0("Unsupported type.modif in mult_nominal_Modif variable: "),
          type.modif, "\n"
        )
      } else {
        result <- cbind(result, process.mult.nominal.modif.variable(
          labels,
          number.of.rows, parsed.xml, i, variables.names[[i]]
        ))
      }
    }, cat(paste0("Variable type not supported:"), variables.types[[i]], "\n"))
  }
  out. <- newSobject(result)
  class(out.) <- "sym.data.table"
  return(out.)
}
#line 1 "/private/var/folders/x1/bc7ln59d11jddyfmvq0f4mwm0000gn/T/RtmpK8STdo/R.INSTALL582a7c381cc/RSDA/R/calc.burt.sym.2.r"
calc.burt.sym.2 <- function(sym.data, pos.var.x, pos.var.y) {
  num.vars.x <- length(pos.var.x)
  num.vars.y <- length(pos.var.y)

  num.rows <- sum(sym.data$sym.var.length[pos.var.x])
  num.cols <- sum(sym.data$sym.var.length[pos.var.y])

  burt.sym <- as.data.frame(matrix(rep(0, 2 * num.cols * num.rows), nrow = num.rows))

  pos.col <- pos.row <- 0

  sym.var.length <- sym.data$sym.var.length[pos.var.x]
  sym.var.length.2 <- sym.data$sym.var.length[pos.var.y] * 2

  cum.sym.var.length <- cumsum(sym.var.length)
  cum.sym.var.length.2 <- cumsum(sym.var.length.2)

  pos.col.ini <- 0
  pos.row.ini <- 0


  for (i in 1:num.vars.x)
  {
    var.act <- sym.var(sym.data, pos.var.x[i])

    pos.row.ini <- pos.row.ini + 1

    pos.row <- cum.sym.var.length[i]

    indx.row.i <- (pos.row.ini:pos.row)

    for (j in 1:num.vars.y)
    {
      pos.col.ini <- pos.col.ini + 1
      pos.col <- cum.sym.var.length.2[j]

      K <- calc.k(var.act, sym.var(sym.data, pos.var.y[j]))

      burt.sym[indx.row.i, (pos.col.ini:pos.col)] <- K$data
      colnames(burt.sym)[(pos.col.ini:pos.col)] <- colnames(K$data)

      pos.col.ini <- cum.sym.var.length.2[j]
    }

    row.names(burt.sym)[indx.row.i] <- rownames(K$data)
    pos.row.ini <- pos.row
    pos.col.ini <- 0
  }

  return(data.frame.to.RSDA.inteval.table(burt.sym))
}
#line 1 "/private/var/folders/x1/bc7ln59d11jddyfmvq0f4mwm0000gn/T/RtmpK8STdo/R.INSTALL582a7c381cc/RSDA/R/calc.burt.sym.r"
#' Burt Matrix
#'
#' @param sym.data ddd
#' @param pos.var ddd
#'
#' @export
#'
calc.burt.sym <- function(sym.data, pos.var) {
  num.vars <- length(pos.var)
  dim.matrix <- sum(sym.data$sym.var.length[pos.var])
  burt.sym <- as.data.frame(matrix(rep(0, 2 * dim.matrix^2), nrow = dim.matrix))

  pos.col <- pos.row <- 0

  sym.var.length <- sym.data$sym.var.length[pos.var]
  sym.var.length.2 <- sym.var.length * 2

  cum.sym.var.length <- cumsum(sym.var.length)
  cum.sym.var.length.2 <- cumsum(sym.var.length.2)

  pos.col.ini <- 0
  pos.row.ini <- 0

  for (i in 1:(num.vars - 1))
  {
    var.act <- sym.var(sym.data, pos.var[i])

    pos.col.ini <- pos.col.ini + 1
    pos.row.ini <- pos.row.ini + 1

    pos.row <- cum.sym.var.length[i]
    pos.col <- cum.sym.var.length.2[i]

    K <- calc.k(var.act, var.act)

    indx.col.i <- (pos.col.ini:pos.col)
    indx.row.i <- (pos.row.ini:pos.row)

    burt.sym[indx.row.i, indx.col.i] <- K$data
    colnames(burt.sym)[indx.col.i] <- colnames(K$data)
    row.names(burt.sym)[indx.row.i] <- row.names(K$data)

    for (j in (i + 1):num.vars)
    {
      pos.col.ini <- cum.sym.var.length.2[j - 1] + 1
      pos.col <- cum.sym.var.length.2[j]
      K <- calc.k(var.act, sym.var(sym.data, pos.var[j]))
      K.t <- transpose.sym(K)

      burt.sym[indx.row.i, (pos.col.ini:pos.col)] <- K$data
      colnames(burt.sym)[(pos.col.ini:pos.col)] <- colnames(K$data)


      burt.sym[(cum.sym.var.length[j - 1] + 1):(cum.sym.var.length[j]), indx.col.i] <- K.t$data
    }

    pos.row.ini <- pos.row
    pos.col.ini <- cum.sym.var.length.2[i]
  }

  i <- num.vars
  var.act <- sym.var(sym.data, pos.var[i])

  pos.row <- cum.sym.var.length[i]
  pos.col <- cum.sym.var.length.2[i]

  K <- calc.k(var.act, var.act)
  indx.col.i <- ((cum.sym.var.length.2[i - 1] + 1):pos.col)
  indx.row.i <- ((cum.sym.var.length[i - 1] + 1):pos.row)

  burt.sym[indx.row.i, indx.col.i] <- K$data
  colnames(burt.sym)[indx.col.i] <- colnames(K$data)
  row.names(burt.sym)[indx.row.i] <- row.names(K$data)

  return(data.frame.to.RSDA.inteval.table(burt.sym))
}
#line 1 "/private/var/folders/x1/bc7ln59d11jddyfmvq0f4mwm0000gn/T/RtmpK8STdo/R.INSTALL582a7c381cc/RSDA/R/calc.k.r"
calc.k <- function(var.sym.X, var.sym.Y) {
  data.X.max <- var.sym.X$var.data.vector
  data.Y.max <- var.sym.Y$var.data.vector
  data.X.min <- calc.matrix.min(data.X.max)
  data.Y.min <- calc.matrix.min(data.Y.max)

  K.min <- t(as.matrix(data.X.min)) %*% as.matrix(data.Y.min)
  K.max <- t(as.matrix(data.X.max)) %*% as.matrix(data.Y.max)

  N <- dim(K.min)
  K <- as.data.frame(matrix(rep(0, 2 * N[1] * N[2]), nrow = N[1]))
  indx.min <- seq(from = 1, by = 2, length.out = N[2])
  indx.max <- seq(from = 2, by = 2, length.out = N[2])
  K[, indx.min] <- K.min
  K[, indx.max] <- K.max

  col.names.K <- colnames(K.min)
  row.names.K <- row.names(K.min)

  row.names(K) <- row.names.K
  colnames(K)[indx.min] <- col.names.K
  colnames(K)[indx.max] <- paste0(col.names.K, ".1")

  return(data.frame.to.RSDA.inteval.table(K))
}
#line 1 "/private/var/folders/x1/bc7ln59d11jddyfmvq0f4mwm0000gn/T/RtmpK8STdo/R.INSTALL582a7c381cc/RSDA/R/calc.matrix.min.r"
calc.matrix.min<-function(data.max)
{
  dim.data.max<-dim(data.max)
  data.min<-data.max
  zeros.rep<-rep(0,dim.data.max[2])
  indx.mult<-which(apply(data.max, 1, sum) > 1)
  data.min[indx.mult,]<-zeros.rep
  return(data.min)
}
#line 1 "/private/var/folders/x1/bc7ln59d11jddyfmvq0f4mwm0000gn/T/RtmpK8STdo/R.INSTALL582a7c381cc/RSDA/R/calculate.probs.R"
#' process.histogram.variable
#' @keywords internal
calculate.probs <- function(x, breaks.) {
  h. <- hist(x, plot = F, breaks = breaks., right = F)
  i <- 1:(length(h.$breaks) - 1)
  j <- 2:(length(h.$breaks))
  prob <- h.$counts / sum(h.$counts)
  d <- data.frame(to = h.$breaks[i], from = h.$breaks[j], prob = prob)
  return(d)
}
#line 1 "/private/var/folders/x1/bc7ln59d11jddyfmvq0f4mwm0000gn/T/RtmpK8STdo/R.INSTALL582a7c381cc/RSDA/R/centers.interval.R"
#' Compute centers of the interval
#' @name centers.interval
#' @author Jorge Arce.
#' @aliases centers.interval
#' @description Compute centers of the interval
#' @usage centers.interval(sym.data)
#' @param sym.data Symbolic interval data table.
#'
#' @return Centers of teh intervals.
#' @references Arce J. and Rodriguez O. (2015) 'Principal Curves and Surfaces to Interval Valued Variables'.
#' The 5th Workshop on Symbolic Data Analysis, SDA2015, Orleans, France, November.
#'
#' Hastie,T. (1984).Principal Curves and Surface. Ph.D Thesis Stanford University.
#'
#' Hastie,T. \& Weingessel,A. (2014).
#' princurve - Fits a Principal Curve in Arbitrary Dimension.R package version 1.1--12
#' http://cran.r-project.org/web/packages/princurve/index.html.
#'
#' Hastie,T. \& Stuetzle, W. (1989). Principal Curves.
#' Journal of the American Statistical Association, Vol. 84-406, 502--516.
#'
#' Hastie, T., Tibshirani, R. \& Friedman, J. (2008).
#' The Elements of Statistical Learning; Data Mining, Inference and Prediction. Springer, New York.
#'
#' @seealso sym.interval.pc
#' @keywords Principal Curve
#' @import princurve
centers.interval <- function(sym.data) {
  idn <- all(sym.data$sym.var.types == sym.data$sym.var.types[1])
  if (idn == FALSE) {
    stop("All variables have to be of the same type")
  }

  if ((sym.data$sym.var.types[1] != "$I")) {
    stop("Variables have to be continuos or Interval")
  } else {
    nn <- sym.data$N
  }
  mm <- sym.data$M
  centers <- matrix(0, nn, mm)
  centers <- as.data.frame(centers)
  rownames(centers) <- sym.data$sym.obj.names
  colnames(centers) <- sym.data$sym.var.names
  for (i in 1:nn) for (j in 1:mm) centers[i, j] <- (sym.var(sym.data, j)$var.data.vector[
        i,
        1
      ] + sym.var(sym.data, j)$var.data.vector[i, 2]) / 2

  return(centers)
}
#line 1 "/private/var/folders/x1/bc7ln59d11jddyfmvq0f4mwm0000gn/T/RtmpK8STdo/R.INSTALL582a7c381cc/RSDA/R/centers.interval.j.r"
#' process.histogram.variable
#' @keywords internal
centers.interval.j <- function(sym.data) {
  idn <- all(sym.data$sym.var.types == sym.data$sym.var.types[1])
  if (idn == FALSE) {
    stop("All variables have to be of the same type")
  }

  if ((sym.data$sym.var.types[1] != "$I")) {
    stop("Variables have to be continuos or Interval")
  } else {
    nn <- sym.data$N
  }
  mm <- sym.data$M
  centers <- matrix(0, nn, mm)
  ratios <- matrix(0, nn, mm)
  centers <- as.data.frame(centers)
  ratios <- as.data.frame(ratios)
  rownames(centers) <- sym.data$sym.obj.names
  colnames(centers) <- sym.data$sym.var.names
  rownames(ratios) <- sym.data$sym.obj.names
  colnames(ratios) <- sym.data$sym.var.names
  for (i in 1:nn) {
    for (j in 1:mm) {
      sym.var.act <- sym.var(sym.data, j)
      min.val <- sym.var.act$var.data.vector[i, 1]
      max.val <- sym.var.act$var.data.vector[i, 2]
      centers[i, j] <- (min.val + max.val) / 2
      ratios[i, j] <- (-min.val + max.val) / 2
    }
  }
  return(list(centers = centers, ratios = ratios))
}
#line 1 "/private/var/folders/x1/bc7ln59d11jddyfmvq0f4mwm0000gn/T/RtmpK8STdo/R.INSTALL582a7c381cc/RSDA/R/centers.interval2.r"
centers.interval2 <- function(sym.data) {
  idn <- all(sym.data$sym.var.types == sym.data$sym.var.types[1])
  if (idn == FALSE) {
    stop("All variables have to be of the same type")
  }

  if ((sym.data$sym.var.types[1] != "$I")) {
    stop("Variables have to be continuos or Interval")
  } else {
    nn <- sym.data$N
  }
  mm <- sym.data$M
  centers <- matrix(0, nn, mm)
  ratios <- matrix(0, nn, mm)
  centers <- as.data.frame(centers)
  ratios <- as.data.frame(ratios)
  rownames(centers) <- sym.data$sym.obj.names
  colnames(centers) <- sym.data$sym.var.names
  rownames(ratios) <- sym.data$sym.obj.names
  colnames(ratios) <- sym.data$sym.var.names
  for (i in 1:nn) {
    for (j in 1:mm) {
      sym.var.act <- sym.var(sym.data, j)
      min.val <- sym.var.act$var.data.vector[i, 1]
      max.val <- sym.var.act$var.data.vector[i, 2]
      centers[i, j] <- (min.val + max.val) / 2
      ratios[i, j] <- (-min.val + max.val) / 2
    }
  }
  return(list(centers = centers, ratios = ratios))
}
#line 1 "/private/var/folders/x1/bc7ln59d11jddyfmvq0f4mwm0000gn/T/RtmpK8STdo/R.INSTALL582a7c381cc/RSDA/R/cfa.CVPRealz.R"
#' cfa.CVPRealz
#' @keywords internal
cfa.CVPRealz <- function(sym.data, TFilas, TColumnas, TT, z) {
  ## z = eigenvector of matrix Z TT = Total
  NFil <- sym.data$N
  MCol <- sym.data$M
  aMin <- min(NFil, MCol)
  TablaDatos <- matrix(0, NFil, MCol) # To centers
  VPRealz <- matrix(0, aMin, aMin) # To Z
  if (MCol <= NFil) {
    for (i in 1:aMin) {
      for (j in 1:aMin) {
        VPRealz[i, j] <- abs(TT) * (sqrt(abs(TT)) * sqrt(TColumnas[i])) * z[
          i,
          j
        ]
      }
    }
  } else {
    for (i in 1:aMin) {
      for (j in 1:aMin) {
        VPRealz[i, j] <- abs(TT) * (sqrt(abs(TT)) * sqrt(TFilas[i])) * z[
          i,
          j
        ]
      }
    }
  }
  return(VPRealz)
}
#line 1 "/private/var/folders/x1/bc7ln59d11jddyfmvq0f4mwm0000gn/T/RtmpK8STdo/R.INSTALL582a7c381cc/RSDA/R/cfa.Czz.R"
#' cfa.Czz
#' @keywords internal
cfa.Czz <- function(sym.data, TFilas, TColumnas, VPRealz, d) {
  NFil <- sym.data$N
  MCol <- sym.data$M
  aMin <- min(NFil, MCol)
  aMax <- max(NFil, MCol)
  X <- matrix(0, NFil, MCol) # To centers
  zz <- matrix(0, NFil, MCol) # To z
  for (i in 1:NFil) {
    for (j in 1:MCol) {
      X[i, j] <- (sym.var(sym.data, j)$var.data.vector[i, 1] + sym.var(
        sym.data,
        j
      )$var.data.vector[i, 2]) / 2
    }
  }
  suma <- 0
  if (MCol <= NFil) {
    for (i in 1:aMin) {
      for (l in 1:aMax) {
        suma <- 0
        for (s in 1:aMin) {
          suma <- suma + (X[l, s] / TColumnas[s]) * VPRealz[s, i]
        }
        suma <- (1 / sqrt(d[i])) * suma
        zz[l, i] <- suma
      }
    }
  } else {
    for (i in 1:aMin) {
      for (l in 1:aMax) {
        suma <- 0
        for (s in 1:aMin) {
          suma <- suma + (X[s, l] / TFilas[s]) * VPRealz[s, i]
        }
        suma <- (1 / sqrt(d[i])) * suma
        zz[l, i] <- suma
      }
    }
  }
  return(zz)
}
#line 1 "/private/var/folders/x1/bc7ln59d11jddyfmvq0f4mwm0000gn/T/RtmpK8STdo/R.INSTALL582a7c381cc/RSDA/R/cfa.MatrixZ.R"
#' cfa.MatrixZ
#' @keywords internal
cfa.MatrixZ <- function(sym.data, TFilas, TColumnas) {
  Fil <- sym.data$N
  Col <- sym.data$M
  a <- min(Fil, Col)
  TablaDatos <- matrix(0, Fil, Col) # To centers
  A <- matrix(0, a, a) # To Z
  for (i in 1:Fil) {
    for (j in 1:Col) {
      TablaDatos[i, j] <- (sym.var(sym.data, j)$var.data.vector[i, 1] + sym.var(
        sym.data,
        j
      )$var.data.vector[i, 2]) / 2
    }
  }
  if (a == Col) {
    for (j in 1:a) {
      for (l in j:a) {
        suma <- 0
        for (i in 1:Fil) {
          suma <- suma + ((TablaDatos[i, j]) * (TablaDatos[i, l])) / (TFilas[i])
        }
        suma <- suma * (1 / sqrt(abs((TColumnas[j]) * (TColumnas[l]))))
        A[j, l] <- suma
        if (i != j) {
          A[l, j] <- suma
        }
      }
    }
  } else {
    for (j in 1:a) {
      for (l in j:a) {
        suma <- 0
        for (i in 1:Col) {
          suma <- suma + ((TablaDatos[j, i]) * (TablaDatos[l, i])) / (TColumnas[i])
        }
        suma <- suma * (1 / sqrt(abs((TFilas[j]) * (TFilas[l]))))
        A[j, l] <- suma
        if (i != j) {
          A[l, j] <- suma
        }
      }
    }
  }
  return(A)
}
#line 1 "/private/var/folders/x1/bc7ln59d11jddyfmvq0f4mwm0000gn/T/RtmpK8STdo/R.INSTALL582a7c381cc/RSDA/R/cfa.minmax.r"
#' cfa.minmax.new
#' @keywords internal
cfa.minmax.new <- function(sym.data, TFilas, TFilasMin, TFilasMax, TColumnas,
                           TColumnasMin, TColumnasMax, Total, VP, VPzz) {
  n <- sym.data$N
  m <- sym.data$M
  aMin <- min(n, m)
  X <- matrix(0, n, m)
  XMin <- matrix(0, n, m)
  XMax <- matrix(0, n, m)
  A <- matrix(0, n + m, aMin - 1)
  Min <- matrix(0, n + m, aMin - 1)
  Max <- matrix(0, n + m, aMin - 1)
  for (i in 1:n) {
    for (j in 1:m) {
      XMin[i, j] <- sym.var(sym.data, j)$var.data.vector[
        i,
        1
      ]
      XMax[i, j] <- sym.var(sym.data, j)$var.data.vector[
        i,
        2
      ]
      X[i, j] <- (sym.var(sym.data, j)$var.data.vector[
        i,
        1
      ] + sym.var(sym.data, j)$var.data.vector[
        i,
        2
      ]) / 2
    }
  }
  for (j in 1:m) {
    for (k in 1:n) {
      X[k, j] <- X[k, j] / Total
      XMin[k, j] <- XMin[k, j] / Total
      XMax[k, j] <- XMax[k, j] / Total
    }
  }
  if (m <= n) {
    for (alfa in 2:aMin) {
      for (i in 1:n) {
        suma <- 0
        SumaA <- 0
        SumaB <- 0
        SumaC <- 0
        SumaD <- 0
        for (j in 1:m) {
          suma <- suma + (X[i, j] * VP[j, alfa]) / TColumnas[j]
          if (VP[j, alfa] < 0) {
            SumaA <- SumaA + (XMax[i, j] * VP[j, alfa]) / TColumnas[j]
            SumaC <- SumaC + (XMin[i, j] * VP[j, alfa]) / TColumnas[j]
          }
          if (VP[j, alfa] > 0) {
            SumaB <- SumaB + (XMin[i, j] * VP[j, alfa]) / TColumnas[j]
            SumaD <- SumaD + (XMax[i, j] * VP[j, alfa]) / TColumnas[j]
          }
        }
        suma <- suma / TFilas[i]
        SumaA <- SumaA / TFilas[i]
        SumaB <- SumaB / TFilas[i]
        SumaC <- SumaC / TFilas[i]
        SumaD <- SumaD / TFilas[i]
        A[i, (alfa - 1)] <- suma
        Min[i, (alfa - 1)] <- (SumaA + SumaB)
        Max[i, (alfa - 1)] <- (SumaC + SumaD)
      }
    }
    for (alfa in 2:aMin) {
      for (j in 1:m) {
        suma <- 0
        SumaA <- 0
        SumaB <- 0
        SumaC <- 0
        SumaD <- 0
        for (i in 1:n) {
          suma <- suma + (X[i, j] * VPzz[i, alfa]) / TFilas[i]
          if (VPzz[i, alfa] < 0) {
            SumaA <- SumaA + (XMax[i, j] * VPzz[i, alfa]) / TFilas[i]
            SumaC <- SumaC + (XMin[i, j] * VPzz[i, alfa]) / TFilas[i]
          }
          if (VPzz[i, alfa] > 0) {
            SumaB <- SumaB + (XMin[i, j] * VPzz[i, alfa]) / TFilas[i]
            SumaD <- SumaD + (XMax[i, j] * VPzz[i, alfa]) / TFilas[i]
          }
        }
        suma <- suma / TColumnas[j]
        SumaA <- SumaA / TColumnas[j]
        SumaB <- SumaB / TColumnas[j]
        SumaC <- SumaC / TColumnas[j]
        SumaD <- SumaD / TColumnas[j]
        A[(n + j), (alfa - 1)] <- suma
        Min[(n + j), (alfa - 1)] <- (SumaA + SumaB)
        Max[(n + j), (alfa - 1)] <- (SumaC + SumaD)
      }
    }
  }
  else {
    for (alfa in 2:aMin) {
      for (j in 1:m) {
        suma <- 0
        SumaA <- 0
        SumaB <- 0
        SumaC <- 0
        SumaD <- 0
        for (i in 1:n) {
          suma <- suma + (X[i, j] * VP[i, alfa]) / TFilas[i]
          if (VP[i, alfa] < 0) {
            SumaA <- SumaA + (XMax[i, j] * VP[i, alfa]) / TFilas[i]
            SumaC <- SumaC + (XMin[i, j] * VP[i, alfa]) / TFilas[i]
          }
          if (VP[i, alfa] > 0) {
            SumaB <- SumaB + (XMin[i, j] * VP[i, alfa]) / TFilas[i]
            SumaD <- SumaD + (XMax[i, j] * VP[i, alfa]) / TFilas[i]
          }
        }
        suma <- suma / TColumnas[j]
        SumaA <- SumaA / TColumnas[j]
        SumaB <- SumaB / TColumnas[j]
        SumaC <- SumaC / TColumnas[j]
        SumaD <- SumaD / TColumnas[j]
        A[j, (alfa - 1)] <- suma
        Min[j, (alfa - 1)] <- (SumaA + SumaB)
        Max[j, (alfa - 1)] <- (SumaC + SumaD)
      }
    }
    for (alfa in 2:aMin) {
      for (i in 1:n) {
        suma <- 0
        SumaA <- 0
        SumaB <- 0
        SumaC <- 0
        SumaD <- 0
        for (j in 1:m) {
          suma <- suma + (X[i, j] * VPzz[j, alfa]) / TColumnas[j]
          if (VPzz[j, alfa] < 0) {
            SumaA <- SumaA + (XMax[i, j] * VPzz[j, alfa]) / TColumnas[j]
            SumaC <- SumaC + (XMin[i, j] * VPzz[j, alfa]) / TColumnas[j]
          }
          if (VPzz[j, alfa] > 0) {
            SumaB <- SumaB + (XMin[i, j] * VPzz[j, alfa]) / TColumnas[j]
            SumaD <- SumaD + (XMax[i, j] * VPzz[j, alfa]) / TColumnas[j]
          }
        }
        suma <- suma / TFilas[i]
        SumaA <- SumaA / TFilas[i]
        SumaB <- SumaB / TFilas[i]
        SumaC <- SumaC / TFilas[i]
        SumaD <- SumaD / TFilas[i]
        A[(m + i), (alfa - 1)] <- suma
        Min[(m + i), (alfa - 1)] <- (SumaA + SumaB)
        Max[(m + i), (alfa - 1)] <- (SumaC + SumaD)
      }
    }
  }
  return(list(Centers = A[1:n, ], Min = Min[1:n, ], Max = Max[1:n, ]))
}

#' cfa.minmax
#' @keywords internal
cfa.minmax <- function(sym.data, TFilas, TFilasMin, TFilasMax, TColumnas, TColumnasMin,
                       TColumnasMax, Total, VP, VPzz) {
  n <- sym.data$N
  m <- sym.data$M
  aMin <- min(n, m)
  X <- matrix(0, n, m)  # To centers
  XMin <- matrix(0, n, m)
  XMax <- matrix(0, n, m)
  A <- matrix(0, n + m, aMin - 1)
  Min <- matrix(0, n + m, aMin - 1)
  Max <- matrix(0, n + m, aMin - 1)
  for (i in 1:n) {
    for (j in 1:m) {
      XMin[i, j] <- sym.var(sym.data, j)$var.data.vector[i, 1]
      XMax[i, j] <- sym.var(sym.data, j)$var.data.vector[i, 2]
      X[i, j] <- (sym.var(sym.data, j)$var.data.vector[i, 1] + sym.var(sym.data,
                                                                       j)$var.data.vector[i, 2])/2
    }
  }
  for (j in 1:m) {
    for (k in 1:n) {
      X[k, j] <- X[k, j]/Total
      XMin[k, j] <- XMin[k, j]/Total
      XMax[k, j] <- XMax[k, j]/Total
    }
  }
  if (m <= n) {
    for (alfa in 2:aMin) {
      for (i in 1:n) {
        suma <- 0
        SumaA <- 0
        SumaB <- 0
        SumaC <- 0
        SumaD <- 0
        for (j in 1:m) {
          suma = suma + (X[i, j] * VP[j, alfa])/TColumnas[j]
          if (VP[j, alfa] < 0) {
            SumaA <- SumaA + (XMax[i, j] * VP[j, alfa])/TColumnas[j]
            SumaC <- SumaC + (XMin[i, j] * VP[j, alfa])/TColumnas[j]
          }
          if (VP[j, alfa] > 0) {
            SumaB <- SumaB + (XMin[i, j] * VP[j, alfa])/TColumnas[j]
            SumaD <- SumaD + (XMax[i, j] * VP[j, alfa])/TColumnas[j]
          }
        }
        suma <- suma/TFilas[i]
        SumaA <- SumaA/TFilas[i]
        SumaB <- SumaB/TFilas[i]
        SumaC <- SumaC/TFilas[i]
        SumaD <- SumaD/TFilas[i]
        A[i, (alfa - 1)] <- suma
        Min[i, (alfa - 1)] <- (SumaA + SumaB)
        Max[i, (alfa - 1)] <- (SumaC + SumaD)
      }
    }
    for (alfa in 2:aMin) {
      for (j in 1:m) {
        suma <- 0
        SumaA <- 0
        SumaB <- 0
        SumaC <- 0
        SumaD <- 0
        for (i in 1:n) {
          suma <- suma + (X[i, j] * VPzz[i, alfa])/TFilas[i]
          if (VPzz[i, alfa] < 0) {
            SumaA <- SumaA + (XMax[i, j] * VPzz[i, alfa])/TFilas[i]
            SumaC <- SumaC + (XMin[i, j] * VPzz[i, alfa])/TFilas[i]
          }
          if (VPzz[i, alfa] > 0) {
            SumaB <- SumaB + (XMin[i, j] * VPzz[i, alfa])/TFilas[i]
            SumaD <- SumaD + (XMax[i, j] * VPzz[i, alfa])/TFilas[i]
          }
        }
        suma <- suma/TColumnas[j]
        SumaA <- SumaA/TColumnas[j]
        SumaB <- SumaB/TColumnas[j]
        SumaC <- SumaC/TColumnas[j]
        SumaD <- SumaD/TColumnas[j]
        A[(n + j), (alfa - 1)] <- suma
        Min[(n + j), (alfa - 1)] <- (SumaA + SumaB)
        Max[(n + j), (alfa - 1)] <- (SumaC + SumaD)
      }
    }
  } else {
    for (alfa in 2:aMin) {
      for (j in 1:m) {
        suma <- 0
        SumaA <- 0
        SumaB <- 0
        SumaC <- 0
        SumaD <- 0
        for (i in 1:n) {
          suma = suma + (X[i, j] * VP[i, alfa])/TFilas[i]
          if (VP[i, alfa] < 0) {
            SumaA <- SumaA + (XMax[i, j] * VP[i, alfa])/TFilas[i]
            SumaC <- SumaC + (XMin[i, j] * VP[i, alfa])/TFilas[i]
          }
          if (VP[i, alfa] > 0) {
            SumaB <- SumaB + (XMin[i, j] * VP[i, alfa])/TFilas[i]
            SumaD <- SumaD + (XMax[i, j] * VP[i, alfa])/TFilas[i]
          }
        }
        suma <- suma/TColumnas[j]
        SumaA <- SumaA/TColumnas[j]
        SumaB <- SumaB/TColumnas[j]
        SumaC <- SumaC/TColumnas[j]
        SumaD <- SumaD/TColumnas[j]
        A[j, (alfa - 1)] <- suma
        Min[j, (alfa - 1)] <- (SumaA + SumaB)
        Max[j, (alfa - 1)] <- (SumaC + SumaD)
      }
    }
    for (alfa in 2:aMin) {
      for (i in 1:n) {
        suma <- 0
        SumaA <- 0
        SumaB <- 0
        SumaC <- 0
        SumaD <- 0
        for (j in 1:m) {
          suma <- suma + (X[i, j] * VPzz[j, alfa])/TColumnas[j]
          if (VPzz[j, alfa] < 0) {
            SumaA <- SumaA + (XMax[i, j] * VPzz[j, alfa])/TColumnas[j]
            SumaC <- SumaC + (XMin[i, j] * VPzz[j, alfa])/TColumnas[j]
          }
          if (VPzz[j, alfa] > 0) {
            SumaB <- SumaB + (XMin[i, j] * VPzz[j, alfa])/TColumnas[j]
            SumaD <- SumaD + (XMax[i, j] * VPzz[j, alfa])/TColumnas[j]
          }
        }
        suma <- suma/TFilas[i]
        SumaA <- SumaA/TFilas[i]
        SumaB <- SumaB/TFilas[i]
        SumaC <- SumaC/TFilas[i]
        SumaD <- SumaD/TFilas[i]
        A[(m + i), (alfa - 1)] = suma
        Min[(m + i), (alfa - 1)] <- (SumaA + SumaB)
        Max[(m + i), (alfa - 1)] <- (SumaC + SumaD)
      }
    }
  }
  return(list(Centers = A, Min = Min, Max = Max))
}

#line 1 "/private/var/folders/x1/bc7ln59d11jddyfmvq0f4mwm0000gn/T/RtmpK8STdo/R.INSTALL582a7c381cc/RSDA/R/cfa.scatterplot.R"
#' CFA Symbolic Scatter Plot
#' @aliases cfa.scatterplot
#' @name cfa.scatterplot
#' @author Oldemar Rodriguez Rojas
#' @description This function could be use to plot two
#' symbolic variables in a X-Y plane to special case
#' of Symbolic Correspondance Analysis.
#'
#' @usage cfa.scatterplot(sym.var.x, sym.var.y, num.gr1=0, labels = TRUE, ...)
#' @param sym.var.x First symbolic variable
#' @param sym.var.y First symbolic variable
#' @param num.gr1 Number of modes of the first variable
#' @param labels As in R plot function.
#' @param ... As in R plot function.
#'
#' @references Rodriguez, O. (2011).Correspondence Analysis for Symbolic MultiValued Variables.
#'  Workshop in Symbolic Data AnalysisNamur, Belgium.
#' @return Return a graphics.
#' @seealso sym.cfa
#' @keywords CFA Plot
#' @export
#' @import graphics
#'
cfa.scatterplot <- function(sym.var.x, sym.var.y, num.gr1 = 0, labels = TRUE, ...) {
  if (((sym.var.x$sym.var.types != "$C") || (sym.var.y$sym.var.types != "$C")) && ((sym.var.x$sym.var.types !=
    "$I") || (sym.var.y$sym.var.types != "$I"))) {
    stop("Impossible to plot this type of variable")
  }
  if ((sym.var.x$sym.var.types == "$C") && (sym.var.y$sym.var.types == "$C")) {
    if (labels == FALSE) {
      plot(sym.var.x$data, sym.var.y$data,
        xlab = sym.var.x$sym.var.names,
        ylab = sym.var.y$sym.var.names, ...
      )
    } else {
      ltext <- sym.var.x$sym.obj.names
      plot(sym.var.x$data, sym.var.y$data,
        type = "n",
        xlab = sym.var.x$sym.var.names, ylab = sym.var.y$sym.var.names, ...
      )
      text(sym.var.x$data, sym.var.y$data, ltext)
    }
  }
  if ((sym.var.x$sym.var.types == "$I") && (sym.var.y$sym.var.types == "$I")) {
    xmin1 <- min(sym.var.x$data[, 1])
    xmin2 <- min(sym.var.x$data[, 2])
    xmin <- min(xmin1, xmin2)
    xmax1 <- max(sym.var.x$data[, 1])
    xmax2 <- max(sym.var.x$data[, 2])
    xmax <- max(xmax1, xmax2)
    ymin1 <- min(sym.var.y$data[, 1])
    ymin2 <- min(sym.var.y$data[, 2])
    ymin <- min(ymin1, ymin2)
    ymax1 <- max(sym.var.y$data[, 1])
    ymax2 <- max(sym.var.y$data[, 2])
    ymax <- max(ymax1, ymax2)
    plot(c(xmin, xmax), c(ymin, ymax),
      type = "n", xlab = sym.var.x$sym.var.names, ylab = sym.var.y$sym.var.names,
      ...
    )
    for (i in 1:sym.var.x$N) {
      x1 <- sym.var.x$data[i, 1]
      y1 <- sym.var.y$data[i, 1]
      x2 <- sym.var.x$data[i, 2]
      y2 <- sym.var.y$data[i, 2]
      if (i <= num.gr1) {
        rect(x1, y1, x2, y2, lwd = 2, border = "red")
      } else {
        rect(x1, y1, x2, y2, lwd = 2, border = "blue")
      }
    }
    if (labels == TRUE) {
      ltext <- sym.var.x$sym.obj.names
      text(jitter(sym.var.x$data[, 1]), jitter(sym.var.y$data[
        ,
        1
      ]), ltext)
    }
  }
}
#line 1 "/private/var/folders/x1/bc7ln59d11jddyfmvq0f4mwm0000gn/T/RtmpK8STdo/R.INSTALL582a7c381cc/RSDA/R/cfa.scatterplot.gg.R"
#' Plot Interval Scatterplot
#'
#' @param x symbolic table with only one column.
#' @param y symbolic table with only one column.
#' @param sym.data original symbolic table.
#' @param pos.var column number of the variables to be plotted.
#'
#' @examples
#' data("ex_mcfa1")
#' sym.table <- classic.to.sym(ex_mcfa1, concept = "suspect",
#'                    variables.types = c(hair = type.set(),
#'                                        eyes = type.set(),
#'                                        region = type.set()))
#'
#' res <- sym.mcfa(sym.table, c(1,2))
#' mcfa.scatterplot(res[,1], res[,2], sym.data = sym.table, pos.var = c(1,2))

mcfa.scatterplot <- function(x,y, sym.data, pos.var) {
  var.names <- c()
  n.vars <- c()
  for (i in pos.var) {
    var.names <- c(var.names, sym.data[, i]$sym.var.names)
    n.vars <- c(n.vars, ncol(sym.data[, i]$data))
  }
  df <- cbind(x$data,y$data)
  colnames(df) <- c("C1","C1.1","C2","C2.1")
  df$var.name <- purrr::flatten_chr(purrr::map2(var.names, n.vars, ~rep(.x,.y)))
  df$cat.name <- row.names(df)

  ggplot(data = df) +
    geom_rect( mapping = aes(xmin = C1, xmax = C1.1, ymin = C2, ymax = C2.1, color = var.name), fill = NA, size = 1) +
    geom_text(aes(label = cat.name, x = C1, y = C2)) +
    theme_minimal() +
    labs(color = "Variables") +
    theme(legend.position = "bottom")
}
#line 1 "/private/var/folders/x1/bc7ln59d11jddyfmvq0f4mwm0000gn/T/RtmpK8STdo/R.INSTALL582a7c381cc/RSDA/R/cfa.totals.R"
#' cfa.totals
#' @keywords internal
cfa.totals <- function(sym.data) {
  Total <- 0
  TotalMin <- 0
  TotalMax <- 0
  N <- sym.data$N
  M <- sym.data$M
  TotalFilas <- rep(0, N)
  TotalColumnas <- rep(0, M)
  TotalFilasMin <- rep(0, N)
  TotalColumnasMin <- rep(0, M)
  TotalFilasMax <- rep(0, N)
  TotalColumnasMax <- rep(0, M)
  A <- matrix(0, N, M) # To centers
  CMin <- matrix(0, N, M)
  CMax <- matrix(0, N, M)
  for (i in 1:N) {
    for (j in 1:M) {
      CMin[i, j] <- sym.var(sym.data, j)$var.data.vector[i, 1]
      CMax[i, j] <- sym.var(sym.data, j)$var.data.vector[i, 2]
      A[i, j] <- (sym.var(sym.data, j)$var.data.vector[i, 1] + sym.var(
        sym.data,
        j
      )$var.data.vector[i, 2]) / 2
    }
  }
  # Centers Totals
  for (i in 1:N) {
    TotalFilas[i] <- sum(A[i, ])
  }
  for (j in 1:M) {
    TotalColumnas[j] <- sum(A[, j])
  }
  Total <- sum(TotalFilas)
  # To minimus
  for (i in 1:N) {
    TotalFilasMin[i] <- sum(CMin[i, ])
  }
  for (j in 1:M) {
    TotalColumnasMin[j] <- sum(CMin[, j])
  }
  TotalMin <- sum(TotalFilasMin)
  # To maximuns
  for (i in 1:N) {
    TotalFilasMax[i] <- sum(CMax[i, ])
  }
  for (j in 1:M) {
    TotalColumnasMax[j] <- sum(CMax[, j])
  }
  TotalMax <- sum(TotalFilasMax)
  return(list(
    Total = Total, TotalMin = TotalMin, TotalMax = TotalMax, TotalRows = TotalFilas,
    TotalColumns = TotalColumnas, TotalRowsMin = TotalFilasMin, TotalColumnsMin = TotalColumnasMin,
    TotalRowsMax = TotalFilasMax, TotalColumnsMax = TotalColumnasMax
  ))
}
#line 1 "/private/var/folders/x1/bc7ln59d11jddyfmvq0f4mwm0000gn/T/RtmpK8STdo/R.INSTALL582a7c381cc/RSDA/R/change.coord.j.r"
#' change.coord
#' @keywords internal
change.coord <- function(basis, points) {
  dim.points <- dim(points)
  dim.basis <- dim(basis)
  num.coord <- dim.points[2]

  matrix.change.coord <- matrix(rep(0, num.coord * num.coord * dim.points[1]), ncol = num.coord *
    num.coord)

  for (i in 1:num.coord) {
    x.i <- points[, i]
    for (j in 1:num.coord) {
      indx <- (i - 1) * num.coord + j
      matrix.change.coord[, indx] <- basis[i, j] * x.i
    }
  }
  return(matrix.change.coord)
}
#line 1 "/private/var/folders/x1/bc7ln59d11jddyfmvq0f4mwm0000gn/T/RtmpK8STdo/R.INSTALL582a7c381cc/RSDA/R/classic.to.sym.R"
#' Generate a symbolic data table
#' @aliases  classic.to.sym
#' @name classic.to.sym
#' @author Carlos Aguero.
#' @description Generate a symbolic data table from a classic data table.
#' @usage classic.to.sym(data, concept, variables, variables.types)
#'
#' @param data A data.frame.
#' @param concept These are the variable that we are going to use a concepts.
#' @param variables These are the variables that we want to include in the symbolic data table.
#' @param variables.types A vector with names and the type of symbolic data to use, the available types are type_histogram (), type_continuous (), type.set (), type.modal (), by default type_histogram () is used for numeric variables and type_modal () for the categorical variables.
#'
#' @return The symbolic data table.
#' @references Bock H-H. and Diday E. (eds.) (2000).
#' Analysis of Symbolic Data. Exploratory methods for extracting statistical information from
#' complex data. Springer, Germany.
#' @seealso read.sym.table
#' @examples
#' result <- classic.to.sym(data = iris,
#'               concept = "Species",
#'               variables = c(Sepal.Length,Sepal.Width,Petal.Length,Petal.Width))
#' result
#'
#' result <- classic.to.sym(data = iris,
#' concept = "Species", # concepto
#' variables = c(Sepal.Length,Sepal.Width,Petal.Length,Petal.Width), # variable a utilizar
#' variables.types = c(Sepal.Length = type.interval(), # tipo para cada una de las variable
#'              Sepal.Width = type.interval(),
#'              Petal.Length = type.interval(),
#'              Petal.Width = type.interval()))
#' result
#' @keywords symbolic data table
#' @export
#' @import sqldf
#'
classic.to.sym <- function(data = NULL, concept = NULL, variables = NULL, variables.types = NULL) {
  variables <- enexpr(variables)
  data <- add_concept(
    x = data,
    concept = concept,
    col.names = !!variables
  )
  vars.selected <- c(names(variables.types), colnames(data)[!colnames(data) %in% c(names(variables.types), "concept")])
  meta.data <- create.meta.data(data, variables.types)

  data. <- remove_meta_info(meta.data)
  symbolic.object <- list()
  symbolic.object$N <- nrow(data.)
  symbolic.object$M <- length(vars.selected)

  symbolic.object$sym.obj.names <- rownames(meta.data)
  symbolic.object$sym.var.names <- vars.selected
  symbolic.object$sym.var.types <- extract_sym_types(meta.data)

  length_starts <- extract_length_starts(meta.data)
  symbolic.object$sym.var.length <- length_starts$lengths
  symbolic.object$sym.var.starts <- length_starts$starts

  symbolic.object$meta <- meta.data
  symbolic.object$data <- data.
  class(symbolic.object) <- "sym.data.table"
  return(suppressWarnings(symbolic.object))
}

#' Symbolic interval type
#' @keywords internal
type.interval <- function() {
  interval <- function(x) {
    var.name <- colnames(x[, 2])
    value <- x[, 2]
    min_name <- paste0(var.name, ".interval.min")
    max_name <- paste0(tolower(var.name), ".interval.max")
    df <- x %>% dplyr::group_by(concept) %>% dplyr::summarise("$I", min(!!sym(var.name)), max(!!sym(var.name)))
    # df <- data_frame(unique(x$concept),"$I",min(value),max(value))
    colnames(df) <- c("concept", "$I", min_name, max_name)
    df
  }
  class(interval) <- c("funtion", "fun_interval")
  interval
}

#' Symbolic continuous type
#' @keywords internal
type.continuous <- function(.fun = mean) {
  continuous <- function(x) {
    .fun <- .fun
    var.name <- colnames(x[, 2])
    value <- x[, 2][[1]]
    var_name <- paste0(tolower(var.name), ".continuous")
    df <- x %>% dplyr::group_by(concept) %>% dplyr::summarise("$C", round(.fun(!!sym(var.name)), 2))
    colnames(df) <- c("concept", "$C", var_name)
    df
  }
  class(continuous) <- c("funtion", "fun_continuous")
  continuous
}

#' Symbolic histogram type
#' @keywords internal
type.histogram <- function(bins = NA_integer_) {
  histogram <- function(x) {
    bins. <- bins
    all <- x[, 2][[1]]
    if (is.na(bins.)) {
      breaks <- hist(all, plot = F, right = F)$breaks
    } else {
      breaks <- hist(all, plot = F, right = F, breaks = bins)$breaks
    }
    i <- 1:(length(breaks) - 1)
    j <- 2:(length(breaks))
    bins <- gsub("\\s", "", paste(format(breaks[i], scientific = F), format(breaks[j], scientific = F), sep = ","))
    bins <- c(paste0("[", bins[-length(bins)], ")"), paste0("[", bins[length(bins)], "]"))

    calculate.hist <- x %>%
      dplyr::group_by(concept) %>%
      dplyr::do(hist = hist(.[, 2][[1]], plot = F, right = F, breaks = breaks)$counts)
    calculate.probs <- calculate.hist %>%
      split(calculate.hist$concept) %>%
      purrr::map_dfr(~ as.data.frame(t(round(.$hist[[1]] / sum(.$hist[[1]]), 2))))

    var_name <- paste0(tolower(colnames(x[, 2])), ".hist")
    df.out <- data.frame(concept = calculate.hist$concept, `$H` = "$H", var_name = length(bins), calculate.probs)
    colnames(df.out) <- c("concept", "$H", var_name, bins)
    tibble::as_data_frame(df.out)
  }
  class(histogram) <- c("funtion", "fun_histogram")
  histogram
}

#' Symbolic set type
#' @keywords internal
type.set <- function() {
  set <- function(x) {
    if (!is.factor(x[, 2, drop = T])) {
      # se combierte la variable a factor
      levels. <- unique(x[2][[1]])
      levels. <- levels.[order(levels.)]
      new.factor <- factor(x = x[2][[1]], levels = levels.)
      x[, 2] <- new.factor
    }

    # se calcula la frecuencia para de las categorias para cada uno de los conceptos
    split.df <- x %>% split(x$concept)
    props.df <- split.df %>% purrr::map_dfr(~ as.data.frame(t(ifelse(as.numeric(table(.[, 2])) > 0L, 1L, 0L))))

    # se completa el data.frame con tipo, largo y nombres de columnas
    var.name <- paste0(gsub("\\s", ".", tolower(colnames(x[, 2]))), ".set")
    out.df <- cbind(names(split.df), "$S", length(levels(x[, 2, drop = T])), props.df)
    colnames(out.df) <- c("concept", "$S", var.name, levels(x[, 2, drop = T]))
    out.df
  }
  class(set) <- c("funtion", "fun_set")
  set
}

#' Symbolic modal type
#' @keywords internal
type.modal <- function() {
  modal <- function(x) {
    # se calcula la frecuencia para de las categorias para cada uno de los conceptos
    split.df <- x %>% split(x$concept)
    props.df <- split.df %>% purrr::map_dfr(~ as.data.frame(t(as.numeric(prop.table(table(.[, 2]))))))

    # se completa el data.frame con tipo, largo y nombres de columnas
    var.name <- paste0(gsub("\\s", ".", tolower(colnames(x[, 2]))), ".modal")
    out.df <- cbind(names(split.df), "$M", length(levels(x[, 2][[1]])), props.df)
    colnames(out.df) <- c("concept", "$M", var.name, levels(x[, 2][[1]]))
    out.df
  }
  class(modal) <- c("funtion", "fun_modal")
  modal
}

#' Symbolic guest type
#' @keywords internal
type.symbolic <- function() {
  function(x) {
    type.numeric <- is.numeric(x[, 2][[1]])
    if (!type.numeric) {
      return(type.modal()(x))
    } else {
      return(type.interval()(x))
    }
  }
}

#' add the concept
#' @keywords internal
add_concept <- function(x = NULL, concept = NULL, col.names = NULL) {
  x <- as_data_frame(x)
  col.names <- enexpr(col.names) # enexpr : captura el objeto y el enviroment
  concept <- syms(concept) # sym : convierte a simbolo
  var.names <- names(x)
  df <- x[, tidyselect::vars_select(var.names, !!col.names, -c(!!!concept))]
  var.concepts <- x[, tidyselect::vars_select(var.names, !!!concept)]
  # var.concepts <- select(x, !!!concept)
  # df <- select(x,!!col.names)
  col_concept <- apply(var.concepts, 1, function(x) paste0(x, collapse = ":"))
  df <- cbind(concept = col_concept, df)
  as_data_frame(df)
}

#' Extract meta data
#' @keywords internal
create.meta.data <- function(x = NULL, col.types = NULL) {
  vars.selected <- c(names(col.types), colnames(x)[!colnames(x) %in% c(names(col.types), "concept")])
  vars.nof <- colnames(x)[!colnames(x) %in% c(names(col.types), "concept")]
  funs. <- c(col.types, purrr::map(seq_len(length(vars.nof)), ~ type.symbolic())) # cambio de nombre para uso interno

  meta.data <- list()
  for (i in seq_len(length(vars.selected))) {
    meta.data[[i]] <- x %>% dplyr::select(concept, !!sym(vars.selected[i])) %>% funs.[[i]]()
  }

  suppressWarnings(meta.data <- Reduce(
    function(dtf1, dtf2) merge(dtf1, dtf2, by = "concept", suffixes = c("", ""), all = TRUE),
    meta.data
  ))
  meta.data <- as.data.frame(meta.data)
  rownames(meta.data) <- meta.data$concept
  meta.data$concept <- NULL
  return(meta.data)
}

#' Remove meta data
#' @keywords internal
remove_meta_info <- function(meta.data = NULL) {
  meta.data <- as_data_frame(meta.data, validate = F)
  vars.remove1 <- which(colnames(meta.data) %in% c("$I", "$C"))
  vars.remove2 <- which(colnames(meta.data) %in% c("$H", "$M", "$S"))
  var.remove <- c(vars.remove1, vars.remove2, vars.remove2 + 1)
  meta.data[, -var.remove]
}

#' Get symbolic types
#' @keywords internal
extract_sym_types <- function(meta.data) {
  vars.remove <- which(colnames(meta.data) %in% c("$I", "$C", "$H", "$M", "$S"))
  colnames(meta.data)[vars.remove]
}

#' Get symbolic data length
#' @keywords internal
extract_length_starts <- function(meta.data) {
  syms <- extract_sym_types(meta.data)
  l <- which(colnames(meta.data) %in% c("$I", "$H", "$C", "$M", "$S"))
  length_and_starts <- list()
  length_and_starts$starts <- ifelse(syms %in% c("$I", "$C"), l + 1, ifelse(syms %in% c("$H", "$M", "$S"), l + 2, NA))
  length_and_starts$lengths <- ifelse(syms %in% c("$C"), 1, ifelse(syms %in% c("$I"), 2, ifelse(syms %in% c("$H", "$S", "$M"), as.numeric(meta.data[1, l + 1]), NA)))
  return(length_and_starts)
}

#' Extract or replace parts of a Symbolic Data Table
#' @keywords internal
#' @export
`[.sym.data.table` <- function(x, i, j) {
  out <- x
  if (!missing(j)) {
    if (any(j > length(out$sym.var.names))) {
      stop("undefined columns selected")
    }

    meta.data <- data.frame(row.names = out$sym.obj.names, check.names = F)
    real.data <- data.frame(row.names = out$sym.obj.names, check.names = F)
    new.var.l <- c()
    new.var.s <- c()

    if (any(j < 0)) {
      j <- seq_along(out$sym.var.names)[j]
    }

    for (columns in j) {
      for (column in columns) {
        type <- out$sym.var.types[column]
        var.l <- out$sym.var.length[column]
        var.s <- out$sym.var.starts[column]

        if (type %in% c("$H", "$M", "$S")) {
          new.var.s <- c(new.var.s, ncol(meta.data) + 3)

          data. <- out$meta[, (var.s - 2):(var.s + (var.l - 1))]
          meta.data <- cbind(meta.data, data.)

          data. <- out$meta[, (var.s):(var.s + (var.l - 1))]
          real.data <- cbind(real.data, data.)

          new.var.l <- c(new.var.l, ncol(data.))
        }
        if (type %in% c("$I")) {
          new.var.s <- c(new.var.s, ncol(meta.data) + 2)
          new.var.l <- c(new.var.l, 2)

          data. <- out$meta[, (var.s - 1):(var.s + (var.l - 1))]
          meta.data <- cbind(meta.data, data.)

          data. <- out$meta[, (var.s):(var.s + 1)]
          real.data <- cbind(real.data, data.)
        }
        if (type %in% c("$C")) {
          new.var.s <- c(new.var.s, ncol(meta.data) + 2)
          new.var.l <- c(new.var.l, 1)
          data. <- out$meta[, (var.s - 1):(var.s)]
          meta.data <- cbind(meta.data, data.)

          data. <- out$meta[var.s]
          real.data <- cbind(real.data, data.)
        }
      }
    }
    out$meta <- meta.data
    out$data <- real.data
    out$sym.var.names <- out$sym.var.names[j]
    out$sym.var.types <- out$sym.var.types[j]
    out$sym.var.length <- out$sym.var.length[j]
    out$sym.var.starts <- out$sym.var.starts[j]
    out$sym.var.starts <- new.var.s
    out$sym.var.length <- new.var.l
  }
  if (!missing(i)) {
    if (any(i > length(out$sym.obj.names))) {
      stop("undefined rows selected")
    }
    out$sym.obj.names <- out$sym.obj.names[i]
    out$data <- out$data[i, ]
    out$meta <- out$meta[i, ]
  }
  out$N <- length(out$sym.obj.names)
  out$M <- length(out$sym.var.names)
  out
  return(out)
}


#' Printing Symbolic Data Table
#'
#' @param x Object of class sym.data.table
#' @param ... optional arguments to print o format method
#'
#' @export
print.sym.data.table <- function(x, ...) {
  cat(
    "# A Symbolic Data Table : ", nrow(x$meta), " x ", length(x$sym.var.starts),
    "\n"
  )

  print(format_sym_vars(x), ...)
}

#' Pander method for symbolic data table
#'
#' Prints a symbolic data table in Pandoc's markdown
#' @param x a symbolic data table
#' @param caption caption (string) to be shown under the table
#' @param ... optional parameters passed to raw pandoc.table function
#' @export
pander.sym.data.table <- function(x, caption = attr(x, "caption"), ...) {
  if (is.null(caption)) {
    caption <- paste0(
      "A Symbolic Data Table : ", nrow(x$meta), " x ", length(x$sym.var.starts),
      "\n"
    )
  }
  pander::pander(format_sym_vars(x), caption, ...)
}



#' format.sym.vars
#' @keywords internal
format_sym_vars <- function(x) {
  out.table <- c()
  for (i in seq_len(x$M)) {
    var.type <- x$sym.var.types[i]
    var <- switch(var.type, `$C` = format_continuous_var(x, i), `$M` = format_modal_var(
      x,
      i
    ), `$H` = format_hist_var(x, i), `$S` = format_set_var(x, i), `$I` = format_interval_var(
      x,
      i
    ))
    out.table <- cbind(out.table, var)
  }
  out.table <- data.frame(out.table)
  colnames(out.table) <- x$sym.var.names
  rownames(out.table) <- x$sym.obj.names
  return(out.table)
}

#' format.hist.var
#' @keywords internal
format_hist_var <- function(x, i) {
  var <- x[, i]$meta
  var <- var[, -c(1, 2)]
  out <- apply(var, 1, function(x) spark_bar(as.numeric(x)))
  # out <- apply(var, 1, function(x) {
  #   paste0(names(x), ":", (round(x, 2) * 100), "%", collapse = " ")
  # })
  return(out)
}

#' format.set.var
#' @keywords internal
format_set_var <- function(x, i) {
  var <- x[, i]$meta
  var <- var[, -c(1, 2)]
  k <- colnames(var)
  out <- apply(var, 1, function(x) {
    paste0("{", paste0(k[as.logical(x)], collapse = ","), "}")
  })
  return(out)
}


#' format.modal.var
#' @keywords internal
format_modal_var <- function(x, i) {
  var <- x[, i]$meta
  var <- var[, -c(1, 2)]
  out <- apply(var, 1, function(x) {
    paste0(stringr::str_trunc(names(x), 3), ":", (round(x, 2) * 100), "% ", collapse = "")
  })
  return(out)
}

#' format.continuous.var
#' @keywords internal
format_continuous_var <- function(x, i) {
  var <- x[, i]$meta
  var <- var[, -1]
  out <- as.character(var)
  return(out)
}


#' format.interval.var
#' @keywords internal
format_interval_var <- function(x, i) {
  var <- x[, i]$meta
  var <- var[, -1]
  out <- paste0("[", round(var[, 1], 2), ",", round(var[, 2], 2), "]")
  return(out)
}

#' format.histogram bars.
#' @keywords internal
spark_bar <- function(x, safe = T) {
  stopifnot(is.numeric(x))

  bars <- vapply(0x2581:0x2588, intToUtf8, character(1))
  if (safe) {
    bars <- bars[-c(4, 8)]
  }

  factor <- cut(
    x,
    breaks = seq(0, 1, length = length(bars) + 1),
    labels = bars,
    include.lowest = TRUE
  )
  chars <- as.character(factor)
  chars[is.na(chars)] <- bars[length(bars)]

  return(paste0(chars, collapse = ""))
}
#line 1 "/private/var/folders/x1/bc7ln59d11jddyfmvq0f4mwm0000gn/T/RtmpK8STdo/R.INSTALL582a7c381cc/RSDA/R/cor.sym.data.table.R"
#' Generic function for the correlation
#' @name cor
#' @aliases cor
#' @author Oldemar Rodriguez Rojas
#' @description This function compute the symbolic correlation
#' @param x A symbolic variable.
#' @param y A symbolic variable.
#' @param use An optional character string giving a method for computing
#' covariances in the presence of missing values. This must be (an abbreviation of)
#'  one of the strings 'everything', 'all.obs', 'complete.obs', 'na.or.complete',
#'  or 'pairwise.complete.obs'.
#' @param method The method to be use.
#' @param ... As in R cor function.
#'
#' @return Return a real number in [-1,1].
#' @references
#' Billard L. and  Diday E. (2006).
#' Symbolic data analysis: Conceptual statistics and data mining. Wiley, Chichester.
#'
#' Rodriguez, O. (2000).
#' Classification et Modeles Lineaires en Analyse des Donnees Symboliques. Ph.D. Thesis,
#' Paris IX-Dauphine University.
#'
#' @examples
#' data(example3)
#' sym.data <- example3
#' cor(sym.data[,1], sym.data[,4], method='centers')
#' cor(sym.data[,2], sym.data[,6], method='centers')
#' cor(sym.data[,2], sym.data[,6], method='billard')
#' @keywords Symbolic Correlation
cor <- function(x, ...) {
  UseMethod("cor", x)
}

#' @rdname cor
#' @export
cor.default <- function(x, y = NULL, use = "everything", method = c(
                          "pearson", "kendall",
                          "spearman"
                        ), ...) {
  stats::cor(x, y, use, method)
}

#' @rdname cor
#' @export
cor.sym.data.table <- function(x, y, method = c("centers", "interval", "billard", "modal"),
                               ...) {
  method <- match.arg(method)
  if (method == "centers") {
    if ((x$sym.var.types == "$C") && (y$sym.var.types == "$C")) {
      return(cor(x$data[, 1], y$data[, 1]))
    }
    if ((x$sym.var.types == "$I") && (y$sym.var.types == "$I")) {
      return(cor((x$data[, 1] + x$data[, 2]) / 2, (y$data[, 1] + y$data[, 2]) / 2))
    } else {
      stop("Impossible to compute the Standard Deviation for this type of variable with this method")
    }
  }
  if (method == "billard") {
    if ((x$sym.var.types == "$I") && (y$sym.var.types == "$I")) {
      return(cov(x, y, method = "billard") / (sd(x, method = "billard") * sd(y,
        method = "billard"
      )))
    }
  }
}
#line 1 "/private/var/folders/x1/bc7ln59d11jddyfmvq0f4mwm0000gn/T/RtmpK8STdo/R.INSTALL582a7c381cc/RSDA/R/cov.sym.data.table.R"
#' Generic function for the covariance
#' @name cov
#' @aliases cov
#' @author Oldemar Rodriguez Rojas
#' @description This function compute the symbolic covariance.
#' @param x First symbolic variables.
#' @param y Second symbolic variables.
#' @param use an optional character string giving a method for computing
#' covariances in the presence of missing values. This must be (an abbreviation of)
#'  one of the strings 'everything', 'all.obs', 'complete.obs', 'na.or.complete',
#'  or 'pairwise.complete.obs'.
#' @param method The method to be use.
#' @param na.rm As in R cov function.
#' @param ... As in R cov function.
#'
#' @return Return a real number.
#' @references
#' Billard L. and  Diday E. (2006).
#' Symbolic data analysis: Conceptual statistics and data mining. Wiley, Chichester.
#'
#' Rodriguez, O. (2000).
#' Classification et Modeles Lineaires en Analyse des Donnees Symboliques. Ph.D. Thesis,
#' Paris IX-Dauphine University.
#'
#' @examples
#' data(example3)
#' sym.data <- example3
#' cov(sym.data[,1], sym.data[,4], method='centers')
#' cov(sym.data[,2],sym.data[,6], method='centers')
#' cov(sym.data[,2],sym.data[,6], method='billard')
#'
#' @keywords Symbolic Covariance
#'
cov <- function(x, ...) {
  UseMethod("cov", x)
}

#' @rdname cov
#' @export
cov.default <- function(x, y = NULL, use = "everything", method = c(
                          "pearson", "kendall",
                          "spearman"
                        ), ...) {
  stats::cov(x, y, use, method)
}

#' @rdname cov
#' @export
cov.sym.data.table <- function(x, y, method = c("centers", "interval", "billard", "modal"),
                               na.rm = FALSE, ...) {
  Gj <- function(a, b, vmean) {
    if ((a + b) / 2 <= vmean) {
      return(-1)
    } else {
      return(1)
    }
  }
  Qj <- function(a, b, vmean) {
    return((a - vmean)^2 + (a - vmean) * (b - vmean) + (b - vmean)^2)
  }
  method <- match.arg(method)
  if (method == "centers") {
    if ((x$sym.var.types == "$C") && (y$sym.var.types == "$C")) {
      return(cov(x$data[, 1], y$data[, 1]))
    }
    if ((x$sym.var.types == "$I") && (y$sym.var.types == "$I")) {
      return(cov((x$data[, 1] + x$data[, 2]) / 2, (y$data[, 1] + y$data[, 2]) / 2))
    } else {
      stop("Impossible to compute the Standard Deviation for this type of variable with this method")
    }
  }
  if (method == "billard") {
    if ((x$sym.var.types == "$I") && (y$sym.var.types == "$I")) {
      ss <- 0
      vmean.x <- mean(x, method = "centers")
      vmean.y <- mean(y, method = "centers")
      for (i in 1:(x$N)) {
        ss <- ss + Gj(x$data[i, 1], x$data[i, 2], vmean.x) * Gj(
          y$data[i, 1],
          y$data[i, 2], vmean.y
        ) * sqrt(Qj(x$data[i, 1], x$data[i, 2], vmean.x) *
          Qj(y$data[i, 1], y$data[i, 2], vmean.y))
      }
      return((1 / (3 * x$N)) * ss)
    } else {
      stop("Impossible to compute the Standard Deviation for this type of variable with this method")
    }
  }
}
#line 1 "/private/var/folders/x1/bc7ln59d11jddyfmvq0f4mwm0000gn/T/RtmpK8STdo/R.INSTALL582a7c381cc/RSDA/R/data.R"
#' @name Table7
#' @title Table7
#' @description example for the dist.interval function.
#' @keywords datasets
"table7"

#' @name ex_mcfa1
#' @title Multiple Correspondence Analysis Example
#' @description example for the sym.mcfa function.
#' @examples
#' data("ex_mcfa1")
#' sym.table <- classic.to.sym(ex_mcfa1, concept = "suspect",
#'                    variables.types = c(hair = type.set(),
#'                                        eyes = type.set(),
#'                                        region = type.set()))
#'
#' res <- sym.mcfa(sym.table, c(1,2))
#' mcfa.scatterplot(res[,1], res[,2], sym.data = sym.table, pos.var = c(1,2))
#'
#' @keywords datasets
"ex_mcfa1"

#' @name ex_mcfa2
#' @title Multiple Correspondence Analysis Example
#' @description example for the sym.mcfa function.
#' @examples
#' data("ex_mcfa2")
#'
#'ex <- classic.to.sym(ex_mcfa2, concept = "employee_id", variables = everything(),
#'                     variables.types = c(salary = type.set(),
#'                                         region = type.set(),
#'                                         evaluation = type.set(),
#'                                         years_worked = type.set()))
#'
#'res <- sym.mcfa(ex, c(1,2,3,4))
#'mcfa.scatterplot(res[,1], res[,2], sym.data = ex, pos.var = c(1,2,3,4))
#'
#' @keywords datasets
"ex_mcfa2"


#' @name abalone
#' @title SODAS XML data file.
#' @description Example of SODAS XML data file converted in a CSV file in RSDA format.
#' @usage data(abalone)
#' @format abalone<-SODAS.to.RSDA('C:/Program Files (x86)/DECISIA/SODAS version 2.0/bases/abalone.xml)
#' @source http://www.info.fundp.ac.be/asso/sodaslink.htm
#' @references Bock H-H. and Diday E. (eds.) (2000).Analysis of Symbolic Data. Exploratory methods
#' for extracting statistical information fromcomplex data. Springer, Germany.
#' @examples
#' data(abalone)
#' res<-sym.interval.pca(abalone,'centers')
#' class(res$Sym.Components) <- c('sym.data.table')
#' sym.scatterplot(res$Sym.Components[,1],res$Sym.Components[,2],
#' labels=TRUE,col='red',main='PCA Oils Data')
#' sym.scatterplot3d(res$Sym.Components[,1],res$Sym.Components[,2],
#' res$Sym.Components[,3],color='blue',main='PCA Oils Data')
#' sym.scatterplot.ggplot(res$Sym.Components[,1],
#' res$Sym.Components[,2],labels=TRUE)
#' sym.circle.plot(res$Sym.Prin.Correlations)
#' @keywords datasets
"abalone"


#' @name Cardiological
#' @title Cardiological data example
#' @description Cardiological interval data example.
#' @usage data(Cardiological)
#' @references Billard L. and  Diday E. (2006).Symbolic data analysis:
#' Conceptual statistics and data mining. Wiley, Chichester.
#' @examples
#' data(Cardiological)
#' car.data <- Cardiological
#' res.cm <- sym.lm(Pulse~Syst+Diast,sym.data=car.data,method='cm')
#' pred.cm <- predictsym.lm(res.cm,car.data,method='cm')
#' RMSE.L(sym.var(car.data,1),pred.cm$Fitted)
#' RMSE.U(sym.var(car.data,1),pred.cm$Fitted)
#' R2.L(sym.var(car.data,1),pred.cm$Fitted)
#' R2.U(sym.var(car.data,1),pred.cm$Fitted)
#' deter.coefficient(sym.var(car.data,1),pred.cm$Fitted)
#' @keywords datasets
"Cardiological"


#' @name ex_cfa1
#' @aliases ex_cfa1
#' @title Correspondence Analysis Example
#' @description Correspondence Analysis for Symbolic MultiValued Variables example.
#' @usage data(ex_cfa1)
#' @references Rodriguez, O. (2011).
#' Correspondence Analysis for Symbolic MultiValued Variables. Workshop in Symbolic
#' Data Analysis Namur, Belgium
#' @keywords datasets
"ex_cfa1"

#' @name ex_cfa2
#' @aliases ex_cfa2
#' @title Correspondence Analysis Example
#' @description Correspondence Analysis for Symbolic MultiValued Variables example.
#' @usage data(ex_cfa2)
#' @references Rodriguez, O. (2011).
#' Correspondence Analysis for Symbolic MultiValued Variables. Workshop in Symbolic
#' Data Analysis Namur, Belgium
#' @keywords datasets
"ex_cfa2"


#' @name ex1_db2so
#' @aliases ex1_db2so
#' @title Data example to generate symbolic objets
#' @description This is a small data example to generate symbolic objets.
#' @usage data(ex1_db2so)
#' @references Bock H-H. and Diday E. (eds.) (2000).
#' Analysis of Symbolic Data. Exploratory methods for extracting statistical information from
#' complex data. Springer, Germany.
#' @examples
#' data(ex1_db2so)
#' ex1 <- ex1_db2so
#' result <- classic.to.sym(ex1, concept=c('state', 'sex'),
#'                          variables = c(county, group, age, age),
#'                          variables.types = c(county = type.continuous(),
#'                          group = type.histogram(),
#'                          age = type.histogram(),
#'                           age = type.set()))
#' result
#' @keywords datasets
"ex1_db2so"


#' @name example1
#' @aliases example1
#' @title Data Example 1
#' @description This a symbolic data table with variables of continuos, interval,
#' histogram and set types.
#' @usage data(example1)
#' @format The labels $C means that follows a continuous variable, $I means an interval
#' variable, $H means a histogram variables and $S means set variable. In the
#' first row each labels should be follow of a name to variable and to the case
#' of histogram a set variables types the names of the modalities (categories).
#' In data rows for continuous variables we have just one value, for interval
#' variables we have the minimum and the maximum of the interval, for histogram
#' variables we have the number of modalities and then the probability of each
#' modality and for set variables we have the cardinality of the set and next
#' the elements of the set. \cr

#' The format is the *.csv file is: \cr

#'       $C   F1 $I F2 F2 $M F3  M1  M2  M3 $S F4 e a 2 3 g b 1 4 i k c d \cr
#' Case1 $C  2.8 $I  1  2 $M  3 0.1 0.7 0.2 $S 12 1 0 0 0 1 0 0 0 1 1 0 0 \cr
#' Case2 $C  1.4 $I  3  9 $M  3 0.6 0.3 0.1 $S 12 0 1 0 0 0 1 0 0 0 0 1 1 \cr
#' Case3 $C  3.2 $I -1  4 $M  3 0.2 0.2 0.6 $S 12 0 0 1 0 0 1 1 0 0 0 1 0 \cr
#' Case4 $C -2.1 $I  0  2 $M  3 0.9 0.0 0.1 $S 12 0 1 0 1 0 0 0 1 0 0 1 0 \cr
#' Case5 $C -3.0 $I -4 -2 $M  3 0.6 0.0 0.4 $S 12 1 0 0 0 1 0 0 0 1 1 0 0 \cr

#' The internal format is:\cr

#'   $N \cr

#' [1] 5 \cr

#' $M \cr

#' [1] 4 \cr

#' $sym.obj.names \cr

#' [1] 'Case1' 'Case2' 'Case3' 'Case4' 'Case5' \cr

#' $sym.var.names \cr

#' [1] 'F1' 'F2' 'F3' 'F4' \cr

#' $sym.var.types

#' [1] '$C' '$I' '$H' '$S' \cr

#' $sym.var.length \cr

#' [1] 1 2 3 4 \cr

#' $sym.var.starts \cr

#' [1]  2  4  8 13 \cr

#' $meta \cr
#'
#'       $C   F1 $I F2 F2 $M F3  M1  M2  M3 $S F4 e a 2 3 g b 1 4 i k c d
#' Case1 $C  2.8 $I  1  2 $M  3 0.1 0.7 0.2 $S 12 1 0 0 0 1 0 0 0 1 1 0 0
#' Case2 $C  1.4 $I  3  9 $M  3 0.6 0.3 0.1 $S 12 0 1 0 0 0 1 0 0 0 0 1 1
#' Case3 $C  3.2 $I -1  4 $M  3 0.2 0.2 0.6 $S 12 0 0 1 0 0 1 1 0 0 0 1 0
#' Case4 $C -2.1 $I  0  2 $M  3 0.9 0.0 0.1 $S 12 0 1 0 1 0 0 0 1 0 0 1 0
#' Case5 $C -3.0 $I -4 -2 $M  3 0.6 0.0 0.4 $S 12 1 0 0 0 1 0 0 0 1 1 0 0

#' $data \cr
#'         F1 F2 F2.1  M1  M2  M3 e a 2 3 g b 1 4 i k c d
#' Case1  2.8  1    2 0.1 0.7 0.2 1 0 0 0 1 0 0 0 1 1 0 0
#' Case2  1.4  3    9 0.6 0.3 0.1 0 1 0 0 0 1 0 0 0 0 1 1
#' Case3  3.2 -1    4 0.2 0.2 0.6 0 0 1 0 0 1 1 0 0 0 1 0
#' Case4 -2.1  0    2 0.9 0.0 0.1 0 1 0 1 0 0 0 1 0 0 1 0
#' Case5 -3.0 -4   -2 0.6 0.0 0.4 1 0 0 0 1 0 0 0 1 1 0 0
#'
#' @references Bock H-H. and Diday E. (eds.) (2000).
#' Analysis of Symbolic Data. Exploratory methods for extracting statistical information from
#' complex data. Springer, Germany.
#' @examples
#' data(example1)
#' @keywords datasets
"example1"


#' @name example2
#' @aliases example2
#' @title Data Example 2
#' @description This a symbolic data table with variables of continuos, interval,
#' histogram and set types.
#' @usage data(example2)
#' @format
#'       $C   F1 $I F2 F2 $M F3  M1  M2  M3 $C   F4 $S F5 e a 2 3 g b 1 4 i k c d\cr
#' Case1 $C  2.8 $I  1  2 $M  3 0.1 0.7 0.2 $C  6.0 $S 12 1 0 0 0 1 0 0 0 1 1 0 0\cr
#' Case2 $C  1.4 $I  3  9 $M  3 0.6 0.3 0.1 $C  8.0 $S 12 0 1 0 0 0 1 0 0 0 0 1 1\cr
#' Case3 $C  3.2 $I -1  4 $M  3 0.2 0.2 0.6 $C -7.0 $S 12 0 0 1 0 0 1 1 0 0 0 1 0\cr
#' Case4 $C -2.1 $I  0  2 $M  3 0.9 0.0 0.1 $C  0.0 $S 12 0 1 0 1 0 0 0 1 0 0 1 0\cr
#' Case5 $C -3.0 $I -4 -2 $M  3 0.6 0.0 0.4 $C -9.5 $S 12 1 0 0 0 1 0 0 0 1 1 0 0\cr
#'
#' @examples
#' data(example2)
#' display.sym.table(example2)
#' @keywords datasets
"example2"


#' @name example3
#' @aliases example3
#' @title Data Example 3
#' @description This a symbolic data table with variables of continuos, interval,
#' histogram and set types.
#' @usage data(example3)
#' @format
#'       $C   F1 $I F2 F2 $M F3  M1  M2  M3 $C   F4 $S F5 e a 2 3 g b 1 4 i k c d $I     F6    F6 $I F7 F7
#' Case1 $C  2.8 $I  1  2 $M  3 0.1 0.7 0.2 $C  6.0 $S 12 1 0 0 0 1 0 0 0 1 1 0 0 $I   0.00 90.00 $I  9 24
#' Case2 $C  1.4 $I  3  9 $M  3 0.6 0.3 0.1 $C  8.0 $S 12 0 1 0 0 0 1 0 0 0 0 1 1 $I -90.00 98.00 $I -9  9
#' Case3 $C  3.2 $I -1  4 $M  3 0.2 0.2 0.6 $C -7.0 $S 12 0 0 1 0 0 1 1 0 0 0 1 0 $I  65.00 90.00 $I 65 70
#' Case4 $C -2.1 $I  0  2 $M  3 0.9 0.0 0.1 $C  0.0 $S 12 0 1 0 1 0 0 0 1 0 0 1 0 $I  45.00 89.00 $I 25 67
#' Case5 $C -3.0 $I -4 -2 $M  3 0.6 0.0 0.4 $C -9.5 $S 12 1 0 0 0 1 0 0 0 1 1 0 0 $I  20.00 40.00 $I  9 40
#' Case6 $C  0.1 $I 10 21 $M  3 0.0 0.7 0.3 $C -1.0 $S 12 1 0 0 0 0 0 1 0 1 0 0 0 $I   5.00  8.00 $I  5  8
#' Case7 $C  9.0 $I  4 21 $M  3 0.2 0.2 0.6 $C  0.5 $S 12 1 1 1 0 0 0 0 0 0 0 0 0 $I   3.14  6.76 $I  4  6
#'
#' @examples
#' data(example3)
#' display.sym.table(example3)
#' @keywords datasets
"example3"


#' @name example4
#' @aliases example4
#' @title Data Example 4
#' @description
#' data(example4)
#' display.sym.table(example4)
#' @usage data(example4)
#' @format
#'       $C  2.8 $I  1  2 $M 3 0.1 0.7 0.2 $C    6 $S F4 e a 2 3 g b 1 4 i k c d $I      0     90
#' Case2 $C  1.4 $I  3  9 $M 3 0.6 0.3 0.1 $C  8.0 $S 12 1 0 0 0 1 0 0 0 1 1 0 0 $I -90.00  98.00
#' Case3 $C  3.2 $I -1  4 $M 3 0.2 0.2 0.6 $C -7.0 $S 12 0 1 0 0 0 1 0 0 0 0 1 1 $I  65.00  90.00
#' Case4 $C -2.1 $I  0  2 $M 3 0.9 0.0 0.1 $C  0.0 $S 12 0 0 1 0 0 1 1 0 0 0 1 0 $I  45.00  89.00
#' Case5 $C -3.0 $I -4 -2 $M 3 0.6 0.0 0.4 $C -9.5 $S 12 0 1 0 1 0 0 0 1 0 0 1 0 $I  90.00 990.00
#' Case6 $C  0.1 $I 10 21 $M 3 0.0 0.7 0.3 $C -1.0 $S 12 1 0 0 0 1 0 0 0 1 1 0 0 $I   5.00   8.00
#' Case7 $C  9.0 $I  4 21 $M 3 0.2 0.2 0.6 $C  0.5 $S 12 1 1 0 0 0 0 1 0 0 0 0 1 $I   3.14   6.76
#'
#' @examples
#' data(example4)
#' display.sym.table(example4)
#' @keywords datasets
"example4"


#' @name example5
#' @aliases example5
#' @title Data Example 5
#' @description
#' This a symbolic data matrix wint continuos, interval, histograma a set data types.
#' @usage data(example5)
#' @format
#' $H F0 M01 M02 $C   F1 $I F2 F2 $H F3  M1  M2  M3 $S F4 E1 E2 E3 E4 \cr

#' Case1 $H  2 0.1 0.9 $C  2.8 $I  1  2 $H  3 0.1 0.7 0.2 $S  4  e  g  k  i \cr

#' Case2 $H  2 0.7 0.3 $C  1.4 $I  3  9 $H  3 0.6 0.3 0.1 $S  4  a  b  c  d \cr

#' Case3 $H  2 0.0 1.0 $C  3.2 $I -1  4 $H  3 0.2 0.2 0.6 $S  4  2  1  b  c \cr

#' Case4 $H  2 0.2 0.8 $C -2.1 $I  0  2 $H  3 0.9 0.0 0.1 $S  4  3  4  c  a \cr

#' Case5 $H  2 0.6 0.4 $C -3.0 $I -4 -2 $H  3 0.6 0.0 0.4 $S  4  e  i  g  k \cr
#'
#' @examples
#' data(example5)
#' display.sym.table(example5)
#' @keywords datasets
"example5"


#' @name example6
#' @aliases example6
#' @title Data Example 6
#' @description
#' This a symbolic data matrix wint continuos, interval, histograma a set data types.
#' @usage data(example6)
#' @format
#'
#'       $C   F1 $M F2  M1  M2  M3  M4  M5 $I F3 F3 $M F4  M1  M2  M3 $C   F5 $S F4 e a 2 3 g b 1 4 i k c d
#' Case1 $C  2.8 $M  5 0.1 0.1 0.1 0.1 0.6 $I  1  2 $M  3 0.1 0.7 0.2 $C  6.0 $S 12 1 0 0 0 1 0 0 0 1 1 0 0
#' Case2 $C  1.4 $M  5 0.1 0.1 0.1 0.1 0.6 $I  3  9 $M  3 0.6 0.3 0.1 $C  8.0 $S 12 0 1 0 0 0 1 0 0 0 0 1 1
#' Case3 $C  3.2 $M  5 0.1 0.1 0.1 0.1 0.6 $I -1  4 $M  3 0.2 0.2 0.6 $C -7.0 $S 12 0 0 1 0 0 1 1 0 0 0 1 0
#' Case4 $C -2.1 $M  5 0.1 0.1 0.1 0.1 0.6 $I  0  2 $M  3 0.9 0.0 0.1 $C  0.0 $S 12 0 1 0 1 0 0 0 1 0 0 1 0
#' Case5 $C -3.0 $M  5 0.1 0.1 0.1 0.1 0.6 $I -4 -2 $M  3 0.6 0.0 0.4 $C -9.5 $S 12 1 0 0 0 1 0 0 0 1 1 0 0
#'
#' @examples
#' data(example6)
#' display.sym.table(example6)
#' @keywords datasets
"example6"


#' @name example7
#' @aliases example7
#' @title Data Example 7
#' @description
#' This a symbolic data matrix wint continuos, interval, histograma a set data types.
#' @usage data(example6)
#' @format
#' $C   F1 $H F2  M1  M2  M3  M4  M5 $I F3 F3 $H F4  M1  M2  M3 $C   F5 \cr

#' Case1 $C  2.8 $H  5 0.1 0.2 0.3 0.4 0.0 $I  1  2 $H  3 0.1 0.7 0.2 $C  6.0 \cr

#' Case2 $C  1.4 $H  5 0.2 0.1 0.5 0.1 0.2 $I  3  9 $H  3 0.6 0.3 0.1 $C  8.0 \cr

#' Case3 $C  3.2 $H  5 0.1 0.1 0.2 0.1 0.5 $I -1  4 $H  3 0.2 0.2 0.6 $C -7.0 \cr

#' Case4 $C -2.1 $H  5 0.4 0.1 0.1 0.1 0.3 $I  0  2 $H  3 0.9 0.0 0.1 $C  0.0 \cr

#' Case5 $C -3.0 $H  5 0.6 0.1 0.1 0.1 0.1 $I -4 -2 $H  3 0.6 0.0 0.4 $C -9.5 \cr
#'
#' @examples
#' data(example7)
#' display.sym.table(example7)
#' @keywords datasets
"example7"


#' @name facedata
#' @aliases facedata
#' @title Face Data Example
#' @description
#' Symbolic data matrix with all the variables of interval type.
#' @usage data('facedata')
#' @format
#' $I;AD;AD;$I;BC;BC;......... \cr
#'
#' HUS1;$I;168.86;172.84;$I;58.55;63.39;.........\cr
#' HUS2;$I;169.85;175.03;$I;60.21;64.38;.........\cr
#' HUS3;$I;168.76;175.15;$I;61.4;63.51;.........\cr
#' INC1;$I;155.26;160.45;$I;53.15;60.21;.........\cr
#' INC2;$I;156.26;161.31;$I;51.09;60.07;.........\cr
#' INC3;$I;154.47;160.31;$I;55.08;59.03;.........\cr
#' ISA1;$I;164;168;$I;55.01;60.03;.........\cr
#' ISA2;$I;163;170;$I;54.04;59;.........\cr
#' ISA3;$I;164.01;169.01;$I;55;59.01;.........\cr
#' JPL1;$I;167.11;171.19;$I;61.03;65.01;.........\cr
#' JPL2;$I;169.14;173.18;$I;60.07;65.07;.........\cr
#' JPL3;$I;169.03;170.11;$I;59.01;65.01;.........\cr
#' KHA1;$I;149.34;155.54;$I;54.15;59.14;.........\cr
#' KHA2;$I;149.34;155.32;$I;52.04;58.22;.........\cr
#' KHA3;$I;150.33;157.26;$I;52.09;60.21;.........\cr
#' LOT1;$I;152.64;157.62;$I;51.35;56.22;.........\cr
#' LOT2;$I;154.64;157.62;$I;52.24;56.32;.........\cr
#' LOT3;$I;154.83;157.81;$I;50.36;55.23;.........\cr
#' PHI1;$I;163.08;167.07;$I;66.03;68.07;.........\cr
#' PHI2;$I;164;168.03;$I;65.03;68.12;.........\cr
#' PHI3;$I;161.01;167;$I;64.07;69.01;.........\cr
#' ROM1;$I;167.15;171.24;$I;64.07;68.07;.........\cr
#' ROM2;$I;168.15;172.14;$I;63.13;68.07;.........\cr
#' ROM3;$I;167.11;171.19;$I;63.13;68.03;.........\cr
#' @references
#' Billard L. and  Diday E. (2006).
#' Symbolic data analysis: Conceptual statistics and data mining. Wiley, Chichester.
#' @examples
#' \dontrun{
#' data(facedata)
#' res.vertex.ps<-sym.interval.pc(facedata,'vertex',150,FALSE,FALSE,TRUE)
#' class(res.vertex.ps$sym.prin.curve) <- c('sym.data.table')
#' sym.scatterplot(res.vertex.ps$sym.prin.curve[,1], res.vertex.ps$sym.prin.curve[,2],
#'                 labels=TRUE,col='red',main='PSC Face Data')
#'                 }
#' @keywords datasets
"facedata"


#' @name int_prost_test
#' @aliases int_prost_test
#' @title Linear regression model data example.
#' @description
#' Linear regression model interval-valued data example.
#' @usage data(int_prost_test)
#' @references
#' HASTIE, T., TIBSHIRANI, R. and FRIEDMAN, J. (2008). The Elements of Statistical Learning:
#' Data Mining, Inference and Prediction. New York: Springer.
#' @examples
#' data(int_prost_train)
#' data(int_prost_test)
#' res.cm<-sym.lm(lpsa~.,sym.data=int_prost_test,method='cm')
#' res.cm<-sym.lm(lpsa~.,sym.data=int_prost_train,method='cm')
#' pred.cm<-predictsym.lm(res.cm,int_prost_test,method='cm')
#' RMSE.L(sym.var(int_prost_test,9),pred.cm$Fitted)
#' RMSE.U(sym.var(int_prost_test,9),pred.cm$Fitted)
#' R2.L(sym.var(int_prost_test,9),pred.cm$Fitted)
#' R2.U(sym.var(int_prost_test,9),pred.cm$Fitted)
#' deter.coefficient(sym.var(int_prost_test,9),pred.cm$Fitted)
#'
#' res.cm.lasso<-sym.glm(sym.data=int_prost_train,response=9,method='cm',
#'                       alpha=1,nfolds=10,grouped=TRUE)
#' plot(res.cm.lasso)
#' plot(res.cm.lasso$glmnet.fit, 'norm', label=TRUE)
#' plot(res.cm.lasso$glmnet.fit, 'lambda', label=TRUE)
#' pred.cm.lasso<-predictsym.glm(res.cm.lasso,response=9,int_prost_test,method='cm')
#' RMSE.L(sym.var(int_prost_test,9),pred.cm.lasso)
#' RMSE.U(sym.var(int_prost_test,9),pred.cm.lasso)
#' R2.L(sym.var(int_prost_test,9),pred.cm.lasso)
#' R2.U(sym.var(int_prost_test,9),pred.cm.lasso)
#' deter.coefficient(sym.var(int_prost_test,9),pred.cm.lasso)
#' @keywords datasets
"int_prost_test"


#' @name int_prost_train
#' @aliases int_prost_train
#' @title Linear regression model data example.
#' @description
#' Linear regression model interval-valued data example.
#' @usage data(int_prost_train)
#' @references
#' HASTIE, T., TIBSHIRANI, R. and FRIEDMAN, J. (2008). The Elements of Statistical Learning:
#' Data Mining, Inference and Prediction. New York: Springer.
#' @examples
#' data(int_prost_train)
#' data(int_prost_test)
#' res.cm<-sym.lm(lpsa~.,sym.data=int_prost_test,method='cm')
#' res.cm<-sym.lm(lpsa~.,sym.data=int_prost_train,method='cm')
#' pred.cm<-predictsym.lm(res.cm,int_prost_test,method='cm')
#' RMSE.L(sym.var(int_prost_test,9),pred.cm$Fitted)
#' RMSE.U(sym.var(int_prost_test,9),pred.cm$Fitted)
#' R2.L(sym.var(int_prost_test,9),pred.cm$Fitted)
#' R2.U(sym.var(int_prost_test,9),pred.cm$Fitted)
#' deter.coefficient(sym.var(int_prost_test,9),pred.cm$Fitted)
#'
#' res.cm.lasso<-sym.glm(sym.data=int_prost_train,response=9,method='cm',
#'                       alpha=1,nfolds=10,grouped=TRUE)
#' plot(res.cm.lasso)
#' plot(res.cm.lasso$glmnet.fit, 'norm', label=TRUE)
#' plot(res.cm.lasso$glmnet.fit, 'lambda', label=TRUE)
#' pred.cm.lasso<-predictsym.glm(res.cm.lasso,response=9,int_prost_test,method='cm')
#' RMSE.L(sym.var(int_prost_test,9),pred.cm.lasso)
#' RMSE.U(sym.var(int_prost_test,9),pred.cm.lasso)
#' R2.L(sym.var(int_prost_test,9),pred.cm.lasso)
#' R2.U(sym.var(int_prost_test,9),pred.cm.lasso)
#' deter.coefficient(sym.var(int_prost_test,9),pred.cm.lasso)
#' @keywords datasets
"int_prost_train"


#' @name lynne1
#' @aliases lynne1
#' @title Symbolic interval data example.
#' @description
#' Symbolic data matrix with all the variables of interval type.
#' @usage data(lynne1)
#'
#' @references
#' Billard L. and  Diday E. (2006).
#' Symbolic data analysis: Conceptual statistics and data mining. Wiley, Chichester.
#' @examples
#' data(lynne1)
#' display.sym.table(lynne1)
#' @keywords datasets
"lynne1"


#' @name lynne2
#' @aliases lynne2
#' @title Symbolic interval data example.
#' @description
#' Symbolic data matrix with all the variables of interval type.
#' @usage data(lynne2)
#'
#' @references
#' Billard L. and  Diday E. (2006).
#' Symbolic data analysis: Conceptual statistics and data mining. Wiley, Chichester.
#' @examples
#' data(lynne2)
#' display.sym.table(lynne2)
#' @keywords datasets
"lynne2"


#' @name oils
#' @aliases olils
#' @title Ichino Oils example data.
#' @description
#' Symbolic data matrix with all the variables of interval type.
#' @usage data(oils)
#' @format
#' $I   GRA   GRA $I FRE FRE $I IOD IOD $I SAP SAP \cr

#' L  $I 0.930 0.935 $I -27 -18 $I 170 204 $I 118 196 \cr

#' P  $I 0.930 0.937 $I  -5  -4 $I 192 208 $I 188 197 \cr

#' Co $I 0.916 0.918 $I  -6  -1 $I  99 113 $I 189 198 \cr

#' S  $I 0.920 0.926 $I  -6  -4 $I 104 116 $I 187 193 \cr

#' Ca $I 0.916 0.917 $I -25 -15 $I  80  82 $I 189 193 \cr

#' O  $I 0.914 0.919 $I   0   6 $I  79  90 $I 187 196 \cr

#' B  $I 0.860 0.870 $I  30  38 $I  40  48 $I 190 199 \cr

#' H  $I 0.858 0.864 $I  22  32 $I  53  77 $I 190 202 \cr
#'
#' @references
#' Cazes P., Chouakria A., Diday E. et Schektman Y. (1997).  Extension de l'analyse en
#' composantes principales a des donnees de type intervalle, Rev. Statistique Appliquee,
#' Vol. XLV Num. 3 pag. 5-24, France.
#' @examples
#' data(oils)
#' display.sym.table(oils)
#' @keywords datasets
"oils"


#' @name StudentsGrades
#' @aliases StudentsGrades
#' @title Data Example.
#' @description
#' Symbolic data matrix with all the variables continuos type.
#' @usage data(StudentsGrades)
#' @format
#'         $C Math  $C Science  $C Spanish  $C History  $C Sport\cr
#' Lucia   $C  7.0   $C     6.5  $C     9.2  $C     8.6  $C   8.0\cr
#' Pedro   $C  7.5  $C     9.4  $C     7.3  $C     7.0  $C   7.0\cr
#' Ines    $C  7.6  $C     9.2  $C     8.0  $C     8.0  $C   7.5\cr
#' Luis    $C  5.0  $C     6.5  $C     6.5  $C     7.0  $C   9.0\cr
#' Andres  $C  6.0  $C     6.0  $C     7.8  $C     8.9  $C   7.3\cr
#' Ana     $C  7.8  $C     9.6  $C     7.7  $C     8.0  $C   6.5\cr
#' Carlos  $C  6.3  $C     6.4  $C     8.2  $C     9.0  $C   7.2\cr
#' Jose    $C  7.9  $C     9.7  $C     7.5  $C     8.0  $C   6.0\cr
#' Sonia   $C  6.0  $C     6.0  $C     6.5  $C     5.5  $C   8.7\cr
#' Maria   $C  6.8  $C     7.2  $C     8.7  $C     9.0  $C   7.0\cr
#' @examples
#' data(StudentsGrades)
#' StudentsGrades
#' @keywords datasets
"StudentsGrades"


#' @name uscrime_int
#' @aliases uscrime_int
#' @title Us crime interval data table.
#' @description
#' Us crime classic data table genetated from uscrime data.
#' @usage data(uscrime_int)
#' @references
#' Rodriguez O. (2013). A generalization of Centre and Range method for fitting a linear
#' regression model to symbolic interval data using Ridge Regression, Lasso
#' and Elastic Net methods. The IFCS2013 conference of the International Federation of
#' Classification Societies, Tilburg University Holland.
#' @examples
#' data(uscrime_int)
#' car.data<-uscrime_int
#' res.cm.lasso<-sym.glm(sym.data=car.data,response=102,method='cm',alpha=1,
#'                       nfolds=10,grouped=TRUE)
#' plot(res.cm.lasso)
#' plot(res.cm.lasso$glmnet.fit, 'norm', label=TRUE)
#' plot(res.cm.lasso$glmnet.fit, 'lambda', label=TRUE)
#'
#' pred.cm.lasso<-predictsym.glm(res.cm.lasso,response=102,car.data,method='cm')
#' RMSE.L(sym.var(car.data,102),pred.cm.lasso)
#' RMSE.U(sym.var(car.data,102),pred.cm.lasso)
#' R2.L(sym.var(car.data,102),pred.cm.lasso)
#' R2.U(sym.var(car.data,102),pred.cm.lasso)
#' deter.coefficient(sym.var(car.data,102),pred.cm.lasso)
#' @keywords datasets
"uscrime_int"


#' @name USCrime
#' @aliases USCrime
#' @title Us crime classic data table
#' @description
#' Us crime classic data table that can be used to generate symbolic data tables.
#' @usage data(USCrime)
#' @source http://archive.ics.uci.edu/ml/
#' @references
#' HASTIE, T., TIBSHIRANI, R. and FRIEDMAN, J. (2008). The Elements of Statistical Learning:
#' Data Mining, Inference and Prediction. New York: Springer.
#' @examples
#' data(USCrime)
#' us.crime<-USCrime
#' dim(us.crime)
#' head(us.crime)
#' summary(us.crime)
#' names(us.crime)
#' nrow(us.crime)
#' result  <- classic.to.sym(us.crime, concept='state',
#'                           variables =c(NumInShelters, NumImmig),
#'                           variables.types =c(NumInShelters = type.histogram(),
#'                            NumImmig = type.histogram()))
#' result
#' @keywords datasets
"USCrime"


#' @name VeterinaryData
#' @aliases VeterinaryData
#' @title Symbolic interval data example
#' @description
#' Symbolic data matrix with all the variables of interval type.
#' @usage data(VeterinaryData)
#' @format
#' $I Height Height $I Weight Weight \cr
#'
#' 1  $I  120.0  180.0 $I  222.2  354.0\cr
#'
#' 2  $I  158.0  160.0 $I  322.0  355.0\cr
#'
#' 3  $I  175.0  185.0 $I  117.2  152.0\cr
#'
#' 4  $I   37.9   62.9 $I   22.2   35.0\cr
#'
#' 5  $I   25.8   39.6 $I   15.0   36.2\cr
#'
#' 6  $I   22.8   58.6 $I   15.0   51.8\cr
#'
#' 7  $I   22.0   45.0 $I    0.8   11.0\cr
#'
#' 8  $I   18.0   53.0 $I    0.4    2.5\cr
#'
#' 9  $I   40.3   55.8 $I    2.1    4.5\cr
#'
#' 10 $I   38.4   72.4 $I    2.5    6.1\cr
#'
#'
#'
#' @references
#' Billard L. and  Diday E. (2006).
#' Symbolic data analysis: Conceptual statistics and data mining. Wiley, Chichester.
#' @examples
#' data(VeterinaryData)
#' display.sym.table(VeterinaryData)
#' @keywords datasets
"VeterinaryData"



#' @title sodasXML
#' @description sodasXML
#' @keywords internal
"sodasXML"
#line 1 "/private/var/folders/x1/bc7ln59d11jddyfmvq0f4mwm0000gn/T/RtmpK8STdo/R.INSTALL582a7c381cc/RSDA/R/data.frame.to.RSDA.interval.table.r"
data.frame.to.RSDA.inteval.table <- function(data.df) {
  sym.obj.names <- row.names(data.df)
  col.names.sym <- colnames(data.df)
  dim.sym <- dim(data.df)
  var.dist <- dim.sym[2] / 2
  sym.var.types <- rep("$I", var.dist)
  sym.var.names <- col.names.sym[seq(from = 1, by = 2, length.out = var.dist)]
  sym.var.length <- rep(2, var.dist)
  sym.var.starts <- seq(from = 2, by = 3, length.out = var.dist)
  meta <- as.data.frame(matrix("$I", nrow = dim.sym[1], ncol = dim.sym[2] * 1.5))

  colnames.sym <- rep("$I", dim.sym[2] * 1.5)

  indx <- 1:var.dist

  for (j in indx) {
    pos.ini <- 2 + 3 * (j - 1)
    pos.fin <- pos.ini + 1
    pos.ini.data <- 1 + 2 * (j - 1)
    pos.fin.data <- pos.ini.data + 1
    pos <- pos.ini:pos.fin
    pos.data <- pos.ini.data:pos.fin.data
    colnames.sym[pos] <- sym.var.names[j]
    meta[, pos] <- data.df[, pos.data]
  }

  colnames(meta) <- colnames.sym
  row.names(meta) <- sym.obj.names

  data.sym <- list(
    N = dim.sym[1],
    M = var.dist,
    sym.obj.names = sym.obj.names,
    sym.var.names = sym.var.names,
    sym.var.types = sym.var.types,
    sym.var.length = sym.var.length,
    sym.var.starts = sym.var.starts,
    meta = meta,
    data = data.df
  )

  class(data.sym) <- "sym.data.table"
  return(data.sym)
}
#line 1 "/private/var/folders/x1/bc7ln59d11jddyfmvq0f4mwm0000gn/T/RtmpK8STdo/R.INSTALL582a7c381cc/RSDA/R/data.frame.to.RSDA.inteval.table.j.r"
#' data.frame.to.RSDA.inteval.table.j
#' @keywords internal
data.frame.to.RSDA.inteval.table.j <- function(data.df) {
  sym.obj.names <- row.names(data.df)
  col.names.sym <- colnames(data.df)
  dim.sym <- dim(data.df)
  var.dist <- dim.sym[2] / 2
  sym.var.types <- rep("$I", var.dist)
  sym.var.names <- col.names.sym[seq(from = 1, by = 2, length.out = var.dist)]
  sym.var.length <- rep(2, var.dist)
  sym.var.starts <- seq(from = 2, by = 3, length.out = var.dist)
  meta <- as.data.frame(matrix("$I", nrow = dim.sym[1], ncol = dim.sym[2] * 1.5))

  colnames.sym <- rep("$I", dim.sym[2] * 1.5)

  indx <- 1:var.dist

  for (j in indx) {
    pos.ini <- 2 + 3 * (j - 1)
    pos.fin <- pos.ini + 1
    pos.ini.data <- 1 + 2 * (j - 1)
    pos.fin.data <- pos.ini.data + 1
    pos <- pos.ini:pos.fin
    pos.data <- pos.ini.data:pos.fin.data
    colnames.sym[pos] <- sym.var.names[j]
    meta[, pos] <- data.df[, pos.data]
  }

  colnames(meta) <- colnames.sym
  row.names(meta) <- sym.obj.names

  data.sym <- list(
    N = dim.sym[1], M = var.dist, sym.obj.names = sym.obj.names, sym.var.names = sym.var.names,
    sym.var.types = sym.var.types, sym.var.length = sym.var.length, sym.var.starts = sym.var.starts,
    meta = meta, data = data.df
  )

  return(data.sym)
}
#line 1 "/private/var/folders/x1/bc7ln59d11jddyfmvq0f4mwm0000gn/T/RtmpK8STdo/R.INSTALL582a7c381cc/RSDA/R/data.frame.to.sym.inteval.j.r"
#' data.fame.to.sym.inteval
#' @keywords internal
data.fame.to.sym.inteval <- function(data.df) {
  sym.obj.names <- row.names(data.df)
  col.names.sym <- colnames(data.df)
  dim.sym <- dim(data.df)
  var.dist <- dim.sym[2] / 2
  sym.var.types <- rep("$I", var.dist)
  sym.var.names <- col.names.sym[seq(from = 1, by = 2, length.out = var.dist)]
  sym.var.length <- rep(2, var.dist)
  sym.var.starts <- seq(from = 2, by = 3, length.out = var.dist)
  meta <- as.data.frame(matrix("$I", nrow = dim.sym[1], ncol = dim.sym[2] * 1.5))

  colnames.sym <- rep("$I", dim.sym[2] * 1.5)

  indx <- 1:var.dist

  for (j in indx) {
    pos.ini <- 2 + 3 * (j - 1)
    pos.fin <- pos.ini + 1
    pos.ini.data <- 1 + 2 * (j - 1)
    pos.fin.data <- pos.ini.data + 1
    pos <- pos.ini:pos.fin
    pos.data <- pos.ini.data:pos.fin.data
    colnames.sym[pos] <- sym.var.names[j]
    meta[, pos] <- data.df[, pos.data]
  }

  colnames(meta) <- colnames.sym
  row.names(meta) <- sym.obj.names

  data.sym <- list(
    N = dim.sym[1], M = var.dist, sym.obj.names = sym.obj.names, sym.var.names = sym.var.names,
    sym.var.types = sym.var.types, sym.var.length = sym.var.length, sym.var.starts = sym.var.starts,
    meta = meta, data = data.df
  )

  return(data.sym)
}
#line 1 "/private/var/folders/x1/bc7ln59d11jddyfmvq0f4mwm0000gn/T/RtmpK8STdo/R.INSTALL582a7c381cc/RSDA/R/desv.fun.j.r"
desv.fun <- function(x) {
  N <- length(x)
  return(sd(x) * sqrt((N - 1) / N))
}
#line 1 "/private/var/folders/x1/bc7ln59d11jddyfmvq0f4mwm0000gn/T/RtmpK8STdo/R.INSTALL582a7c381cc/RSDA/R/deter.coefficient.R"
#' Compute the determination cosfficient
#' @aliases deter.coefficient
#' @name deter.coefficient
#' @author Oldemar Rodriguez Rojas
#' @description The determination coefficient represents a
#' goodness-of-fit measure commonly used in regression analysis to
#' capture the adjustment quality of a model.
#' @usage deter.coefficient(sym.var, prediction)
#' @param sym.var Variable that was predicted.
#' @param prediction The prediction given by the model.
#'
#' @return Return the determination cosfficient.
#' @references LIMA-NETO, E.A., DE CARVALHO, F.A.T., (2008). Centre and range method
#' to fitting a linear regression model on symbolic interval data. Computational
#' Statistics and Data Analysis 52, 1500-1515.
#'
#' LIMA-NETO, E.A., DE CARVALHO, F.A.T., (2010). Constrained linear regression models
#' for symbolic interval-valued variables. Computational Statistics and
#' Data Analysis 54, 333-347.
#' @seealso sym.glm
#' @examples
#' data(int_prost_test)
#' data(int_prost_train)
#' res.cm <- sym.lm(lpsa~., sym.data=int_prost_train, method='cm')
#' pred.cm <- predictsym.lm(res.cm,int_prost_test,method='cm')
#' deter.coefficient(sym.var(int_prost_test,9),pred.cm$Fitted)
#'
#' res.cm.lasso <- sym.glm(sym.data=int_prost_train,response=9,method='cm',
#'                       alpha=1,nfolds=10,grouped=TRUE)
#' pred.cm.lasso <- predictsym.glm(res.cm.lasso,response=9,int_prost_test,method='cm')
#' deter.coefficient(sym.var(int_prost_test,9),pred.cm.lasso)
#' @keywords Symbolic Lasso Ridge Elastic Net
#' @export
#'
deter.coefficient <- function(sym.var, prediction) {
  pvar <- sym.var
  nn <- pvar$N
  centers.pvar <- rep(0, nn)
  pred <- prediction
  centers.pred <- rep(0, nn)
  centers.pvar <- (pvar$var.data.vector[, 1] + pvar$var.data.vector[, 2]) / 2
  centers.pred <- (pred[, 1] + pred[, 2]) / 2
  coef <- sum((centers.pred - mean(centers.pvar))^2) / sum((centers.pvar - mean(centers.pvar))^2)
  return(coef)
}
#line 1 "/private/var/folders/x1/bc7ln59d11jddyfmvq0f4mwm0000gn/T/RtmpK8STdo/R.INSTALL582a7c381cc/RSDA/R/display.sym.table.R"
#' display.sym.table
#' @name display.sym.table
#' @aliases display.sym.table
#' @author Oldemar Rodriguez Rojas
#' @description This function display a symbolic data table tha have been read by read.sym.table(...)
#' @usage display.sym.table(sym.data)
#' @param sym.data Shoud be a Symbolic Data table that have been read with read.sym.table(...)
#' @details The output will be the symbolic data table in the screen.
#'
#' @return Not value.
#' @references Billard, L and  Diday, E. (2007). Symbolic Data Analysis: Conceptual Statistics and Data
#' Mining (Wiley Series in Computational Statistics).
#' Billard, L and  Diday, E. (2003). From the Statistics of Data to the Statistics of
#' Knowledge: Symbolic Data Analysis. Journal of the American of the Statistical Association, USA.
#' @examples
#' data(example3)
#' display.sym.table(example3)
#' @seealso read.sym.table
#' @keywords Display Symbolic Table
#' @export
#'
display.sym.table <- function(sym.data) {
  return(sym.data$meta)
}
#line 1 "/private/var/folders/x1/bc7ln59d11jddyfmvq0f4mwm0000gn/T/RtmpK8STdo/R.INSTALL582a7c381cc/RSDA/R/dist.R"
#' Generic function for distance matrix computation
#' @name dist
#' @aliases dist
#' @author Oldemar Rodriguez Rojas
#' @param x An R object. Currently the are methods for numeric matrix, data.frame, dist object or symbolic data table
#'
#' @return dist returns an object of class 'dist'
#' @export
dist <- function(x, ...) {
  UseMethod("dist", x)
}

#' @param method the distance measure to be used. This must be one of "euclidean", "maximum", "manhattan", "canberra", "binary" or "minkowski". Any unambiguous substring can be given.
#' @param diag logical value indicating whether the diagonal of the distance matrix should be printed by print.dist.
#' @param upper logical value indicating whether the upper triangle of the distance matrix should be printed by print.dist.
#' @param p The power of the Minkowski distance.
#'
#' @rdname dist
#' @export
dist.default <- function(x, method = "euclidean", diag = FALSE, upper = FALSE, p = 2, ...) {
  stats::dist(x, method = method, diag = diag, upper = upper, p = p)
}


#' @param q q value for the Minkowski method
#' @param ... Further arguments passed to or from other methods
#'
#' @rdname dist
#' @export
dist.sym.data.table <- function(x, q = 2, ...) {
  if (length(unique(x$sym.var.types))) {
    if (x$sym.var.types[1] == "%I") {
      return(sym.dist.interval(x))
    } else if (x$sym.var.types[1] == "%S") {
      return(sym.dist.set(x))
    }
  }

  n <- x$N
  m <- x$M
  out <- matrix(0, nrow = n, ncol = n)
  colnames(out) <- x$sym.obj.names
  rownames(out) <- x$sym.obj.names
  dist.functions <- select.dist(x)
  for (i in seq_len(m)) {
    for (j in seq_len(n)) {
      for (k in seq_len(n)) {
        out[j, k] <- out[j, k] + dist.functions[[i]](x[j, i], x[k, i])
      }
    }
  }
  out <- out^(1 / q)
  out <- dist(out)
  return(out)
}

#' Select distance methods for a symbolic data table
#'
#' @param x A symbilic data table
#'
#' @keywords internal
select.dist <- function(x) {
  types <- x$sym.var.types
  dist.functions <- list()
  for (i in seq_along(types)) {
    switch(types[i],
      "$C" = {
        dist.functions[[i]] <- cont.distance
      },
      "$I" = {
        dist.functions[[i]] <- interval.distance
      },
      "$M" = {
        dist.functions[[i]] <- modal.distance
      },
      "$S" = {
        dist.functions[[i]] <- set.distance
      },
      "$H" = {
        dist.functions[[i]] <- hist.distance
      }
    )
  }
  return(dist.functions)
}

#' Distance between modal multivalued variables
#'
#' @param x A symbilic data table 1x1
#' @param y A symbilic data table 1x1
#'
#' @keywords internal
modal.distance <- function(x, y, q = 2) {
  1 - (sum(sqrt(x$data * y$data))^q)
}


#' Distance between set variables
#'
#' @param x A symbilic data table 1x1
#' @param y A symbilic data table 1x1
#' @param method Method to use
#' @param normalize A logical value indicating whether normalize the output
#'
#' @keywords internal
set.distance <- function(x, y, q = 2) {
  var <- rbind(x$data, y$data)
  sum.var <- colSums(var)
  union <- sum(sum.var > 0)
  intersect <- length(which(sum.var == 2))

  distance <- union - intersect + 0.5 * (2 * intersect - sum(x$data) - sum(y$data))
  distance <- distance / ncol(x$data)
  distances <- distance^q
  return(distance)
}

#' Distance between interval variables
#'
#' @param x A symbilic data table 1x1
#' @param y A symbilic data table 1x1
#'
#' @keywords internal
interval.distance <- function(x, y, q = 2) {
  max(c(abs(x$data[, 1] - y$data[, 1]), abs(x$data[, 2] - y$data[, 2])))^q
}


#' Distance between histogram variables
#'
#' @param x A symbilic data table 1x1
#' @param y A symbilic data table 1x1
#'
#' @keywords internal
hist.distance <- function(x, y, q = 2) {
  1 - (sum(sqrt(x$data * y$data))^q)
}

#' Distance between continuous variables
#'
#' @param x A symbilic data table 1x1
#' @param y A symbilic data table 1x1
#'
#' @keywords internal
cont.distance <- function(x, y, q = 2) {
  (x$data - y$data)^q
}
#line 1 "/private/var/folders/x1/bc7ln59d11jddyfmvq0f4mwm0000gn/T/RtmpK8STdo/R.INSTALL582a7c381cc/RSDA/R/dist.interval.R"
#' Compute the distance between two rows
#' @keywords internal
sym.Interval.distance <- function(sym.data, variable, w1, w2, gamma = 0.5, method = "Minkowski",
                                  normalize = TRUE) {
  if (method == "Gowda.Diday" | method == "Ichino" | method == "Minkowski" | method ==
    "Hausdorff") {
    result <- sym.data
    if (result$sym.var.types[variable] == "$I") {
      lenght <- result$sym.var.length[variable]
      ini <- result$sym.var.starts[variable]
      var <- result$meta[, ini:(ini + lenght - 1)]
      Intersect <- abs(max(var[w1, 1], var[w2, 1]) - min(var[w1, 2], var[
        w2,
        2
      ]))
      Union <- abs(min(var[w1, 1], var[w2, 1]) - max(var[w1, 2], var[w2, 2]))
      k <- abs(max(var[w1, 2], var[w2, 2]) - min(var[w1, 1], var[w2, 1]))
      total.lenght <- max(var[, 2]) - min(var[, 1])
      if (method == "Gowda.Diday") {
        D1 <- abs(abs((var[w1, 2] - var[w1, 1])) - abs((var[w2, 2] - var[
          w2,
          1
        ]))) / k
        if (var[w1, 1] > var[w2, 2] | var[w1, 2] < var[w2, 1]) {
          D2 <- (abs(var[w1, 2] - var[w1, 1]) + abs(var[w2, 2] - var[w2, 1])) / k
        } else {
          D2 <- (abs(var[w1, 2] - var[w1, 1]) + abs(var[w2, 2] - var[w2, 1]) -
            (2 * Intersect)) / k
        }
        D3 <- abs(var[w1, 1] - var[w2, 1]) / total.lenght
        Distance <- D1 + D2 + D3
      }
      if (method == "Ichino" | method == "Minkowski") {
        if (gamma > 0.5) {
          gamma <- 0.5
        }
        if (gamma < 0) {
          gamma <- 0
        }
        if (var[w1, 1] > var[w2, 2] | var[w1, 2] < var[w2, 1]) {
          Distance <- Union + gamma * (-abs(var[w1, 2] - var[w1, 1]) - abs(var[
            w2,
            2
          ] - var[w2, 1]))
        } else {
          Distance <- Union - Intersect + gamma * (2 * Intersect - abs(var[
            w1,
            2
          ] - var[w1, 1]) - abs(var[w2, 2] - var[w2, 1]))
        }
      }
      if (method == "Hausdorff") {
        Distance <- max(abs(var[w1, 1] - var[w2, 1]), abs(var[w1, 2] - var[
          w2,
          2
        ]))
      }
      if (normalize == TRUE) {
        Distance <- Distance / total.lenght
      }
    } else {
      Distance <- NA
    }
    return(Distance)
  }
  return("Invalid method")
}


#' Distance for Symbolic Interval Variables.
#' @name sym.dist.interval
#' @description This function computes and returns the distance matrix by using the specified
#' distance measure to compute distance between symbolic interval variables.
#'
#' @param sym.data A symbolic object
#' @param variables Numeric vector with the number of the variables to use.
#' @param gamma gamma value for the methods ichino and minkowski.
#' @param method Method to use (Gowda.Diday, Ichino, Minkowski, Hausdorff)
#' @param normalize A logical value indicating whether normalize the data in the ichino or hausdorff method.
#' @param SpanNormalize A logical value indicating whether
#' @param q q value for the hausdorff method.
#' @param euclidea A logical value indicating whether use the euclidean distance.
#' @param pond A numeric vector
#'
#' @return An object of class 'dist'
#' @export
#'
#' @examples
#'
#' data('table7')
#' ex3 <- classic.to.sym(table7, concept=c('Animal'),variables = c(Height, Weight)
#' ,variables.types=c(Height = type.interval(), Weight = type.interval()))
#' sym.dist.interval(ex3,method='Gowda.Diday',normalize=FALSE)
#' sym.dist.interval(ex3,gamma=0.5,method='Ichino',normalize=FALSE)
#' sym.dist.interval(ex3,gamma=0.5,method='Minkowski',normalize=FALSE,q=1)
#' sym.dist.interval(ex3,gamma=0.5,method='Minkowski',normalize=FALSE,q=2)
#' sym.dist.interval(ex3,gamma=0.5,method='Hausdorff',normalize=FALSE,
#' SpanNormalize=FALSE,euclidea=TRUE)
#' sym.dist.interval(ex3,gamma=0.5,method='Hausdorff',normalize=FALSE,
#' SpanNormalize=TRUE,euclidea=TRUE)
sym.dist.interval <- function(sym.data, gamma = 0.5, method = "Minkowski", normalize = TRUE,
                              SpanNormalize = FALSE, q = 1, euclidea = TRUE, pond = rep(1, length(variables))) {
  variables <- (1:(sym.data$M))
  if (sum(pond) != length(variables) & sum(pond) > 1) {
    pond <- rep(1 / length(variables), length(variables))
  }

  for (med in 1:length(method)) {
    if (method[med] == "Gowda.Diday" | method[med] == "Ichino" | method[med] ==
      "Minkowski" | method[med] == "Hausdorff") {
      result <- sym.data
      h <- 1
      Dissimilarity.matrix <- matrix(c(0), ncol = nrow(result$data), nrow = nrow(result$data))

      if (method[med] == "Minkowski") {
        for (var in variables) {
          Matrix <- matrix(c(0), ncol = nrow(result$data), nrow = nrow(result$data))
          Matrix_pond <- matrix(c(0), ncol = nrow(result$data), nrow = nrow(result$data))
          for (j in 1:nrow(result$data)) {
            for (i in j:nrow(result$data)) {
              Matrix[i, j] <- sym.Interval.distance(
                sym.data, var, i, j, gamma,
                method[med], normalize
              )
            }
          }
          if (q == 1) {
            Matrix_pond <- Matrix_pond + (Matrix * pond[h])
          } else {
            Matrix_pond <- Matrix_pond + (Matrix)^q
          }
          Dissimilarity.matrix <- Dissimilarity.matrix + Matrix_pond
          h <- h + 1
        }
        Dissimilarity.matrix <- as.dist(Dissimilarity.matrix^(1 / q))
      }

      if (method[med] == "Gowda.Diday" | method[med] == "Ichino") {
        for (var in variables) {
          Matrix <- matrix(c(0), ncol = nrow(result$data), nrow = nrow(result$data))
          Matrix_pond <- matrix(c(0), ncol = nrow(result$data), nrow = nrow(result$data))
          for (j in 1:nrow(result$data)) {
            for (i in j:nrow(result$data)) {
              Matrix[i, j] <- sym.Interval.distance(
                sym.data, var, i, j, gamma,
                method[med], normalize
              )
            }
          }
          Matrix_pond <- Matrix_pond + (Matrix * pond[h])
          Dissimilarity.matrix <- Dissimilarity.matrix + Matrix_pond
          h <- h + 1
        }
        Dissimilarity.matrix <- as.dist(Dissimilarity.matrix)
      }

      if (method[med] == "Hausdorff") {
        if (normalize == TRUE) {
          SpanNormalize <- FALSE
        }
        Dissimilarity.matrix <- matrix(c(0), ncol = nrow(result$data), nrow = nrow(result$data))
        for (var in variables) {
          Matrix <- matrix(c(0), ncol = nrow(result$data), nrow = nrow(result$data))
          for (j in 1:nrow(result$data)) {
            for (i in j:nrow(result$data)) {
              Matrix[i, j] <- sym.Interval.distance(
                sym.data, var, i, j, gamma,
                method[med], normalize
              )
            }
          }
          H <- ((1 / (2 * nrow(result$data)^2)) * sum(Matrix^2))^(1 / 2)
          if (SpanNormalize == TRUE) {
            Matrix <- Matrix / H
          }
          if (euclidea == TRUE) {
            Dissimilarity.matrix <- Dissimilarity.matrix + Matrix^2
          } else {
            Dissimilarity.matrix <- Dissimilarity.matrix + Matrix
          }
        }
        if (euclidea == TRUE) {
          Dissimilarity.matrix <- as.dist(Dissimilarity.matrix)^(1 / 2)
        } else {
          Dissimilarity.matrix <- as.dist(Dissimilarity.matrix)
        }
      }
    } else {
      return("Invalid method")
    }

    if (med == 1) {
      res <- list(Dissimilarity.matrix)
      names <- matrix(c(method[med]))
    } else {
      names <- rbind(names, method[med])
      res[[length(res) + 1]] <- Dissimilarity.matrix
    }
    names(res) <- names
  }
  return(res)
}
#line 1 "/private/var/folders/x1/bc7ln59d11jddyfmvq0f4mwm0000gn/T/RtmpK8STdo/R.INSTALL582a7c381cc/RSDA/R/dist.modal.R"
#' dist.modal
#' @keywords internal
dist.mod <- function(x, y) {
  sum(sqrt(x * y))
}


#' Distance matrix for symbolic data
#'
#' @param sym.data Symbolic data table
#'
#' @return return an object of class 'dist
#' @export
dist.modal <- function(sym.data) {
  n <- sym.data$N
  m <- sym.data$M
  out <- matrix(0, nrow = n, ncol = n)
  for (i in seq_len(m)) {
    for (j in seq_len(n)) {
      for (k in seq_len(n)) {
        out[j, k] <- out[j, k] + dist.mod(sym.data[j, i]$data, sym.data[
          k,
          i
        ]$data)
      }
    }
  }
  out <- dist(1 - (out / m))
  return(out)
}
#line 1 "/private/var/folders/x1/bc7ln59d11jddyfmvq0f4mwm0000gn/T/RtmpK8STdo/R.INSTALL582a7c381cc/RSDA/R/dist.set.R"
#' Compute the distance between two rows
#' @keywords internal
sym.Multieval.distance <- function(sym.data, variable, w1, w2, gamma = 0.5, method = "Minkowski",
                                   normalize = TRUE) {
  if (method == "Gowda.Diday" | method == "Ichino" | method == "Minkowski") {
    result <- sym.data
    if (result$sym.var.types[variable] == "$S") {
      lenght <- result$sym.var.length[variable]
      ini <- result$sym.var.starts[variable]
      var <- result$meta[, ini:(ini + lenght - 1)]
      Var <- colSums(rbind(var[w1, ], var[w2, ]))
      Union <- sum(Var > 0)
      Intersect <- length(which(Var == 2))
      if (method == "Gowda.Diday") {
        D1 <- abs(sum(var[w1, ]) - sum(var[w2, ])) / Union
        D2 <- (sum(var[w1, ]) + sum(var[w2, ]) - 2 * Intersect) / Union
        Distance <- D1 + D2
      } else {
        if (gamma > 0.5) {
          gamma <- 0.5
        }
        if (gamma < 0) {
          gamma <- 0
        }
        Distance <- Union - Intersect + gamma * (2 * Intersect - sum(var[w1, ]) - sum(var[w2, ]))
      }
      if (normalize == TRUE) {
        Distance <- Distance / result$sym.var.length[variable]
      }
    } else {
      Distance <- NA
    }
    return(Distance)
  }
  return("Invalid method")
}
#' Distance for Symbolic Set Variables.
#' @name sym.dist.set
#' @description This function computes and returns the distance matrix by using the specified
#' distance measure to compute distance between symbolic interval variables.
#'
#' @param sym.data A symbolic object
#' @param variables Numeric vector with the number of the variables to use.
#' @param gamma gamma value for the methods ichino and minkowski.
#' @param method Method to use (Gowda.Diday, Ichino, Minkowski, Hausdorff)
#' @param normalize A logical value indicating whether normalize the data in the ichino or hausdorff method.
#' @param q q value for the Minkowski method.
#' @param pond A numeric vector
#'
#' @return An object of class 'dist'
#' @export

sym.dist.set <- function(sym.data, gamma = 0.5, method = "Minkowski", normalize = TRUE,
                         q = 1, pond = rep(1, length(variables))) {
  variables <- (1:(sym.data$M))
  if (sum(pond) != length(variables) & sum(pond) > 1) {
    pond <- rep(1 / length(variables), length(variables))
  }
  for (med in 1:length(method)) {
    if (method[med] == "Gowda.Diday" | method[med] == "Ichino" | method[med] ==
      "Minkowski") {
      result <- sym.data
      h <- 1
      Dissimilarity.matrix <- matrix(c(0), ncol = nrow(result$data), nrow = nrow(result$data))
      if (method[med] == "Minkowski") {
        for (var in variables) {
          Matrix <- matrix(c(0), ncol = nrow(result$data), nrow = nrow(result$data))
          Matrix_pond <- matrix(c(0), ncol = nrow(result$data), nrow = nrow(result$data))
          for (j in 1:nrow(result$data)) {
            for (i in j:nrow(result$data)) {
              Matrix[i, j] <- sym.Multieval.distance(
                sym.data, var, i, j, gamma,
                method[med], normalize
              )
            }
          }
          if (q == 1) {
            Matrix_pond <- Matrix_pond + (Matrix * pond[h])
          } else {
            Matrix_pond <- Matrix_pond + (Matrix)^q
          }
          Dissimilarity.matrix <- Dissimilarity.matrix + Matrix_pond
          h <- h + 1
        }
        Dissimilarity.matrix <- as.dist(Dissimilarity.matrix^(1 / q))
      } else {
        for (var in variables) {
          Matrix <- matrix(c(0), ncol = nrow(result$data), nrow = nrow(result$data))
          Matrix_pond <- matrix(c(0), ncol = nrow(result$data), nrow = nrow(result$data))
          for (j in 1:nrow(result$data)) {
            for (i in j:nrow(result$data)) {
              Matrix[i, j] <- sym.Multieval.distance(
                sym.data, var, i, j, gamma,
                method[med], normalize
              )
            }
          }
          Matrix_pond <- Matrix_pond + (Matrix * pond[h])
          Dissimilarity.matrix <- Dissimilarity.matrix + Matrix_pond
          h <- h + 1
        }
        Dissimilarity.matrix <- as.dist(Dissimilarity.matrix)
      }
    } else {
      return("Invalid method")
    }
    if (med == 1) {
      res <- list(Dissimilarity.matrix)
      names <- matrix(c(method[med]))
    } else {
      names <- rbind(names, method[med])
      res[[length(res) + 1]] <- Dissimilarity.matrix
    }
    names(res) <- names
  }
  return(res)
}
#line 1 "/private/var/folders/x1/bc7ln59d11jddyfmvq0f4mwm0000gn/T/RtmpK8STdo/R.INSTALL582a7c381cc/RSDA/R/dist.vect.R"
#' Compute a distance vector
#' @name dist.vect
#' @aliases dist.vect
#' @author Jorge Arce
#' @description Compute a distance vector
#' @usage dist.vect(vector1, vector2)
#' @param vector1 First vector.
#' @param vector2 Second vector.
#'
#' @return Eclidean distance between the two vectors.
#' @references Arce J. and Rodriguez O. (2015) 'Principal Curves and Surfaces
#' to Interval Valued Variables'. The 5th Workshop on Symbolic
#' Data Analysis, SDA2015, Orleans, France, November.
#'
#' Hastie,T. (1984).
#' Principal Curves and Surface. Ph.D. Thesis Stanford University.
#'
#' Hastie,T. \& Weingessel,A. (2014).
#' princurve - Fits a Principal Curve in Arbitrary Dimension.R package version 1.1--12
#' http://cran.r-project.org/web/packages/princurve/index.html.
#'
#' Hastie,T. \& Stuetzle, W. (1989). Principal Curves.
#' Journal of the American Statistical Association, Vol. 84-406, 502--516.
#'
#' Hastie, T., Tibshirani, R. \& Friedman, J. (2008).
#' The Elements of Statistical Learning; Data Mining, Inference and Prediction.
#' Springer, New York.
#'
#' @seealso sym.interval.pc
#' @keywords Principal Curve
#'
dist.vect <- function(vector1, vector2) {
  dist <- 0
  if (ncol(vector1) == ncol(vector2)) {
    dist <- norm.vect(vector1 - vector2)
  }
  return(dist)
}
#line 1 "/private/var/folders/x1/bc7ln59d11jddyfmvq0f4mwm0000gn/T/RtmpK8STdo/R.INSTALL582a7c381cc/RSDA/R/dist.vect.matrix.R"
#' Compute the distance vector matrix
#' @name dist.vect.matrix
#' @aliases dist.vect.matrix
#' @author Jorge Arce.
#' @description Compute the distance vector matrix.
#'
#' @usage dist.vect.matrix(vector, Matrix)
#' @param vector An n dimensional vector.
#' @param Matrix An n x n matrix.
#'
#' @return The distance.
#' @references Arce J. and Rodriguez O. (2015) 'Principal Curves and Surfaces
#' to Interval Valued Variables'. The 5th Workshop on Symbolic
#' Data Analysis, SDA2015, Orleans, France, November.
#'
#' Hastie,T. (1984).
#' Principal Curves and Surface. Ph.D Thesis Stanford University.
#'
#' Hastie,T. \& Weingessel,A. (2014).
#' princurve - Fits a Principal Curve in Arbitrary Dimension.R package version 1.1--12
#' http://cran.r-project.org/web/packages/princurve/index.html.
#'
#' Hastie,T. \& Stuetzle, W. (1989). Principal Curves.
#' Journal of the American Statistical Association, Vol. 84-406, 502--516.
#'
#' Hastie, T., Tibshirani, R. \& Friedman, J. (2008).
#' The Elements of Statistical Learning; Data Mining, Inference and Prediction. Springer, New York.
#'
#' @seealso sym.interval.pc
#'
#' @keywords Principal Curve
#'
dist.vect.matrix <- function(vector, Matrix) {
  num.col.vect <- ncol(vector)
  num.col.matrix <- ncol(Matrix)
  num.row.matrix <- nrow(Matrix)
  dist.matrix <- rep(-1, num.row.matrix)
  if (num.col.vect == num.col.matrix) {
    for (i in 1:num.row.matrix) {
      w <- as.matrix(Matrix[i, ])
      dist.matrix[i] <- dist.vect(vector, t(w))
    }
  }
  return(dist.matrix)
}
#line 1 "/private/var/folders/x1/bc7ln59d11jddyfmvq0f4mwm0000gn/T/RtmpK8STdo/R.INSTALL582a7c381cc/RSDA/R/downarrow.matrix.R"
#' downarrow.matrix
#' @keywords internal
downarrow.matrix <- function(sym.data) {
  k <- max(sym.data$sym.var.length)
  nn <- sym.data$N
  mm <- sym.data$M
  n.sym.objects <- k * nn
  n.sym.var <- mm
  meta.M <- 3 * mm
  sym.var.types <- rep("$I", n.sym.var)
  sym.var.length <- rep(2, n.sym.var)
  sym.var.names <- sym.data$sym.var.names
  sym.var.starts <- seq(2, meta.M, 3)
  sym.obj.names <- seq(1, n.sym.objects)
  m1 <- as.data.frame(rep(0, n.sym.objects))
  for (j in 1:mm) {
    if (sym.var(sym.data, j)$var.type == "$C") {
      pos <- 1
      c1 <- rep("$I", n.sym.objects)
      c2 <- rep(0, n.sym.objects)
      c3 <- rep(0, n.sym.objects)
      for (i in 1:nn) {
        for (s in 1:k) {
          c2[pos] <- sym.var(sym.data, j)$var.data.vector[i]
          c3[pos] <- sym.var(sym.data, j)$var.data.vector[i]
          pos <- pos + 1
        }
      }
      m1 <- cbind(m1, c1, as.numeric(c2), as.numeric(c3))
    }
    if (sym.var(sym.data, j)$var.type == "$I") {
      pos <- 1
      c1 <- rep("$I", n.sym.objects)
      c2 <- rep(0, n.sym.objects)
      c3 <- rep(0, n.sym.objects)
      for (i in 1:nn) {
        for (s in 1:k) {
          c2[pos] <- sym.var(sym.data, j)$var.data.vector[i, 1]
          c3[pos] <- sym.var(sym.data, j)$var.data.vector[i, 2]
          pos <- pos + 1
        }
      }
      m1 <- cbind(m1, c1, as.numeric(c2), as.numeric(c3))
    }
    if (sym.var(sym.data, j)$var.type == "$H") {
      pos <- 1
      c1 <- rep("$I", n.sym.objects)
      c2 <- rep(0, n.sym.objects)
      c3 <- rep(0, n.sym.objects)
      ff <- sym.data$sym.var.length[j]
      for (i in 1:nn) {
        prob.acum <- 0
        for (s in 1:k) {
          if (s <= ff) {
            prob.acum <- prob.acum + sym.var(sym.data, j)$var.data.vector[
              i,
              s
            ]
            c3[pos] <- prob.acum
          } else {
            c3[pos] <- prob.acum
          }
          pos <- pos + 1
        }
      }
      m1 <- cbind(m1, c1, as.numeric(c2), as.numeric(c3))
    }
  }
  meta.data <- m1[, -1]
  vnames <- rep("$I", meta.M)
  pos <- 2
  for (i in 1:mm) {
    vnames[pos] <- sym.data$sym.var.names[i]
    vnames[pos + 1] <- sym.data$sym.var.names[i]
    pos <- pos + 3
  }
  colnames(meta.data) <- vnames
  data.matrix <- meta.data
  pos <- 1
  for (i in 1:mm) {
    data.matrix <- data.matrix[, -pos]
    pos <- pos + 2
  }
  sym.data <- list(
    N = n.sym.objects, M = n.sym.var, sym.obj.names = sym.obj.names,
    sym.var.names = sym.var.names, sym.var.types = sym.var.types, sym.var.length = sym.var.length,
    sym.var.starts = sym.var.starts, meta = meta.data, data = data.matrix
  )
  return(sym.data)
}
#line 1 "/private/var/folders/x1/bc7ln59d11jddyfmvq0f4mwm0000gn/T/RtmpK8STdo/R.INSTALL582a7c381cc/RSDA/R/generate.columns.interval.j.r"
#' generate.columns.interval
#' @keywords internal
generate.columns.interval <- function(data) {
  min.char <- as.character(round(data[, 1], 2))
  max.char <- as.character(round(data[, 2], 2))

  return(paste0(paste0("[", paste(min.char, max.char, sep = ",")), "]"))
}
#line 1 "/private/var/folders/x1/bc7ln59d11jddyfmvq0f4mwm0000gn/T/RtmpK8STdo/R.INSTALL582a7c381cc/RSDA/R/generate.columns.multivalued.j.r"
#' generate.columns.multivalued
#' @keywords internal
generate.columns.multivalued <- function(data) {
  data.colnames <- colnames(data)

  sal <- apply(data, 1, function(x) {
    paste0(paste0("{", paste(paste(data.colnames[x > 0], x[x > 0], sep = ";"),
      collapse = ","
    )), "}")
  })

  return(sal)
}
#line 1 "/private/var/folders/x1/bc7ln59d11jddyfmvq0f4mwm0000gn/T/RtmpK8STdo/R.INSTALL582a7c381cc/RSDA/R/generate.columns.set.j.r"
#' generate.columns.set
#' @keywords internal
generate.columns.set <- function(data) {
  data.colnames <- colnames(data)

  sal <- apply(data, 1, function(x) {
    paste0(paste0("{", paste(data.colnames[x == 1], collapse = ",")), "}")
  })
  return(sal)
}
#line 1 "/private/var/folders/x1/bc7ln59d11jddyfmvq0f4mwm0000gn/T/RtmpK8STdo/R.INSTALL582a7c381cc/RSDA/R/generate.sym.table.R"
#' Generate a Symbolic Data Table
#' @name generate.sym.table
#' @aliases generate.sym.table
#' @author Oldemar Rodriguez Rojas
#' @description This function generates a symbolic data table from a CSV data file.
#' @usage generate.sym.table(sym.data, file, sep, dec, row.names = NULL, col.names = NULL)
#'
#' @param sym.data Symbolic data table.
#' @param file The name of the CSV file.
#' @param sep As in R function read.table.
#' @param dec As in R function read.table.
#' @param row.names As in R function read.table.
#' @param col.names As in R function read.table.
#'
#' @return Return a symbolic data table.
#' @references Bock H-H. and Diday E. (eds.) (2000).
#' Analysis of Symbolic Data. Exploratory methods for extracting statistical information from
#' complex data. Springer, Germany.
#'
#' @examples
#' data(example1)
#' generate.sym.table(example1, file='temp4.csv', sep='|',dec='.', row.names=TRUE,
#'                    col.names=TRUE)
#' ex1 <- read.sym.table('temp4.csv', header=TRUE, sep='|',dec='.', row.names=1)
#' @keywords Symbolic Table
#' @export
#' @importFrom utils write.table
#'
generate.sym.table <- function(sym.data, file, sep, dec, row.names = NULL, col.names = NULL) {
  ncolumn <- rep(sym.data$sym.var.types[1], sym.data$N)
  temp.data <- cbind(temp = ncolumn, sym.data$data[, 1:ncol(sym.data$data)])
  colnames(temp.data)[1] <- sym.data$sym.var.types[1]
  pos <- 1 # pos = valid number of columns inserted
  if ((sym.data$sym.var.types[1] == "$C") || (sym.data$sym.var.types[1] == "$c")) {
    pos <- 2
  }
  if ((sym.data$sym.var.types[1] == "$I") || (sym.data$sym.var.types[1] == "$i")) {
    pos <- 3
  }
  if ((sym.data$sym.var.types[1] == "$H") || (sym.data$sym.var.types[1] == "$h") ||
    (sym.data$sym.var.types[1] == "$S") || (sym.data$sym.var.types[1] == "$s")) {
    ncolumn <- rep(sym.data$sym.var.length[1], sym.data$N)
    temp.data <- cbind(temp.data[, 1:pos], temp = ncolumn, temp.data[, (pos + 1):ncol(temp.data)])
    colnames(temp.data)[(pos + 1)] <- sym.data$sym.var.names[1]
    pos <- pos + 1 + sym.data$sym.var.length[1]
  }
  for (j in 2:sym.data$M) {
    ncolumn <- rep(sym.data$sym.var.types[j], sym.data$N)
    temp.data <- cbind(temp.data[, 1:pos], temp = ncolumn, temp.data[, (pos + 1):ncol(temp.data)])
    colnames(temp.data)[pos + 1] <- sym.data$sym.var.types[j]
    pos <- pos + 1
    if ((sym.data$sym.var.types[j] == "$C") || (sym.data$sym.var.types[j] == "$c")) {
      pos <- pos + 1
    }
    if ((sym.data$sym.var.types[j] == "$I") || (sym.data$sym.var.types[j] == "$i")) {
      pos <- pos + 2
    }
    if ((sym.data$sym.var.types[j] == "$H") || (sym.data$sym.var.types[j] == "$h") ||
      (sym.data$sym.var.types[j] == "$S") || (sym.data$sym.var.types[j] == "$s")) {
      ncolumn <- rep(sym.data$sym.var.length[j], sym.data$N)
      temp.data <- cbind(temp.data[, 1:pos], temp = ncolumn, temp.data[, (pos +
        1):ncol(temp.data)])
      colnames(temp.data)[(pos + 1)] <- sym.data$sym.var.names[j]
      pos <- pos + 1 + sym.data$sym.var.length[j]
    }
  }
  write.table(temp.data, file,
    sep = as.character(sep), dec = dec, quote = FALSE,
    row.names = c(row.names), col.names = c(col.names)
  )
}
#line 1 "/private/var/folders/x1/bc7ln59d11jddyfmvq0f4mwm0000gn/T/RtmpK8STdo/R.INSTALL582a7c381cc/RSDA/R/get.rotation.matrix.j.r"
#' get.rotation.matrix
#' @keywords internal
get.rotation.matrix <- function(pca) {
  return(t(apply(pca$var$coord, 1, function(x) {
    x / sqrt(pca$eig[, 1])
  })))
}
#line 1 "/private/var/folders/x1/bc7ln59d11jddyfmvq0f4mwm0000gn/T/RtmpK8STdo/R.INSTALL582a7c381cc/RSDA/R/interscal.B.R"
#' interscal.B
#' @keywords internal
interscal.B <- function(sym.data) {
  MDis <- interscal.delta(sym.data)
  Fil <- dim(MDis)[1] # Fil is 2m
  suma1 <- 0
  suma2 <- 0
  suma3 <- 0
  B <- matrix(0, Fil, Fil)
  for (r in 1:Fil) {
    for (s in 1:Fil) {
      suma3 <- suma3 + (MDis[r, s] * MDis[r, s])
    }
  }
  for (i in 1:Fil) {
    for (j in 1:Fil) {
      suma1 <- 0
      for (r in 1:Fil) {
        suma1 <- suma1 + (MDis[r, j] * MDis[r, j])
      }
      suma2 <- 0
      for (s in 1:Fil) {
        suma2 <- suma2 + (MDis[i, s] * MDis[i, s])
      }
      B[i, j] <- (-1 / 2) * (MDis[i, j] * MDis[i, j] - (1 / Fil) * suma1 - (1 / Fil) *
        suma2 + ((1 / Fil)^2) * suma3)
    }
  }
  return(B)
}
#line 1 "/private/var/folders/x1/bc7ln59d11jddyfmvq0f4mwm0000gn/T/RtmpK8STdo/R.INSTALL582a7c381cc/RSDA/R/interscal.R"
#' Interscal Method
#' @name interscal
#' @aliases interscal
#' @author Oldemar Rodriguez Rojas
#' @description Execute Interscal Method.
#' @usage interscal(sym.data)
#' @param sym.data The symbolic data matrix.
#'
#' @return The symbolic interval components.
#' @references Groenen, P.J.F., Winsberg, S., Rodriguez, O., Diday, E. (2006). I-Scal: Multidimensional
#' scaling of interval dissimilarities. Computational Statistics and Data Analysis, 51,
#' 360-378.
#'
#' Rodriguez, O. (2000).
#' Classification et Modeles Lineaires en Analyse des Donnees Symboliques. Ph.D. Thesis,
#' Paris IX-Dauphine University
#' @seealso sym.interval.pca
#'
#' @examples
#' \dontrun{
#' data(oils)
#' res<-interscal(oils)
#' class(res$Sym.Components) <- c('sym.data.table')
#' sym.scatterplot(res$Sym.Components[,1], res$Sym.Components[,2],
#'                 labels=TRUE,col='red',main='Interscal CFA Data')
#' sym.scatterplot3d(res$Sym.Components[,1], res$Sym.Components[,2],
#'                   res$Sym.Components[,3],color='blue',
#'                   labels=TRUE,main='Interscal CFA Data')
#' sym.scatterplot.ggplot(res$Sym.Components[,1],res$Sym.Components[,2],
#'                        labels=TRUE)
#' }
#' @keywords Interscal
#' @export
interscal <- function(sym.data) {
  sdn <- sym.normalize(sym.data)
  BM <- interscal.B(sdn)
  ds <- eigen(BM)
  ValP <- ds$values
  VecP <- ds$vector
  n <- 2 * sym.data$N
  m <- sym.data$M
  if (n < m) {
    nn <- min(n, m)
  } else {
    nn <- m
  }
  prin.com <- matrix(0, n, nn)
  for (i in 1:n) {
    for (j in 1:nn) {
      prin.com[i, j] <- sqrt(abs(ValP[j])) * VecP[i, j]
    }
  }
  # Interval Principal Components
  sym.comp <- sym.data
  NObjSimb <- sym.data$N
  nn <- sym.data$M
  Min <- matrix(0, NObjSimb, nn)
  Max <- matrix(0, NObjSimb, nn)
  for (j in 1:nn) {
    for (i in 1:NObjSimb) {
      ii <- 2 * (i - 1) + 1
      max <- prin.com[ii, j]
      min <- prin.com[ii, j]
      for (k in ii:(2 * i)) {
        if (prin.com[k, j] > max) {
          max <- prin.com[k, j]
        }
        if (prin.com[k, j] < min) {
          min <- prin.com[k, j]
        }
      }
      Min[i, j] <- min
      Max[i, j] <- max
    }
  }
  for (i in 1:NObjSimb) {
    posd <- 1
    for (j in 1:nn) {
      sym.comp$meta[i, sym.comp$sym.var.starts[j]] <- Min[i, j]
      sym.comp$meta[i, sym.comp$sym.var.starts[j] + 1] <- Max[i, j]
      sym.comp$data[i, posd] <- Min[i, j]
      sym.comp$data[i, posd + 1] <- Max[i, j]
      posd <- posd + 2
    }
  }
  return(list(Eigenvalues = ValP, Eignvector = VecP, Sym.Components = sym.comp))
}
#line 1 "/private/var/folders/x1/bc7ln59d11jddyfmvq0f4mwm0000gn/T/RtmpK8STdo/R.INSTALL582a7c381cc/RSDA/R/interscal.delta.R"
#' interscal.delta
#' @keywords internal
interscal.delta <- function(sym.data) {
  res <- interval.dist(sym.data, distance = "interscal")
  CMin <- res$min.matrix
  CMax <- res$max.matrix
  Fil <- sym.data$N
  D2M <- matrix(0, 2 * Fil, 2 * Fil)
  for (i in 1:Fil) {
    for (j in i:Fil) {
      if (i == j) {
        if (j != Fil) {
          D2M[2 * i - 1, 2 * j - 1] <- 0
          D2M[2 * i, 2 * j] <- 0
          D2M[2 * i - 1, 2 * j] <- CMax[i, j]
          D2M[2 * j, 2 * i - 1] <- D2M[2 * i - 1, 2 * j]
        } else {
          D2M[2 * i - 1, 2 * j - 1] <- 0
          D2M[2 * i, 2 * j] <- 0
          D2M[2 * i - 1, 2 * j] <- CMax[i, i]
          D2M[2 * j, 2 * i - 1] <- D2M[2 * i - 1, 2 * j]
        }
      } else {
        D2M[2 * i - 1, 2 * j - 1] <- CMin[i, j]
        D2M[2 * i, 2 * j] <- CMax[i, j]
        D2M[2 * i - 1, 2 * j] <- (CMax[i, j] + CMin[i, j]) / 2
        D2M[2 * i, 2 * j - 1] <- (CMax[i, j] + CMin[i, j]) / 2
        D2M[2 * j - 1, 2 * i - 1] <- D2M[2 * i - 1, 2 * j - 1]
        D2M[2 * j, 2 * i] <- D2M[2 * i, 2 * j]
        D2M[2 * j, 2 * i - 1] <- D2M[2 * i - 1, 2 * j]
        D2M[2 * j - 1, 2 * i] <- D2M[2 * i, 2 * j - 1]
      }
    }
  }
  return(D2M)
}
#line 1 "/private/var/folders/x1/bc7ln59d11jddyfmvq0f4mwm0000gn/T/RtmpK8STdo/R.INSTALL582a7c381cc/RSDA/R/interval.dist.R"
#' Interval Distance Matrix
#' @name interval.dist
#' @aliases interval.dist
#' @author Oldemar Rodriguez Rojas
#' @description Compute a distance matrix from a symbolic interval data matrix.
#' @usage interval.dist(sym.data, distance = c('hausdorff', 'centers', 'interscal'), p = 2)
#' @param sym.data Symbolic data matrix with the variables of interval type.
#' @param distance The distance to be use.
#' @param p The p in the Hausdorff distance :
#'
#' \deqn{d(w_{u_1},w_{u_2}) = \left( \sum_{j=1}^m \Phi_j(w_{u_1},w_{u_2})^p  \right)^{1/p}}
#'
#' @return Return a R distance triangular matrix.
#' @references
#' Groenen, P.J.F., Winsberg, S., Rodriguez, O., Diday, E. (2006). I-Scal: Multidimensional
#' scaling of interval dissimilarities. Computational Statistics and Data Analysis, 51,
#' 360-378.
#'
#' Billard L. and  Diday E. (2006).
#' Symbolic data analysis: Conceptual statistics and data mining. Wiley, Chichester.
#' @examples
#' \dontrun{
#' data(VeterinaryData)
#' VD <- VeterinaryData
#' interval.dist(VD)
#' interval.dist(VD,distance='centers')
#' }
#' @keywords Symbolic Distance
#' @export
#' @importFrom stats as.dist
#'
interval.dist <-
  function(sym.data, distance=c("hausdorff", "centers", "interscal"), p=2) {
    distance <- match.arg(distance)
    if ((distance == "hausdorff") || (distance == "centers")) {
      idn <- all(sym.data$sym.var.types == "$I")
      if (idn == FALSE) {
        stop("The two variables have to be interval type")
      }
      nn <- sym.data$N
      mm <- sym.data$M
      dist.matrix <- matrix(0, nn, nn)
      for (i in 1:nn) {
        for (j in 1:i) {
          dist.matrix[i, j] <- interval.dist.tobj(
            sym.obj(sym.data, i), sym.obj(sym.data, j),
            distance
          )
          dist.matrix[j, i] <- dist.matrix[i, j]
        }
      }
      return(as.dist(dist.matrix))
    }
    if ((distance == "interscal")) {
      idn <- all(sym.data$sym.var.types == "$I")
      if (idn == FALSE) {
        stop("The two variables have to be interval type")
      }
      nn <- sym.data$N
      mm <- sym.data$M
      dist.matrix <- matrix(0, nn, 2 * nn)
      min.matrix <- matrix(0, nn, nn)
      max.matrix <- matrix(0, nn, nn)
      pos <- 1
      for (j in 1:nn) {
        for (i in 1:nn) {
          dist.matrix[i, pos] <- interval.dist.tobj(sym.obj(sym.data, i), sym.obj(sym.data, j), distance)[1]
          dist.matrix[i, pos + 1] <- interval.dist.tobj(sym.obj(sym.data, i), sym.obj(sym.data, j), distance)[2]
          min.matrix[i, j] <- dist.matrix[i, pos]
          max.matrix[i, j] <- dist.matrix[i, pos + 1]
        }
        pos <- pos + 2
      }
      return(list(interval.dist = dist.matrix, min.matrix = min.matrix, max.matrix = max.matrix))
    }
  }
#line 1 "/private/var/folders/x1/bc7ln59d11jddyfmvq0f4mwm0000gn/T/RtmpK8STdo/R.INSTALL582a7c381cc/RSDA/R/interval.dist.tobj.R"
#' Symbolic Objects Distance
#' @name interval.dist.tobj
#' @aliases interval.dist.tobj
#' @author Oldemar Rodriguez Rojas
#' @description Compute a distance between two symbolic objects.
#' @usage interval.dist.tobj(sym.obj.x, sym.obj.y, distance = c('hausdorff',
#' 'centers', 'interscal'), p = 2)
#' @param sym.obj.x First Symbolic Object
#' @param sym.obj.y Second Symbolic Object
#' @param distance Dsitance to be use
#' @param p The p in the Hausdorff distance
#'
#' \deqn{d(w_{u_1},w_{u_2}) = \left( \sum_{j=1}^m \Phi_j(w_{u_1},w_{u_2})^p  \right)^{1/p}}
#'
#' @return Return a real number that is the distance between sym.obj.x and sym.obj.y
#' @references
#' Billard L. and  Diday E. (2006).
#' Symbolic data analysis: Conceptual statistics and data mining. Wiley, Chichester.
#' @seealso interval.dist
#' @examples
#' data(VeterinaryData)
#' VD <- VeterinaryData
#' interval.dist.tobj(sym.obj(VD,1),sym.obj(VD,2))
#' interval.dist.tobj(sym.obj(VD,1),sym.obj(VD,2),distance='centers')
#' @keywords Symbolic Distance
#' @export
interval.dist.tobj <- function(sym.obj.x, sym.obj.y, distance = c(
                                 "hausdorff", "centers",
                                 "interscal"
                               ), p = 2) {
  distance <- match.arg(distance)
  idn1 <- all(sym.obj.x$var.types == "$I")
  idn2 <- all(sym.obj.y$var.types == "$I")
  if ((idn1 == FALSE) || (idn2 == FALSE)) {
    stop("The two variables have to be interval type")
  }
  if (distance == "hausdorff") {
    pos <- 1
    sum <- 0
    for (j in 1:(sym.obj.x$M)) {
      a <- abs(sym.obj.x$obj.data.vector[pos] - sym.obj.y$obj.data.vector[pos])
      b <- abs(sym.obj.x$obj.data.vector[pos + 1] - sym.obj.y$obj.data.vector[pos +
        1])
      m <- max(a, b)
      pos <- pos + 2
      sum <- sum + m^p
    }
    return(sum^(1 / p))
  }
  if (distance == "centers") {
    pos <- 1
    sum <- 0
    for (j in 1:(sym.obj.x$M)) {
      a <- (sym.obj.x$obj.data.vector[pos] + sym.obj.x$obj.data.vector[pos +
        1]) / 2
      b <- (sym.obj.y$obj.data.vector[pos] + sym.obj.y$obj.data.vector[pos +
        1]) / 2
      m <- abs(a - b)
      pos <- pos + 2
      sum <- sum + m^p
    }
    return(sum^(1 / p))
  }
  if (distance == "interscal") {
    # Daneaux and Masson Distance
    pos <- 1
    suma <- 0
    sumb <- 0
    for (j in 1:(sym.obj.x$M)) {
      a <- (sym.obj.x$obj.data.vector[pos + 1] - sym.obj.x$obj.data.vector[pos] +
        sym.obj.y$obj.data.vector[pos + 1] - sym.obj.y$obj.data.vector[pos] -
        2 * abs((sym.obj.x$obj.data.vector[pos + 1] + sym.obj.x$obj.data.vector[pos]) / 2 -
          (sym.obj.y$obj.data.vector[pos + 1] + sym.obj.y$obj.data.vector[pos]) / 2) -
        abs(sym.obj.x$obj.data.vector[pos + 1] - sym.obj.x$obj.data.vector[pos] +
          sym.obj.y$obj.data.vector[pos + 1] - sym.obj.y$obj.data.vector[pos] -
          2 * abs((sym.obj.x$obj.data.vector[pos + 1] + sym.obj.x$obj.data.vector[pos]) / 2 -
            (sym.obj.y$obj.data.vector[pos + 1] + sym.obj.y$obj.data.vector[pos]) / 2)))^2
      suma <- suma + a
      b <- (sym.obj.x$obj.data.vector[pos + 1] - sym.obj.x$obj.data.vector[pos] +
        sym.obj.y$obj.data.vector[pos + 1] - sym.obj.y$obj.data.vector[pos] +
        2 * abs((sym.obj.x$obj.data.vector[pos + 1] + sym.obj.x$obj.data.vector[pos]) / 2 -
          (sym.obj.y$obj.data.vector[pos + 1] + sym.obj.y$obj.data.vector[pos]) / 2))^2
      sumb <- sumb + b
      pos <- pos + 2
    }
    return(c((1 / 4) * sqrt(suma), (1 / 2) * sqrt(sumb)))
  }
}
#line 1 "/private/var/folders/x1/bc7ln59d11jddyfmvq0f4mwm0000gn/T/RtmpK8STdo/R.INSTALL582a7c381cc/RSDA/R/interval.histogram.plot.R"
#' Histogram plot for an interval variable
#'
#' @param x An symbolic data table.
#' @param n.bins Numbers of breaks of the histogram.
#' @param ... Arguments to be passed to the barplot method.
#'
#' @return A list with componets : frequency and histogram
#' @export
#'
#' @examples
#' data(oils)
#' res <- interval.histogram.plot(x = oils[,3], n.bins = 3)
#' res
interval.histogram.plot <- function(x, n.bins, ...) {
  if (x$M > 1) {
    stop("x must be a sym.data.table with only one variable of type interval.")
  }
  if (x$sym.var.types %in% c("$I")) {
    data. <- x$data
    data.min <- min(data.)
    data.max <- max(data.)
    n.intervals <- length(n.bins) - 1
    if (n.intervals == 0) {
      n.bins <- seq(from = data.min, to = data.max, length.out = n.bins + 1)
      n.bins <- round(x = n.bins, digits = 2)
    } else {
      int.min <- min(n.bins)
      int.max <- max(n.bins)
      if (data.min < int.min) {
        n.bins <- c(data.min, n.bins)
      }
      if (int.max < data.max) {
        n.bins <- c(n.bins, data.max)
      }
    }
    m <- nrow(data.)
    n.intervals <- length(n.bins) - 1

    data.i <- data.[, 1]
    data.s <- data.[, 2]

    freqs <- numeric(length = n.intervals)
    names <- character(length = n.intervals)

    for (i in 1:n.intervals) {
      interval.i <- n.bins[i]
      interval.s <- n.bins[i + 1]
      names[i] <- paste0("[", interval.i, ",", interval.s, "]")

      ind <- (data.s > interval.i) & (data.i < interval.s)
      x.i <- y.i <- data.i[ind]
      x.s <- y.s <- data.s[ind]
      y.i[x.i <= interval.i] <- interval.i
      y.s[interval.s <= x.s] <- interval.s

      freqs[i] <- 100 * sum((y.s - y.i) / (x.s - x.i)) / m
    }

    freqs <- round(x = freqs, digits = 1)

    histogram <- barplot(height = freqs, names.arg = names, ...)

    return(list(frequency = freqs, histogram = histogram))
  } else {
    stop("var.number does not point to an interval value variable")
  }
}
#line 1 "/private/var/folders/x1/bc7ln59d11jddyfmvq0f4mwm0000gn/T/RtmpK8STdo/R.INSTALL582a7c381cc/RSDA/R/is.vertex.j.r"
#' is.vertex
#' @keywords internal
is.vertex <- function(optim.matrix, vertex.matrix) {
  optim.matrix <- as.data.frame(optim.matrix)
  m <- dim(optim.matrix)
  cols <- 1:m[2]
  cols.names <- paste0("V", cols)
  colnames(optim.matrix) <- colnames(vertex.matrix) <- cols.names
  T1.cols <- paste0("T1.", cols.names)
  T2.cols <- paste0("T2.", cols.names)

  join <- paste(paste(T1.cols, "=", T2.cols), collapse = " AND ")

  query <- "SELECT T1.* FROM [optim.matrix] T1 INNER JOIN [vertex.matrix] T2 ON "
  query <- paste0(query, join)
  sal <- sqldf(query)
  return(m[1] == dim(sal)[1])
}
#line 1 "/private/var/folders/x1/bc7ln59d11jddyfmvq0f4mwm0000gn/T/RtmpK8STdo/R.INSTALL582a7c381cc/RSDA/R/mean.sym.data.table.R"
#' Symbolic Mean
#' @name mean.sym.data.table
#' @aliases  mean.sym.data.table
#' @author Oldemar Rodriguez Rojas
#' @description This function compute the symbolic mean
#' @param x The symbolic variable.
#' @param method The method to be use.
#' @param trim As in R mean function.
#' @param na.rm As in R mean function.
#' @param ... As in R mean function.
#'
#' @return Return a real number.
#' @references
#' Billard L. and  Diday E. (2006).
#' Symbolic data analysis: Conceptual statistics and data mining. Wiley, Chichester.
#'
#' Rodriguez, O. (2000).
#' Classification et Modeles Lineaires en Analyse des Donnees Symboliques. Ph.D. Thesis,
#' Paris IX-Dauphine University.
#'
#' @examples
#' data(example3)
#' sym.data<-example3
#' mean(sym.data[,1])
#' mean(sym.data[,2])
#' mean(sym.data[,2], method='interval')
#' mean(sym.data[,3], method='modal')
#'
#' @keywords Symbolic Mean
#' @export
#' @exportMethod
#'
mean.sym.data.table <- function(x, method = c("centers", "interval", "modal"), trim = 0,
                                na.rm = F, ...) {
  method <- match.arg(method)
  if (method == "centers") {
    if (x$sym.var.types == "$C") {
      return(mean(x$data[, 1], trim, na.rm, ...))
    }
    if (x$sym.var.types == "$I") {
      return(mean((x$data[, 1] + x$data[, 2]) / 2, ...))
    } else {
      stop("Impossible to compute the mean for this type of variable with this method")
    }
  }
  if (method == "interval") {
    if (x$sym.var.types == "$I") {
      return(colMeans(x$data))
    } else {
      stop("Impossible to compute the mean for this type of variable with this method")
    }
  }
  if (method == "modal") {
    if (x$sym.var.types == "$M") {
      return(colMeans(x$data))
    } else {
      stop("Impossible to compute the mean for this type of variable with this method")
    }
  }
}
#line 1 "/private/var/folders/x1/bc7ln59d11jddyfmvq0f4mwm0000gn/T/RtmpK8STdo/R.INSTALL582a7c381cc/RSDA/R/median.sym.data.table.R"
#' Symbolic Median
#' @name median.sym.data.table
#' @aliases median.sym.data.table
#' @author Oldemar Rodriguez Rojas
#' @description This function compute the symbolic median.
#' @param x The symbolic variable.
#' @param method The method to be use.
#' @param na.rm As in R median function.
#' @param ... As in R median function.
#'
#' @return Return a real number.
#' @references
#' Billard L. and  Diday E. (2006).
#' Symbolic data analysis: Conceptual statistics and data mining. Wiley, Chichester.
#'
#' Rodriguez, O. (2000).
#' Classification et Modeles Lineaires en Analyse des Donnees Symboliques. Ph.D. Thesis,
#' Paris IX-Dauphine University.
#'
#' @examples
#' data(example3)
#' sym.data<-example3
# median(sym.data[,1])
#' median(sym.data[,2])
#' median(sym.data[,6] ,method='interval')
#' median(sym.data[,3] ,method='modal')
#' @keywords Symbolic Median
#' @export
#'
median.sym.data.table <- function(x, na.rm = FALSE, method = c(
                                    "centers", "interval",
                                    "modal"
                                  ), ...) {
  method <- match.arg(method)
  if (method == "centers") {
    if (x$sym.var.types == "$C") {
      return(median(x$data[, 1]))
    }
    if (x$sym.var.types == "$I") {
      return(median(x$data[, 1] + x$data[, 2]) / 2)
    } else {
      stop("Impossible to compute the median for this type of variable with this method")
    }
  }
  if (method == "interval") {
    if (x$sym.var.types == "$I") {
      return(sapply(x$data, median))
    } else {
      stop("Impossible to compute the median for this type of variable with this method")
    }
  }
  if (method == "modal") {
    if (x$sym.var.types == "$M") {
      return(sapply(x$data, median))
    } else {
      stop("Impossible to compute the median for this type of variable with this method")
    }
  }
}
#line 1 "/private/var/folders/x1/bc7ln59d11jddyfmvq0f4mwm0000gn/T/RtmpK8STdo/R.INSTALL582a7c381cc/RSDA/R/meta.to.RSDA.j.r"
#' meta.to.RSDA
#' @keywords internal
meta.to.RSDA <- function(data.meta) {
  dim.meta <- dim(data.meta)
  names.col.meta <- colnames(data.meta)
  pos.var <- pos.hist <- which(names.col.meta %in% c("$S", "$H"))
  pos.inter <- which(names.col.meta %in% c("$I"))
  pos.cont <- which(names.col.meta %in% c("$C"))
  N <- dim.meta[1]
  tam.col.data <- 0
  if (length(pos.hist) > 0) {
    tam.col.data <- tam.col.data + sum(data.meta[1, pos.hist + 1])
  }

  if (length(pos.inter) > 0) {
    tam.col.data <- tam.col.data + 2 * length(pos.inter)
    pos.var <- c(pos.var, pos.inter)
  }

  if (length(pos.cont) > 0) {
    tam.col.data <- tam.col.data + length(pos.inter)
    pos.var <- c(pos.var, pos.cont)
  }

  data <- matrix(rep(0, tam.col.data * N), nrow = N)
  pos.var <- pos.var[order(pos.var)]
  M <- length(pos.var)

  sym.var.names <- sym.var.length <- sym.var.starts <- rep(0, M)

  ind.star <- 1
  for (i in 1:M) {
    pos.act <- pos.var[i]
    var.act <- names.col.meta[pos.act]
    switch(var.act, `$S` = {
      var.length <- data.meta[1, pos.act + 1]
      sym.var.length[i] <- var.length
      sym.var.names[i] <- names.col.meta[pos.act + 1]
      sym.var.starts[i] <- ind.star + 2
      ind.star <- ind.star + 2 + var.length
    }, `$H` = {
      var.length <- data.meta[1, pos.act + 1]
      sym.var.length[i] <- data.meta[1, pos.act + 1]
      sym.var.names[i] <- names.col.meta[pos.act + 1]
      sym.var.starts[i] <- ind.star + 2
      ind.star <- ind.star + 2 + var.length
    }, `$I` = {
      sym.var.length[i] <- 2
      sym.var.names[i] <- names.col.meta[pos.act + 1]
      sym.var.starts[i] <- ind.star + 1
      ind.star <- ind.star + 3
    }, `$C` = {
      sym.var.length[i] <- 1
      sym.var.names[i] <- names.col.meta[pos.act + 1]
      sym.var.starts[i] <- ind.star + 1
      ind.star <- ind.star + 2
    })
  }

  data <- data.meta[, -c(pos.var, pos.hist + 1)]
  sym.obj.names <- row.names(data.meta)

  return(list(
    N = N, M = M, sym.obj.names = sym.obj.names, sym.var.names = sym.var.names,
    sym.var.types = names.col.meta[pos.var], sym.var.length = sym.var.length, sym.var.starts = sym.var.starts,
    meta = data.meta, data = data
  ))
}
#line 1 "/private/var/folders/x1/bc7ln59d11jddyfmvq0f4mwm0000gn/T/RtmpK8STdo/R.INSTALL582a7c381cc/RSDA/R/neg.desv.fun.j.r"
#' neg.desv.fun
#' @keywords internal
neg.desv.fun <- function(x) {
  return(-desv.fun(x))
}
#line 1 "/private/var/folders/x1/bc7ln59d11jddyfmvq0f4mwm0000gn/T/RtmpK8STdo/R.INSTALL582a7c381cc/RSDA/R/neighbors.vertex.R"
#' Compute neighbors vertex
#' @name neighbors.vertex
#' @author Jorge Arce
#' @aliases neighbors.vertex
#' @description Compute neighbors vertex
#' @usage neighbors.vertex(vertex, Matrix, num.neig)
#' @param vertex Vertes of the hipercube
#' @param Matrix Interval Data Matrix.
#' @param num.neig Number of vertices.
#' @references
#' Arce J. and Rodriguez O. (2015) 'Principal Curves and Surfaces
#' to Interval Valued Variables'. The 5th Workshop on Symbolic
#' Data Analysis, SDA2015, Orleans, France, November.
#'
#' Hastie,T. (1984).
#' Principal Curves and Surface. Ph.D Thesis Stanford University.
#'
#' Hastie,T. \& Weingessel,A. (2014).
#' princurve - Fits a Principal Curve in Arbitrary Dimension.R package version 1.1--12
#' http://cran.r-project.org/web/packages/princurve/index.html.
#'
#' Hastie,T. \& Stuetzle, W. (1989). Principal Curves.
#' Journal of the American Statistical Association, Vol. 84-406, 502--516.
#'
#' Hastie, T., Tibshirani, R. \& Friedman, J. (2008).
#' The Elements of Statistical Learning; Data Mining, Inference and Prediction.
#' Springer, New York.
#'
#' @seealso sym.interval.pc
#' @keywords Principal Curve
#'
neighbors.vertex <- function(vertex, Matrix, num.neig) {
  dist <- dist.vect.matrix(t(vertex), Matrix)
  index <- order(dist, decreasing = FALSE)
  neighbors <- Matrix[index[1:num.neig], ]
  return(list(neighbors = neighbors, order = index, distance = dist))
}
#line 1 "/private/var/folders/x1/bc7ln59d11jddyfmvq0f4mwm0000gn/T/RtmpK8STdo/R.INSTALL582a7c381cc/RSDA/R/newSobject.R"
#' newSobject
#' @keywords internal
newSobject <- function(meta.data) {
  special.indexes.1 <- which(colnames(meta.data) %in% c("$C", "$I"))
  special.indexes.2 <- which(colnames(meta.data) %in% c("$H", "$S", "$M"))
  special.indexes.all <- sort(c(special.indexes.1, special.indexes.2))
  index.colnames <- colnames(meta.data)[special.indexes.all]

  sym.var.length <- integer()
  for (i in 1:length(index.colnames)) {
    switch(index.colnames[[i]], `$C` = {
      sym.var.length <- c(sym.var.length, 1)
    }, `$I` = {
      sym.var.length <- c(sym.var.length, 2)
    }, `$H` = {
      sym.var.length <- c(sym.var.length, meta.data[[1, special.indexes.all[[i]] +
        1]])
    }, `$M` = {
      sym.var.length <- c(sym.var.length, meta.data[[1, special.indexes.all[[i]] +
        1]])
    }, `$S` = {
      sym.var.length <- c(sym.var.length, meta.data[[1, special.indexes.all[[i]] +
        1]])
    }, stop("Invalid argument!"))
  }

  return(list(
    N = nrow(meta.data), M = length(special.indexes.all), sym.obj.names = row.names(meta.data),
    sym.var.names = colnames(meta.data)[special.indexes.all + 1], sym.var.types = colnames(meta.data)[special.indexes.all],
    sym.var.length = sym.var.length, sym.var.starts = sort(c(special.indexes.1 +
      1, special.indexes.2 + 2)), meta = meta.data, data = meta.data[, -c(
      special.indexes.all,
      special.indexes.2 + 1
    )]
  ))
}
#line 1 "/private/var/folders/x1/bc7ln59d11jddyfmvq0f4mwm0000gn/T/RtmpK8STdo/R.INSTALL582a7c381cc/RSDA/R/norm.vect.R"
#' Compute the norm of a vector.
#' @name norm.vect
#' @aliases norm.vect
#' @author Jorge Arce
#'
#' @usage norm.vect(vector1)
#' @param vector1 An n dimensional vector.
#' @return The L2 norm of the vector.
#' @references Arce J. and Rodriguez O. (2015) 'Principal Curves and Surfaces
#' to Interval Valued Variables'. The 5th Workshop on Symbolic
#' Data Analysis, SDA2015, Orleans, France, November.
#'
#' Hastie,T. (1984).
#' Principal Curves and Surface. Ph.D Thesis Stanford University.
#'
#' Hastie,T. \& Weingessel,A. (2014).
#' princurve - Fits a Principal Curve in Arbitrary Dimension.R package version 1.1--12
#' http://cran.r-project.org/web/packages/princurve/index.html.
#'
#' Hastie,T. \& Stuetzle, W. (1989). Principal Curves.
#' Journal of the American Statistical Association, Vol. 84-406, 502--516.
#'
#' Hastie, T., Tibshirani, R. \& Friedman, J. (2008).
#' The Elements of Statistical Learning; Data Mining, Inference and Prediction.
#'  Springer, New York.
#'
#' @seealso sym.interval.pc
#' @keywords Principal Curve
#'
norm.vect <- function(vector1) {
  norm <- sqrt(sum(vector1^2))
  return(norm)
}
#line 1 "/private/var/folders/x1/bc7ln59d11jddyfmvq0f4mwm0000gn/T/RtmpK8STdo/R.INSTALL582a7c381cc/RSDA/R/optim.desv.fun.interval.j.r"
#' optim.desv.fun.interval
#' @keywords internal
optim.desv.fun.interval <- function(sym.var.1) {
  res.min <- cobyla(sym.var.1$var.data.vector[, 1], desv.fun, lower = sym.var.1$var.data.vector[
    ,
    1
  ], upper = sym.var.1$var.data.vector[, 2], nl.info = FALSE, control = list(
    xtol_rel = 1e-08,
    maxeval = 20000
  ))

  res.max <- cobyla(sym.var.1$var.data.vector[, 1], neg.desv.fun, lower = sym.var.1$var.data.vector[
    ,
    1
  ], upper = sym.var.1$var.data.vector[, 2], nl.info = FALSE, control = list(
    xtol_rel = 1e-08,
    maxeval = 20000
  ))


  tmp.df <- data.frame(res.min$value, -res.max$value)
  colnames(tmp.df) <- c("sd", "sd.1")
  row.names(tmp.df) <- sym.var.1$var.name
  return(list(
    N = 1, var.name = "sd", var.type = "$I", obj.names = sym.var.1$var.name,
    var.data.vector = tmp.df
  ))
}
#line 1 "/private/var/folders/x1/bc7ln59d11jddyfmvq0f4mwm0000gn/T/RtmpK8STdo/R.INSTALL582a7c381cc/RSDA/R/optim.pca.distance.j.r"
#' optim.desv.fun.interval
#' @keywords internal
optim.pca.distance.j <- function(sym.data) {
  N <- sym.data$N
  M <- sym.data$M
  seq.min <- seq(from = 1, by = 2, length.out = M)
  seq.max <- seq(from = 2, by = 2, length.out = M)

  sym.var.names <- sym.data$sym.var.names
  sym.data.vertex <- vertex.interval.new.j(sym.data)
  sym.data.vertex.matrix <- sym.data.vertex$vertex
  dim.vertex <- dim(sym.data.vertex.matrix)[1]
  tot.individuals <- N + dim.vertex

  min.interval <- as.vector(as.matrix(sym.data$data[, seq.min]))
  max.interval <- as.vector(as.matrix(sym.data$data[, seq.max]))
  init.point <- as.vector(as.matrix(centers.interval.j(sym.data)$centers))

  res.min <- lbfgs(init.point, pca.supplementary.vertex.fun.j,
    lower = min.interval,
    upper = max.interval, nl.info = FALSE, control = list(xtol_rel = 1e-08, maxeval = 20000),
    N = N, M = M, sym.var.names = sym.var.names, sym.data.vertex.matrix = sym.data.vertex.matrix,
    tot.individuals = tot.individuals
  )

  M.x <- matrix(res.min$par, nrow = N)
  colnames(M.x) <- sym.var.names
  M.x <- scale(M.x)
  mean.var <- attr(M.x, "scaled:center")
  desv.var <- attr(M.x, "scaled:scale")
  sym.data.vertex.matrix.cent <- sym.data.vertex.matrix

  for (i in 1:M) {
    sym.data.vertex.matrix.cent[, i] <- (sym.data.vertex.matrix.cent[, i] - mean.var[i]) / desv.var[i]
  }
  M.x <- rbind(M.x, sym.data.vertex.matrix.cent)
  pca.min <- PCA(
    X = M.x, scale.unit = FALSE, ind.sup = (N + 1):tot.individuals,
    ncp = M, graph = FALSE
  )

  pca.min.sym <- sym.interval.pca.limits.new.j(sym.data, pca.min$ind.sup$coord, sym.data.vertex$num.vertex)

  return(list(Sym.Components = pca.min.sym, pca.min = pca.min, res.min = res.min))
}
#line 1 "/private/var/folders/x1/bc7ln59d11jddyfmvq0f4mwm0000gn/T/RtmpK8STdo/R.INSTALL582a7c381cc/RSDA/R/optim.pca.variance.j.r"
#' optim.pca.variance.j
#' @keywords internal
optim.pca.variance.j <- function(sym.data, num.dimension) {
  N <- sym.data$N
  M <- sym.data$M
  num.dimen.aux <- num.dimension
  seq.min <- seq(from = 1, by = 2, length.out = M)
  seq.max <- seq(from = 2, by = 2, length.out = M)

  sym.var.names <- sym.data$sym.var.names
  sym.data.vertex <- vertex.interval.new.j(sym.data)
  sym.data.vertex.matrix <- sym.data.vertex$vertex
  dim.vertex <- dim(sym.data.vertex.matrix)[1]
  tot.individuals <- N + dim.vertex

  min.interval <- as.vector(as.matrix(sym.data$data[, seq.min]))
  max.interval <- as.vector(as.matrix(sym.data$data[, seq.max]))

  res.min <- lbfgs(min.interval, pca.supplementary.vertex.lambda.fun.j,
    lower = min.interval,
    upper = max.interval, nl.info = FALSE, control = list(xtol_rel = 1e-08, maxeval = 20000),
    N = N, M = M, sym.var.names = sym.var.names, sym.data.vertex.matrix = sym.data.vertex.matrix,
    tot.individuals = tot.individuals, num.dimen.aux = num.dimen.aux
  )

  M.x <- matrix(res.min$par, nrow = N)
  colnames(M.x) <- sym.var.names
  M.x <- scale(M.x)
  mean.var <- attr(M.x, "scaled:center")
  desv.var <- attr(M.x, "scaled:scale")
  sym.data.vertex.matrix.cent <- sym.data.vertex.matrix

  for (i in 1:M) {
    sym.data.vertex.matrix.cent[, i] <- (sym.data.vertex.matrix.cent[, i] - mean.var[i]) / desv.var[i]
  }
  M.x <- rbind(M.x, sym.data.vertex.matrix.cent)
  pca.max <- PCA(
    X = M.x, scale.unit = FALSE, ind.sup = (N + 1):tot.individuals,
    ncp = M, graph = FALSE
  )

  pca.min.sym <- sym.interval.pca.limits.new.j(sym.data, pca.max$ind.sup$coord, sym.data.vertex$num.vertex)

  return(list(Sym.Components = pca.min.sym, pca.min = pca.max, res.max = res.min))
}
#line 1 "/private/var/folders/x1/bc7ln59d11jddyfmvq0f4mwm0000gn/T/RtmpK8STdo/R.INSTALL582a7c381cc/RSDA/R/pca.supplementary.vertex.fun.j.r"
pca.supplementary.vertex.fun.j <- function(x, N, M, sym.var.names, sym.data.vertex.matrix,
                                           tot.individuals) {
  M.x <- matrix(x, nrow = N)
  colnames(M.x) <- sym.var.names
  M.x <- scale(M.x)
  mean.var <- attr(M.x, "scaled:center")
  desv.var <- attr(M.x, "scaled:scale")
  sym.data.vertex.matrix.cent <- sym.data.vertex.matrix
  for (i in 1:M) {
    sym.data.vertex.matrix.cent[, i] <- (sym.data.vertex.matrix.cent[, i] - mean.var[i]) / desv.var[i]
  }

  M.x <- rbind(M.x, sym.data.vertex.matrix.cent)

  pca.min <- PCA(
    X = M.x, scale.unit = FALSE, ind.sup = (N + 1):tot.individuals,
    ncp = M, graph = FALSE
  )

  min.dist.pca <- pca.min$ind.sup$dist * pca.min$ind.sup$dist
  return(sum(min.dist.pca))
}
#line 1 "/private/var/folders/x1/bc7ln59d11jddyfmvq0f4mwm0000gn/T/RtmpK8STdo/R.INSTALL582a7c381cc/RSDA/R/pca.supplementary.vertex.lambda.fun.j.r"
#' pca.supplementary.vertex.lambda.fun.j
#' @keywords internal
pca.supplementary.vertex.lambda.fun.j <- function(x, M, N, sym.var.names, sym.data.vertex.matrix,
                                                  tot.individuals, num.dimen.aux) {
  M.x <- matrix(x, nrow = N)
  colnames(M.x) <- sym.var.names

  M.x <- scale(M.x)
  mean.var <- attr(M.x, "scaled:center")
  desv.var <- attr(M.x, "scaled:scale")

  sym.data.vertex.matrix.cent <- sym.data.vertex.matrix

  for (i in 1:M) {
    sym.data.vertex.matrix.cent[, i] <- (sym.data.vertex.matrix.cent[, i] - mean.var[i]) / desv.var[i]
  }

  M.x <- rbind(M.x, sym.data.vertex.matrix.cent)

  pca.max <- PCA(
    X = M.x, scale.unit = FALSE, ind.sup = (N + 1):tot.individuals,
    ncp = M, graph = FALSE
  )
  out <- list(pca.max = pca.max, out = -sum(pca.max$eig[(1:num.dimen.aux)]))

  return(-sum(pca.max$eig[(1:num.dimen.aux)]))
}
#line 1 "/private/var/folders/x1/bc7ln59d11jddyfmvq0f4mwm0000gn/T/RtmpK8STdo/R.INSTALL582a7c381cc/RSDA/R/plot.sym.data.table.R"
#' Function for plotting a symbolic object
#'
#' @author Andres Navarro
#' @param x The symbolic object.
#' @param col A specification for the default plotting color.
#' @param matrix.form A vector of the form c(num.rows,num.columns).
#' @param border A logical value indicating whether border should be plotted.
#' @param size The magnification to be used for each graphic.
#' @param title A logical value indicating whether title should be plotted.
#' @param show.type A logical value indicating whether type should be plotted.
#' @param font.size The font size of graphics.
#' @param hist.angle.x The angle of labels in y axis. Only for histogram plot
#' @param reduce A logical value indicating whether values different from zero should be plotted in modal and set graphics.
#' @param ... Arguments to be passed to methods.
#'
#' @return A plot of the symbolic data table.
#' @keywords Plot Symbolic data table
#' @export
#' @exportMethod
#' @examples
#' \dontrun{
#' data(oils)
#' plot(oils)
#' plot(oils,border = T,size = 1.3)
#' }
plot.sym.data.table <- function(x, col = NA, matrix.form = NA, border = FALSE, size = 1,
                                title = TRUE, show.type = FALSE, font.size = 1, reduce = FALSE, hist.angle.x = 60, ...) {
  if (!("sym.data.table" %in% class(x))) { # El tipo de dato es el incorrecto
    stop("The data type is wrong, only sym.data.table are accepted")
  }

  if (any(is.na(col))) { # No se ingresaron colores
    col <- distinctColorPalette(max(x$sym.var.length))
  }  # Cantidad de colores correspondiente a la cantidad maxima de variables

  title <- !(x$N > 1 && x$M == 1) # si filas > 1 y columnas == 1 tenemos que recorrer en una columna y no mostrar titulo


  if (any(!is.na(matrix.form))) { # Si se tiene matrix.form
    if (!is.vector(matrix.form) || length(matrix.form) != 2) {
      stop("Wrong format on matrix.form")
    }
    if (prod(matrix.form) < x$M * x$N) { # El numero de espacios tiene que ser igual o superior al de variables
      stop("Wrong dimensions on matrix.form")
    }
  } else { # Si no hay matriz se crea una, segun la orientacion de la fila
    matrix.form <- c(x$N, x$M)
  }

  size.factor <- ifelse(is.numeric(size), 1.74 * (1 / size), 1.74) # Determina un tamao por defecto de los graficos (proporcion agregada)

  # Guarda la configuracion de par original
  def.par <- par(no.readonly = T)
  # Cambia la configuracion de los graficos
  par(mfrow = matrix.form)
  par(mar = c(0, 0, 1, 0))
  par(pin = (par()$din / (rep(max(matrix.form), 2) * size.factor)))
  # par(cex.axis = 0.7 * font.size)
  par(cex = 0.7 * font.size)

  # Grafica las variables
  for (index.row in 1:x$N) {
    for (index.col in 1:x$M) {
      var.data <- x[index.row, index.col]
      switch(var.data$sym.var.types,
        "$I" = sym.interval.plot(var.data, col, border, show.type),
        "$C" = sym.continuos.plot(var.data, col, border, show.type),
        "$H" = sym.hist.plot(var.data, col, border, show.type, hist.angle.x),
        "$M" = sym.modal.plot(var.data, col, border, show.type, reduce),
        "$S" = sym.set.plot(var.data, col, border, show.type, reduce)
      )
    }
  }

  # Pone el titulo
  if (title) {
    mtext(toupper(x$sym.obj.names), outer = TRUE, cex = 1.5, side = 3)
  }

  tryCatch(expr = {
    par(def.par) # retorna al estado original
  }, error = function(err) {
    suppressMessages(grDevices::dev.off())
    message("The size of the device is too small or the \"size\" parameter needs to be adjusted.")
  }, warning = function(war) {
    message(paste0("ImputeValues: ", war))
  })
}
#line 1 "/private/var/folders/x1/bc7ln59d11jddyfmvq0f4mwm0000gn/T/RtmpK8STdo/R.INSTALL582a7c381cc/RSDA/R/plotX.slice.R"
#' plotX.slice
#' @keywords internal
#' @import graphics
plotX.slice <- function(xx1, yy1, xx2, yy2, vv, vvars, kk) {
  radio <- sqrt(xx1^2 + yy1^2)
  a <- xx1
  b <- yy1
  cx1 <- 0
  cy1 <- 0
  if (radio <= 1) {
    cx1 <- xx1
    cy1 <- yy1
    if (xx1 > 0) {
      text(xx1 + 0.15, yy1, vvars[kk], col = vv[kk])
    } else {
      text(xx1 - 0.15, yy1, vvars[kk], col = vv[kk])
    }
  } else {
    na <- -(a / sqrt(a^2 + b^2))
    nb <- -(b / sqrt(a^2 + b^2))
    sig1 <- a * na
    sig2 <- b * nb
    if ((sig1 < 0) & (sig2 < 0)) {
      na <- -na
      nb <- -nb
    }
    cx1 <- na
    cy1 <- nb
    if (na > 0) {
      text(na + 0.15, nb, vvars[kk], col = vv[kk])
    } else {
      text(na - 0.15, nb, vvars[kk], col = vv[kk])
    }
  }
  radio <- sqrt(xx2^2 + yy2^2)
  a <- xx2
  b <- yy2
  cx2 <- 0
  cy2 <- 0
  if (radio <= 1) {
    cx2 <- xx2
    cy2 <- yy2
  } else {
    na <- -(a / sqrt(a^2 + b^2))
    nb <- -(b / sqrt(a^2 + b^2))
    sig1 <- a * na
    sig2 <- b * nb
    if ((sig1 < 0) & (sig2 < 0)) {
      na <- -na
      nb <- -nb
    }
    cx2 <- na
    cy2 <- nb
  }
  fxx <- c(0, cx1, cx2, 0)
  fyy <- c(0, cy1, cy2, 0)
  polygon(fxx, fyy, col = vv[kk], border = vv[kk])
}
#line 1 "/private/var/folders/x1/bc7ln59d11jddyfmvq0f4mwm0000gn/T/RtmpK8STdo/R.INSTALL582a7c381cc/RSDA/R/predictsym.glm.R"
#' Predict method to Lasso, Ridge and and Elastic Net Linear regression model
#' to interval variables
#' @name predictsym.glm
#' @aliases predictsym.glm
#' @author Oldemar Rodriguez Rojas
#' @description To execute Predict method to Lasso, Ridge and and Elastic Net Linear
#' regression model to interval variables.
#' @usage predictsym.glm(model, new.sym.data, response = 1, method = c('cm', 'crm'))
#' @param model The output of glm method.
#' @param new.sym.data Should be a symbolic data table read with the function read.sym.table(...).
#' @param response The number of the column where is the response variable in the interval data table.
#' @param method 'cm' to generalized Center Method and 'crm' to generalized Center and Range Method.
#'
#' @return The object returned depends the ... argument which is passed on to the predict
#' method for glmnet objects.
#' @references Rodriguez O. (2013). A generalization of Centre and Range method for fitting a linear
#' regression model to symbolic interval data using Ridge Regression, Lasso
#' and Elastic Net methods. The IFCS2013 conference of the International Federation of
#' Classification Societies, Tilburg University Holland.
#' @seealso sym.glm
#' @examples
#' data(int_prost_train)
#' data(int_prost_test)
#' res.cm.lasso<-sym.glm(sym.data=int_prost_train,response=9,method='cm',
#'                       alpha=1,nfolds=10,grouped=TRUE)
#' pred.cm.lasso<-predictsym.glm(res.cm.lasso,response=9,int_prost_test,method='cm')
#' plot(res.cm.lasso)
#' plot(res.cm.lasso$glmnet.fit, 'norm', label=TRUE)
#' plot(res.cm.lasso$glmnet.fit, 'lambda', label=TRUE)
#' RMSE.L(sym.var(int_prost_test,9),pred.cm.lasso)
#' RMSE.U(sym.var(int_prost_test,9),pred.cm.lasso)
#' R2.L(sym.var(int_prost_test,9),pred.cm.lasso)
#' R2.U(sym.var(int_prost_test,9),pred.cm.lasso)
#' deter.coefficient(sym.var(int_prost_test,9),pred.cm.lasso)
#'
#' @keywords Symbolic Regression Lasso Ridge
#' @import stats glmnet
#'
predictsym.glm <- function(model, new.sym.data, response = 1, method = c("cm", "crm")) {
  idn <- all(new.sym.data$sym.var.types == new.sym.data$sym.var.types[1])
  if (idn == FALSE) {
    stop("All variables have to be of the same type")
  }
  method <- match.arg(method)
  nn <- new.sym.data$N
  mm <- new.sym.data$M
  if (method == "cm") {
    mins <- matrix(0, nn, mm)
    maxs <- matrix(0, nn, mm)
    for (i in 1:nn) {
      for (j in 1:mm) {
        mins[i, j] <- sym.var(new.sym.data, j)$var.data.vector[i, 1]
        maxs[i, j] <- sym.var(new.sym.data, j)$var.data.vector[i, 2]
      }
    }
    pred.mins <- predict(model, newx = mins[, -response], s = "lambda.min")
    pred.maxs <- predict(model, newx = maxs[, -response], s = "lambda.min")
    Prediction <- data.frame(Minimums = pred.mins, Maximums = pred.maxs)
    return(Prediction)
  }
  if (method == "crm") {
    # Center Model
    centers <- matrix(0, nn, mm)
    for (i in 1:nn) for (j in 1:mm) centers[i, j] <- (sym.var(new.sym.data, j)$var.data.vector[
          i,
          1
        ] + sym.var(new.sym.data, j)$var.data.vector[i, 2]) / 2
    predc <- predict(model$CenterModel, newx = centers[, -response], s = "lambda.min")
    # Range Model
    range <- matrix(0, nn, mm)
    for (i in 1:nn) for (j in 1:mm) range[i, j] <- (sym.var(new.sym.data, j)$var.data.vector[
          i,
          2
        ] - sym.var(new.sym.data, j)$var.data.vector[i, 1]) / 2
    predr <- predict(model$RangeModel, newx = range[, -response], s = "lambda.min")
    res.min <- predc - predr
    res.max <- predc + predr
    Prediction <- data.frame(Minimums = res.min, Maximums = res.max)
    return(Prediction)
  }
}
#line 1 "/private/var/folders/x1/bc7ln59d11jddyfmvq0f4mwm0000gn/T/RtmpK8STdo/R.INSTALL582a7c381cc/RSDA/R/predictsym.lm.R"
#' Predict method to CM and CRM Linear regression model
#' @name predictsym.lm
#' @aliases predictsym.lm
#' @author Oldemar Rodriguez Rojas
#' @description To execute predict method the Center Method (CR) and Center and Range Method (CRM) to
#' Linear regression.
#' @usage predictsym.lm(model, new.sym.data, method = c('cm', 'crm'))
#' @param model The output of lm method.
#' @param new.sym.data Should be a symbolic data table read with the function read.sym.table(...).
#' @param method 'cm' to Center Method and 'crm' to Center and Range Method.
#'
#' @return predictsym.lm produces a vector of predictions or a matrix of predictions and bounds
#' with column names fit, lwr, and upr if interval is set. For type = 'terms' this is a
#' matrix with a column per term and may have an attribute 'constant'
#' @references
#' LIMA-NETO, E.A., DE CARVALHO, F.A.T., (2008). Centre and range method
#' to fitting a linear regression model on symbolic interval data. Computational
#' Statistics and Data Analysis 52, 1500-1515.
#'
#' LIMA-NETO, E.A., DE CARVALHO, F.A.T., (2010). Constrained linear regression models
#' for symbolic interval-valued variables. Computational Statistics and
#' Data Analysis 54, 333-347.
#'
#' @seealso sym.glm
#' @examples
#' data(int_prost_train)
#' data(int_prost_test)
#' res.cm <- sym.lm(lpsa~.,sym.data=int_prost_train,method='cm')
#' pred.cm <- predictsym.lm(res.cm,int_prost_test,method='cm')
#'
#' @keywords Symbolic lm
#' @export
#' @import stats
#'
predictsym.lm <- function(model, new.sym.data, method = c("cm", "crm")) {
  idn <- all(new.sym.data$sym.var.types == new.sym.data$sym.var.types[1])
  if (idn == FALSE) {
    stop("All variables have to be of the same type")
  }
  method <- match.arg(method)
  nn <- new.sym.data$N
  mm <- new.sym.data$M
  if (method == "cm") {
    mins <- matrix(0, nn, mm)
    maxs <- matrix(0, nn, mm)
    for (i in 1:nn) for (j in 1:mm) {
        mins[i, j] <- sym.var(new.sym.data, j)$var.data.vector[i, 1]
        maxs[i, j] <- sym.var(new.sym.data, j)$var.data.vector[i, 2]
      }
    mins <- as.data.frame(mins)
    colnames(mins) <- new.sym.data$sym.var.names
    maxs <- as.data.frame(maxs)
    colnames(maxs) <- new.sym.data$sym.var.names
    pred.mins <- predict(model, newdata = mins, se.fit = TRUE)
    pred.maxs <- predict(model, newdata = maxs, se.fit = TRUE)
    Prediction <- data.frame(Minimums = pred.mins$fit, Maximums = pred.maxs$fit)
    return(list(MinPrediction = pred.mins, MaxPredictions = pred.maxs, Fitted = Prediction))
  }
  if (method == "crm") {
    # Center Model
    centers <- matrix(0, nn, mm)
    for (i in 1:nn) for (j in 1:mm) centers[i, j] <- (sym.var(new.sym.data, j)$var.data.vector[
          i,
          1
        ] + sym.var(new.sym.data, j)$var.data.vector[i, 2]) / 2
    centers <- as.data.frame(centers)
    colnames(centers) <- new.sym.data$sym.var.names
    predc <- predict(model$CenterModel, newdata = centers, se.fit = TRUE)
    # Range Model
    range <- matrix(0, nn, mm)
    for (i in 1:nn) for (j in 1:mm) range[i, j] <- (sym.var(new.sym.data, j)$var.data.vector[
          i,
          2
        ] - sym.var(new.sym.data, j)$var.data.vector[i, 1]) / 2
    range <- as.data.frame(range)
    colnames(range) <- new.sym.data$sym.var.names
    predr <- predict(model$RangeModel, newdata = range, se.fit = TRUE)
    res.min <- predc$fit - predr$fit
    res.max <- predc$fit + predr$fit
    Prediction <- data.frame(Minimums = res.min, Maximums = res.max)
    return(list(CenterPrediction = predc, RangePrediction = predr, Fitted = Prediction))
  }
}
#line 1 "/private/var/folders/x1/bc7ln59d11jddyfmvq0f4mwm0000gn/T/RtmpK8STdo/R.INSTALL582a7c381cc/RSDA/R/principal.axis.i.j.r"
#' principal.axis.i
#' @keywords internal
principal.axis.i <- function(rotation.matrix, comp.i, eje.x, eje.y) {
  pos <- c(eje.x, eje.y)
  x1 <- rotation.matrix[pos, comp.i]
  b <- x1[2] / x1[1]
  a <- 0
  return(data.frame(a = a, b = b))
}
#line 1 "/private/var/folders/x1/bc7ln59d11jddyfmvq0f4mwm0000gn/T/RtmpK8STdo/R.INSTALL582a7c381cc/RSDA/R/process.continue.variable.R"
#' process.continue.variable
#' @keywords internal
#' @importFrom XML xmlValue
process.continue.variable <- function(number.of.rows, parsed.xml, variable.index, variable.name) {
  aux <- list()
  aux[[1]] <- rep("$C", number.of.rows)

  after.evaluator <- function(node) {
    if (length(node["val_conti"]) == 0) {
      return(NA)
    } else {
      return(as.numeric(xmlValue(node[[1]])))
    }
  }

  aux[[2]] <- xpathSApply(parsed.xml, paste0(
    "/assofile/indiv_mat/ligmat/valmat[",
    variable.index, "]"
  ), after.evaluator)

  aux <- data.frame(aux)
  colnames(aux) <- c("$C", variable.name)
  return(aux)
}
#line 1 "/private/var/folders/x1/bc7ln59d11jddyfmvq0f4mwm0000gn/T/RtmpK8STdo/R.INSTALL582a7c381cc/RSDA/R/process.continuum.variable.R"
#' process.continuum.variable
#' @keywords internal
process.continuum.variable <- function(variableName, conceptColumns) {
  varType <- "$C"
  return(sqldf(paste0(
    "SELECT '", varType, "', round(AVG(", variableName, "), 2) AS ",
    variableName, " FROM main.dataTable GROUP BY ", conceptColumns, " ORDER BY ",
    conceptColumns
  )))
}
#line 1 "/private/var/folders/x1/bc7ln59d11jddyfmvq0f4mwm0000gn/T/RtmpK8STdo/R.INSTALL582a7c381cc/RSDA/R/process.histogram.variable.R"
#' process.histogram.variable
#' @import dplyr tidyr stringr lazyeval
#' @keywords internal
process.histogram.variable <- function(variableName, concept, dataTable, n) {
  as_quosure <- function(strs) rlang::parse_quosures(paste(strs, collapse = ";"))
  concept. <- stringr::str_replace_all(concept, "[\\[\\]]", "")
  variable.name. <- stringr::str_replace_all(variableName, "[\\[\\]]", "")
  n.breaks <- n
  n.breaks[is.na(n.breaks)] <- 5
  breaks. <- hist(dataTable[, variable.name.], plot = F, right = F, breaks = n.breaks)$breaks
  cal.prop <- rlang::quo(calculate.probs(x = .[[!!variable.name.]], breaks. = !!breaks.))

  data. <- dataTable %>% dplyr::group_by(!!!as_quosure(concept.)) %>% dplyr::do(!!cal.prop)

  data. <- data. %>%
    tidyr::unite("interval", .data$to, .data$from, sep = ",") %>%
    dplyr::mutate(interval = c(paste0("[", head(.data$interval, n() - 1), ")"), .data$interval[n()])) %>%
    dplyr::mutate(interval = c(.data$interval[1:(n() - 1)], paste0("[", .data$interval[n()], "]")))

  order. <- unique(data.$interval)
  data. <- data. %>% tidyr::spread(interval, prob, fill = 0, convert = F)
  data. <- data.[, -1]
  data. <- data.[, order.]

  type <- data.frame(`$H` = rep("$H", nrow(data.)), check.names = F)
  type.length <- data.frame(rep(ncol(data.), nrow(data.)), check.names = F)
  colnames(type.length) <- variable.name.
  data. <- cbind(type, type.length, data.)
  return(data.)
}
#line 1 "/private/var/folders/x1/bc7ln59d11jddyfmvq0f4mwm0000gn/T/RtmpK8STdo/R.INSTALL582a7c381cc/RSDA/R/process.inter.cont.variable.R"
#' process.inter.cont.variable
#' @keywords internal
#' @importFrom XML xmlValue xmlElementsByTagName
process.inter.cont.variable <- function(number.of.rows, parsed.xml, variable.index,
                                        variable.name) {
  aux <- list()
  aux[[1]] <- rep("$I", number.of.rows)

  after.evaluator <- function(node, element.to.retrieve) {
    if (length(node["val_interv"]) == 0) {
      return(NA)
    } else {
      return(as.numeric(xmlValue(xmlElementsByTagName(node[[1]], element.to.retrieve)[[1]])))
    }
  }

  nodes <- getNodeSet(parsed.xml, paste0(
    "/assofile/indiv_mat/ligmat/valmat[", variable.index,
    "]"
  ))
  aux[[2]] <- sapply(nodes, after.evaluator, element.to.retrieve = "pmin")
  aux[[3]] <- sapply(nodes, after.evaluator, element.to.retrieve = "pmax")

  aux <- data.frame(aux)
  colnames(aux) <- c("$I", variable.name, variable.name)
  return(aux)
}
#line 1 "/private/var/folders/x1/bc7ln59d11jddyfmvq0f4mwm0000gn/T/RtmpK8STdo/R.INSTALL582a7c381cc/RSDA/R/process.interval.variable.R"
#' process.interval.variable
#' @keywords internal
process.interval.variable <- function(variableName, conceptColumns) {
  varType <- "$I"
  return(sqldf(paste0(
    "SELECT '", varType, "', MIN(", variableName, ") AS ", variableName,
    ", MAX(", variableName, ") AS ", variableName, " FROM main.dataTable GROUP BY ",
    conceptColumns, " ORDER BY ", conceptColumns
  )))
}
#line 1 "/private/var/folders/x1/bc7ln59d11jddyfmvq0f4mwm0000gn/T/RtmpK8STdo/R.INSTALL582a7c381cc/RSDA/R/process.modal.variable.R"
#' process.modal.variable
#' @keywords internal
process.modal.variable <- function(variableName, concept, sym.obj.names) {
  suppressWarnings(sqldf(paste0(
    "CREATE INDEX IF NOT EXISTS main.", variableName,
    " ON dataTable (", variableName, ")"
  )))

  conceptColumns <- paste(concept, collapse = ", ")
  conceptConcatenation <- paste(concept, collapse = "||'.'||")
  categories <- sqldf(paste0(
    "SELECT DISTINCT ", variableName, " FROM main.dataTable ORDER BY ",
    variableName
  ))[[1]]

  result <- data.frame(rep("$M", length(sym.obj.names)), length(categories), check.names = F)
  colnames(result) <- c("$M", substr(variableName, 2, nchar(variableName) - 1))

  for (i in seq(from = 1, to = length(categories), by = 32)) {
    if (length(categories) - i + 1 >= 32) {
      categoryGroup <- categories[i:(i + 31)]
    } else {
      categoryGroup <- categories[i:length(categories)]
    }

    queries <- character()
    for (category in categoryGroup) {
      queries <- c(queries, paste0(
        "(SELECT SymObjNames, ifnull(freq, 0) AS '",
        category, "' FROM (SELECT SymObjNames FROM main.symObjTable) LEFT JOIN (SELECT ",
        conceptConcatenation, " AS concept, COUNT(", variableName, ") AS freq FROM main.dataTable WHERE ",
        variableName, " = '", category, "' GROUP BY ", conceptColumns, ") ON concept = SymObjNames)"
      ))
    }
    queries <- paste(queries, collapse = " NATURAL JOIN ")
    result <- cbind(result, sqldf(paste0("SELECT * FROM ", queries))[-1])
  }

  totalFrequency <- sqldf(paste0(
    "SELECT COUNT(", variableName, ") FROM main.dataTable GROUP BY ",
    conceptColumns, " ORDER BY ", conceptColumns
  ))[[1]]

  for (j in 1:length(categories)) {
    result[j + 2] <- round(result[[j + 2]] / totalFrequency, 3)
  }

  return(result)
}
#line 1 "/private/var/folders/x1/bc7ln59d11jddyfmvq0f4mwm0000gn/T/RtmpK8STdo/R.INSTALL582a7c381cc/RSDA/R/process.mult.nominal.modif.variable.R"
#' process.mult.nominal.modif.variable
#' @keywords internal
#' @importFrom XML xmlSApply
process.mult.nominal.modif.variable <- function(labels, number.of.rows, parsed.xml,
                                                variable.index, variable.name) {
  aux <- list()
  aux[[1]] <- rep("$H", number.of.rows)
  if (labels) {
    categories <- xpathSApply(parsed.xml, paste0(
      "/assofile/variables/stvar[",
      variable.index, "]/mult_nominal_Modif/nominal-desc/list-nom/label"
    ), xmlValue)
  } else {
    categories <- xpathSApply(parsed.xml, paste0(
      "/assofile/variables/stvar[",
      variable.index, "]/mult_nominal_Modif/nominal-desc/list-nom/name"
    ), xmlValue)
  }
  aux[[2]] <- rep(length(categories), number.of.rows)

  nodes <- getNodeSet(parsed.xml, paste0(
    "/assofile/indiv_mat/ligmat/valmat[", variable.index,
    "]"
  ))

  get.distributions <- function(node) {
    if (length(node["val_list_modal"]) == 0) {
      return(rep(NA, length(categories)))
    } else {
      moda.nodes <- as.numeric(sapply(
        xmlSApply(node, function(x) x["no_moda"]),
        xmlValue
      ))
      frequencies <- as.numeric(sapply(
        xmlSApply(node, function(x) x["frequency"]),
        xmlValue
      ))
      missing.categories.indexes <- setdiff(1:length(categories), moda.nodes)
      for (missing.cat.index in missing.categories.indexes) {
        frequencies <- append(frequencies, 0, after = missing.cat.index - 1)
      }
      return(frequencies)
    }
  }

  all.frequencies <- t(round(sapply(nodes, get.distributions), 3))
  aux <- data.frame(c(aux, as.data.frame(all.frequencies)))

  colnames(aux) <- c("$H", variable.name, categories)
  return(aux)
}
#line 1 "/private/var/folders/x1/bc7ln59d11jddyfmvq0f4mwm0000gn/T/RtmpK8STdo/R.INSTALL582a7c381cc/RSDA/R/process.mult.nominal.variable.R"
#' process.mult.nominal.variable
#' @keywords internal
#' @importFrom XML xmlSApply
process.mult.nominal.variable <- function(labels, number.of.rows, parsed.xml, variable.index,
                                          variable.name) {
  aux <- list()
  aux[[1]] <- rep("$S", number.of.rows)
  if (labels) {
    categories <- xpathSApply(parsed.xml, paste0(
      "/assofile/variables/stvar[",
      variable.index, "]/mult_nominal/nominal-desc/list-nom/label"
    ), xmlValue)
  } else {
    categories <- xpathSApply(parsed.xml, paste0(
      "/assofile/variables/stvar[",
      variable.index, "]/mult_nominal/nominal-desc/list-nom/name"
    ), xmlValue)
  }

  aux[[2]] <- rep(length(categories), number.of.rows)
  nodes <- getNodeSet(parsed.xml, paste0(
    "/assofile/indiv_mat/ligmat/valmat[", variable.index,
    "]"
  ))

  after.evaluator <- function(node) {
    if (length(node["val_modal"]) == 0) {
      return(NA)
    } else {
      present.mods <- as.numeric(xmlSApply(node, xmlValue))
      modals.vector <- rep(0, length(categories) - length(present.mods))
      for (present.mod in present.mods) {
        modals.vector <- append(modals.vector, 1, present.mod - 1)
      }
      return(modals.vector)
    }
  }
  node.categories <- t(xmlSApply(nodes, after.evaluator))

  aux <- data.frame(c(aux, as.data.frame(node.categories)))
  colnames(aux) <- c("$S", variable.name, categories)
  return(aux)
}
#line 1 "/private/var/folders/x1/bc7ln59d11jddyfmvq0f4mwm0000gn/T/RtmpK8STdo/R.INSTALL582a7c381cc/RSDA/R/process.nominal.variable.R"
#' process.nominal.variable
#' @keywords internal
process.nominal.variable <- function(labels, number.of.rows, parsed.xml, variable.index,
                                     variable.name) {
  aux <- list()
  aux[[1]] <- rep("$S", number.of.rows)
  if (labels) {
    categories <- xpathSApply(parsed.xml, paste0(
      "/assofile/variables/stvar[",
      variable.index, "]/nominal/nominal-desc/list-nom/label"
    ), xmlValue)
  } else {
    categories <- xpathSApply(parsed.xml, paste0(
      "/assofile/variables/stvar[",
      variable.index, "]/nominal/nominal-desc/list-nom/name"
    ), xmlValue)
  }

  aux[[2]] <- rep(length(categories), number.of.rows)
  nodes <- getNodeSet(parsed.xml, paste0(
    "/assofile/indiv_mat/ligmat/valmat[", variable.index,
    "]"
  ))

  after.evaluator <- function(node) {
    if (length(node["val_nomina"]) == 0) {
      return(rep(NA, length(categories)))
    } else {
      category <- as.numeric(xmlValue(node))
      return(append(rep(0, length(categories) - 1), 1, category - 1))
    }
  }
  node.categories <- t(xmlSApply(nodes, after.evaluator))

  aux <- data.frame(c(aux, as.data.frame(node.categories)))
  colnames(aux) <- c("$S", variable.name, categories)
  return(aux)
}
#line 1 "/private/var/folders/x1/bc7ln59d11jddyfmvq0f4mwm0000gn/T/RtmpK8STdo/R.INSTALL582a7c381cc/RSDA/R/process.set.variable.R"
#' process.set.variable
#' @keywords internal
process.set.variable <- function(variableName, concept, sym.obj.names) {
  suppressWarnings(sqldf(paste0(
    "CREATE INDEX IF NOT EXISTS main.", variableName,
    " ON dataTable (", variableName, ")"
  )))

  conceptColumns <- paste(concept, collapse = ", ")
  conceptConcatenation <- paste(concept, collapse = "||'.'||")
  categories <- sqldf(paste0(
    "SELECT DISTINCT ", variableName, " FROM main.dataTable ORDER BY ",
    variableName
  ))[[1]]

  result <- data.frame(rep("$S", length(sym.obj.names)), length(categories), check.names = F)
  colnames(result) <- c("$S", substr(variableName, 2, nchar(variableName) - 1))

  for (i in seq(from = 1, to = length(categories), by = 64)) {
    if (length(categories) - i + 1 >= 64) {
      categoryGroup <- categories[i:(i + 63)]
    } else {
      categoryGroup <- categories[i:length(categories)]
    }

    queries <- character()
    for (category in categoryGroup) {
      queries <- c(queries, paste0(
        "(SELECT SymObjNames, SymObjNames IN (SELECT DISTINCT ",
        conceptConcatenation, " FROM main.dataTable WHERE ", variableName,
        " = '", category, "') AS '", category, "' FROM main.symObjTable)"
      ))
    }
    queries <- paste(queries, collapse = " NATURAL JOIN ")
    result <- cbind(result, sqldf(paste0("SELECT * FROM ", queries))[-1])
  }

  return(result)
}
#line 1 "/private/var/folders/x1/bc7ln59d11jddyfmvq0f4mwm0000gn/T/RtmpK8STdo/R.INSTALL582a7c381cc/RSDA/R/read.sym.table.R"
#' Read a Symbolic Table
#' @name read.sym.table
#' @aliases read.sym.table
#' @author Oldemar Rodriguez Rojas
#' @description It reads a symbolic data table from a CSV file.
#' @usage read.sym.table(file, header = TRUE, sep, dec, row.names = NULL)
#' @param file The name of the CSV file.
#' @param header As in R function read.table
#' @param sep As in R function read.table
#' @param dec As in R function read.table
#' @param row.names As in R function read.table
#' @details
#' The labels $C means that follows a continuous variable, $I means an interval variable, $H
#' means a histogram variables and $S means set variable. In the first row each labels should
#' be follow of a name to variable and to the case of histogram a set variables types the names
#' of the modalities (categories) . In data rows for continuous variables we have just one
#' value, for interval variables we have the minimum and the maximum of the interval,
#' for histogram variables we have the number of modalities and then the probability
#' of each modality and for set variables we have the cardinality of the set and next
#' the elements of the set.
#'
#' The format is the CSV file should be like:
#'
#'   $C   F1 $I F2 F2 $H F3  M1  M2  M3 $S F4 E1 E2 E3 E4 \cr
#'
#' Case1 $C  2.8 $I  1  2 $H  3 0.1 0.7 0.2 $S  4  e  g  k  i\cr
#'
#' Case2 $C  1.4 $I  3  9 $H  3 0.6 0.3 0.1 $S  4  a  b  c  d\cr
#'
#' Case3 $C  3.2 $I -1  4 $H  3 0.2 0.2 0.6 $S  4  2  1  b  c\cr
#'
#' Case4 $C -2.1 $I  0  2 $H  3 0.9 0.0 0.1 $S  4  3  4  c  a\cr
#'
#' Case5 $C -3.0 $I -4 -2 $H  3 0.6 0.0 0.4 $S  4  e  i  g  k\cr
#'
#' The internal format is:\cr

#'   $N\cr

#' [1] 5\cr

#' $M\cr

#' [1] 4\cr

#' $sym.obj.names\cr

#' [1] 'Case1' 'Case2' 'Case3' 'Case4' 'Case5'\cr

#' $sym.var.names\cr

#' [1] 'F1' 'F2' 'F3' 'F4'\cr

#' $sym.var.types\cr

#' [1] '$C' '$I' '$H' '$S'\cr

#' $sym.var.length\cr

#' [1] 1 2 3 4\cr

#' $sym.var.starts\cr

#' [1]  2  4  8 13\cr

#' $meta\cr

#' $C   F1 $I F2 F2 $H F3  M1  M2  M3 $S F4 E1 E2 E3 E4\cr

#' Case1 $C  2.8 $I  1  2 $H  3 0.1 0.7 0.2 $S  4  e  g  k  i\cr

#' Case2 $C  1.4 $I  3  9 $H  3 0.6 0.3 0.1 $S  4  a  b  c  d\cr

#' Case3 $C  3.2 $I -1  4 $H  3 0.2 0.2 0.6 $S  4  2  1  b  c\cr

#' Case4 $C -2.1 $I  0  2 $H  3 0.9 0.0 0.1 $S  4  3  4  c  a\cr

#' Case5 $C -3.0 $I -4 -2 $H  3 0.6 0.0 0.4 $S  4  e  i  g  k\cr

#' $data\cr

#' F1 F2 F2.1  M1  M2  M3 E1 E2 E3 E4\cr

#' Case1  2.8  1    2 0.1 0.7 0.2  e  g  k  i\cr

#' Case2  1.4  3    9 0.6 0.3 0.1  a  b  c  d\cr

#' Case3  3.2 -1    4 0.2 0.2 0.6  2  1  b  c\cr

#' Case4 -2.1  0    2 0.9 0.0 0.1  3  4  c  a\cr

#' Case5 -3.0 -4   -2 0.6 0.0 0.4  e  i  g  k\cr
#'
#' @return Return a symbolic data table structure.
#' @references
#' Bock H-H. and Diday E. (eds.) (2000).
#' Analysis of Symbolic Data. Exploratory methods for extracting statistical information
#' from complex data. Springer, Germany.
#' @seealso display.sym.table
#' @examples
#' \dontrun{
#' data(example1)
#' write.sym.table(example1, file='temp4.csv', sep='|',dec='.', row.names=TRUE,
#'                 col.names=TRUE)
#' ex1<-read.sym.table('temp4.csv', header=TRUE, sep='|',dec='.', row.names=1)
#' }
#' @keywords Symbolic Table
#' @export
#' @importFrom utils read.table
#'
read.sym.table <- function(file, header = TRUE, sep, dec, row.names = NULL) {
  meta.data <- read.table(file, header,
    sep = as.character(sep), dec = as.character(dec),
    row.names = c(row.names), check.names = FALSE
  )
  n.sym.objects <- dim(meta.data)[1]
  meta.M <- dim(meta.data)[2]
  sym.var.types <- list()
  sym.var.length <- rep(0, length(meta.M))
  sym.var.names <- list()
  sym.var.starts <- list()
  sym.obj.names <- rownames(meta.data)
  del.columns <- c()
  del.columns.length <- 0
  if (header == TRUE) {
    meta.types <- colnames(meta.data)
  } else {
    stop("Data file have to have a header")
  }
  meta.types.orig <- meta.types
  for (i in 1:length(meta.types)) {
    meta.types[i] <- substr(meta.types[i], start = 1, stop = 2)
  }
  for (j in 1:length(meta.types)) {
    if ((meta.types[j] == "$C") || (meta.types[j] == "$c")) {
      sym.var.types[j] <- "$C"
      sym.var.length[j] <- 1
      sym.var.names[j] <- meta.types.orig[j + 1]
      sym.var.starts[j] <- j + 1
    } else if ((meta.types[j] == "$I") || (meta.types[j] == "$i")) {
      sym.var.types[j] <- "$I"
      sym.var.length[j] <- 2
      sym.var.names[j] <- meta.types.orig[j + 1]
      sym.var.starts[j] <- j + 1
    } else if ((meta.types[j] == "$H") || (meta.types[j] == "$h")) {
      sym.var.types[j] <- "$H"
      sym.var.length[j] <- as.integer(meta.data[2, j + 1])
      del.columns[del.columns.length + 1] <- j + 1
      del.columns.length <- del.columns.length + 1
      sym.var.names[j] <- meta.types.orig[j + 1]
      sym.var.starts[j] <- j + 2
    } else if ((meta.types[j] == "$M") || (meta.types[j] == "$m")) {
      sym.var.types[j] <- "$M"
      sym.var.length[j] <- as.integer(meta.data[2, j + 1])
      del.columns[del.columns.length + 1] <- j + 1
      del.columns.length <- del.columns.length + 1
      sym.var.names[j] <- meta.types.orig[j + 1]
      sym.var.starts[j] <- j + 2
    } else if ((meta.types[j] == "$S") || (meta.types[j] == "$s")) {
      sym.var.types[j] <- "$S"
      sym.var.length[j] <- as.integer(meta.data[2, j + 1])
      del.columns[del.columns.length + 1] <- j + 1
      del.columns.length <- del.columns.length + 1
      sym.var.names[j] <- meta.types.orig[j + 1]
      sym.var.starts[j] <- j + 2
    } else {
      sym.var.types[j] <- "NA"
    }
  }
  del1 <- match(sym.var.types, c("$C", "$I", "$H", "$S", "$M"), 0)
  for (k in 1:del.columns.length) {
    sym.var.types[del.columns[k]] <- "$H"
  }
  del2 <- match(sym.var.types, c("$C", "$I", "$H", "$S", "$M"), 0)
  sym.var.types <- sym.var.types[del1 > 0]
  sym.var.length <- sym.var.length[del1 > 0]
  n.sym.var <- length(sym.var.length)
  data.matrix <- as.data.frame(meta.data[, del2 == 0])
  sym.data <- list(
    N = n.sym.objects, M = n.sym.var, sym.obj.names = sym.obj.names,
    sym.var.names = unlist(sym.var.names), sym.var.types = unlist(sym.var.types),
    sym.var.length = sym.var.length, sym.var.starts = unlist(sym.var.starts), meta = meta.data,
    data = data.matrix
  )

  class(sym.data) <- c("sym.data.table")
  return(sym.data)
}
#line 1 "/private/var/folders/x1/bc7ln59d11jddyfmvq0f4mwm0000gn/T/RtmpK8STdo/R.INSTALL582a7c381cc/RSDA/R/rightarrow.matrix.R"
#' rightarrow.matrix
#' @keywords internal
rightarrow.matrix <- function(sym.data) {
  return(sym.data$data)
}
#line 1 "/private/var/folders/x1/bc7ln59d11jddyfmvq0f4mwm0000gn/T/RtmpK8STdo/R.INSTALL582a7c381cc/RSDA/R/scatter.sym.j.r"
#' sym.scatterplot
#' @keywords internal
sym.scatterplot <- function(sym.var.x, sym.var.y, labels = FALSE, ...) {
  if (((sym.var.x$sym.var.types != "$C") || (sym.var.y$sym.var.types != "$C")) &&
    ((sym.var.x$sym.var.types != "$I") || (sym.var.y$sym.var.types != "$I"))) {
    stop("Impossible to plot this type of variable")
  }
  if ((sym.var.x$sym.var.types == "$C") && (sym.var.y$sym.var.types == "$C")) {
    if (labels == FALSE) {
      plot(sym.var.x$data, sym.var.y$data,
        xlab = sym.var.x$sym.var.names, ylab = sym.var.y$sym.var.names,
        ...
      )
    } else {
      ltext <- sym.var.x$sym.obj.names
      plot(sym.var.x$data, sym.var.y$data,
        type = "n", xlab = sym.var.x$sym.var.names,
        ylab = sym.var.y$sym.var.names, ...
      )
      text(sym.var.x$data, sym.var.y$data, ltext)
    }
  }
  if ((sym.var.x$sym.var.types == "$I") && (sym.var.y$sym.var.types == "$I")) {
    xmin1 <- min(sym.var.x$data[, 1])
    xmin2 <- min(sym.var.x$data[, 2])
    xmin <- min(xmin1, xmin2)
    xmax1 <- max(sym.var.x$data[, 1])
    xmax2 <- max(sym.var.x$data[, 2])
    xmax <- max(xmax1, xmax2)
    ymin1 <- min(sym.var.y$data[, 1])
    ymin2 <- min(sym.var.y$data[, 2])
    ymin <- min(ymin1, ymin2)
    ymax1 <- max(sym.var.y$data[, 1])
    ymax2 <- max(sym.var.y$data[, 2])
    ymax <- max(ymax1, ymax2)
    plot(c(xmin, xmax), c(ymin, ymax),
      type = "n", xlab = sym.var.x$sym.var.names,
      ylab = sym.var.y$sym.var.names, ...
    )
    for (i in 1:sym.var.x$N) {
      x1 <- sym.var.x$data[i, 1]
      y1 <- sym.var.y$data[i, 1]
      x2 <- sym.var.x$data[i, 2]
      y2 <- sym.var.y$data[i, 2]
      rect(x1, y1, x2, y2, lwd = 2, border = i + 1)
    }
    if (labels == TRUE) {
      ltext <- sym.var.x$sym.obj.names
      text(jitter(sym.var.x$data[, 1]), jitter(sym.var.y$data[, 1]), ltext)
    }
  }
}
#line 1 "/private/var/folders/x1/bc7ln59d11jddyfmvq0f4mwm0000gn/T/RtmpK8STdo/R.INSTALL582a7c381cc/RSDA/R/sd.sym.data.table.R"
#' Generic function for the standard desviation
#' @name sd
#' @aliases sd
#' @author Oldemar Rodriguez Rojas
#' @description Compute the symbolic standard desviation.
#' @param x A symbolic variable.
#' @param method The method to be use.
#' @param na.rm As in R sd function.
#' @param ... As in R sd function.
#'
#' @return return a real number.
#' @references Billard L. and  Diday E. (2006).
#' Symbolic data analysis: Conceptual statistics and data mining. Wiley, Chichester.
#'
#' Rodriguez, O. (2000).
#' Classification et Modeles Lineaires en Analyse des Donnees Symboliques. Ph.D. Thesis,
#' Paris IX-Dauphine University.
#'
#' @examples
#' data(example3)
#' sym.data<-example3
#' sd(sym.data[,1])
#' sd(sym.data[,2])
#' sd(sym.data[,6])
#' sd(sym.data[,6], method='interval')
#' sd(sym.data[,6], method='billard')
#' sd(sym.data[,3],method='modal')
#' @keywords Symbolic sd
#' @export
#'
sd <- function(x, ...) {
  UseMethod("sd", x)
}

#' @rdname sd
#' @export
sd.default <- function(x, na.rm = FALSE, ...) {
  stats::sd(x, na.rm)
}


#' @rdname sd
#' @export
sd.sym.data.table <- function(x, method = c("centers", "interval", "billard", "modal"),
                              na.rm = FALSE, ...) {
  method <- match.arg(method)
  if (method == "centers") {
    if (x$sym.var.types == "$C") {
      return(sd(x$data[, 1]))
    }
    if (x$sym.var.types == "$I") {
      return(sd(x$data[, 1] + x$data[, 2]) / 2)
    } else {
      stop("Impossible to compute the Standard Deviation for this type of variable with this method")
    }
  }
  if (method == "interval") {
    if (x$sym.var.types == "$I") {
      return(sapply(x$data, sd))
    } else {
      stop("Impossible to compute the Standard Deviation for this type of variable with this method")
    }
  }
  if (method == "billard") {
    if (x$sym.var.types == "$I") {
      return(sqrt((1 / (3 * x$N)) * sum(x$data[, 1]^2 + (x$data[, 1] * x$data[
        ,
        2
      ]) + x$data[, 2]^2) - (1 / (4 * (x$N)^2)) * sum(x$data[, 1] + x$data[
        ,
        2
      ])^2))
    } else {
      stop("Impossible to compute the Standard Deviation for this type of variable with this method")
    }
  }
  if (method == "modal") {
    if (x$sym.var.types == "$M") {
      return(sapply(x$data, sd))
    } else {
      stop("Impossible to compute the Standard Deviation for this type of variable with this method")
    }
  }
}
#line 1 "/private/var/folders/x1/bc7ln59d11jddyfmvq0f4mwm0000gn/T/RtmpK8STdo/R.INSTALL582a7c381cc/RSDA/R/sym.cfa.R"
#' @keywords internal
#'
sym.cfa <- function(x = NULL, y = NULL) {

  sym.data <- transform.set(x, y)
  idn <- all(sym.data$sym.var.types == sym.data$sym.var.types[1])
  if (idn == FALSE) {
    stop("All variables have to be of the same type")
  }
  res <- cfa.totals(sym.data)
  Z <- cfa.MatrixZ(sym.data, res$TotalRows, res$TotalColumns)
  svd <- eigen(Z)
  MVPRealz <- cfa.CVPRealz(
    sym.data, res$TotalRows, res$TotalColumns, res$Total,
    svd$vectors
  )
  Mzz <- cfa.Czz(sym.data, res$TotalRows, res$TotalColumns, MVPRealz, svd$values)
  CMM <- cfa.minmax(
    sym.data, res$TotalRows, res$TotalRowsMin, res$TotalRowsMax,
    res$TotalColumns, res$TotalColumnsMin, res$TotalColumnsMax, res$Total, MVPRealz,
    Mzz
  )
  names. <- make.names(c(sym.data$sym.var.names, sym.data$sym.obj.names),unique = T)
  df <- cbind(concept = names., data.frame(rbind(CMM$Min, CMM$Max)))
  df <- cbind(concept = names., data.frame(rbind(CMM$Min, CMM$Max)))
  colnames(df) <- c("concept", paste0("C", seq_len(ncol(df) - 1)))
  out <- classic.to.sym(df, concept = "concept")
  class(out) <- "sym.data.table"
  meta <- do.call("cbind",lapply(seq_len(ncol(CMM$Min)), function(x){data.frame("$I" = rep("I",nrow(CMM$Max)), CMM$Min[,x], CMM$Max[,x] ,check.names = F)}))
  data <- do.call("cbind",lapply(seq_len(ncol(CMM$Min)), function(x){data.frame(CMM$Min[,x], CMM$Max[,x] ,check.names = F)}))
  colnames(data) <-colnames(out$data)
  colnames(meta) <-colnames(out$meta)
  rownames(meta) <- make.names(names.,unique = T)
  rownames(data) <- make.names(names.,unique = T)

  out2 <- list(N = sum(sym.data$N,sym.data$M),
               M = ncol(CMM$Min),
               sym.obj.names = names.,
               sym.var.names = out$sym.var.names,
               sym.var.types = out$sym.var.types,
               sym.var.length = out$sym.var.length,
               sym.var.starts = out$sym.var.starts,
               data = data,
               meta = meta)
  class(out2) <- "sym.data.table"
  return(out2)
}

transform.set <- function(x, y) {
  concept <- colnames(x$data)
  x <- as.matrix(x$data)
  y <- as.matrix(y$data)

  x.min <- x
  p <- apply(x, 1, function(x) sum(x) > 1)
  x.min[p, ] <- rep(0, ncol(x))
  x.max <- x

  y.max <- y
  y.min <- y
  p <- apply(y, 1, function(x) sum(x) > 1)
  y.min[p, ] <- rep(0, ncol(y))

  df1 <- data.frame(t(x.min) %*% y.min)
  df2 <- data.frame(t(x.max) %*% y.max)
  df1$concept <- concept
  df2$concept <- concept
  df.out <- rbind(df1, df2)

  classic.to.sym(df.out, concept = "concept")
}
#line 1 "/private/var/folders/x1/bc7ln59d11jddyfmvq0f4mwm0000gn/T/RtmpK8STdo/R.INSTALL582a7c381cc/RSDA/R/sym.circle.plot.R"
#' Symbolic Circle of Correlations
#' @name sym.circle.plot
#' @aliases sym.circle.plot
#' @author Oldemar Rodriguez Rojas
#' @description Plot the symbolic circle of correlations.
#' @usage sym.circle.plot(prin.corre)
#' @param prin.corre A symbolic interval data matrix with correlations between the variables and the
#' principals componets, both of interval type.
#'
#' @return Plot the symbolic circle
#' @references
#' Rodriguez O. (2012). The Duality Problem in Interval Principal Components Analysis.
#' The 3rd Workshop in Symbolic Data Analysis, Madrid.
#'
#' @examples
#' data(oils)
#' res<-sym.interval.pca(oils,'centers')
#' sym.circle.plot(res$Sym.Prin.Correlations)
#'
#' @keywords Symbolic Circle
#' @export
#'
sym.circle.plot <- function(prin.corre) {
  v <- c(
    "green", "red", "blue", "cyan", "brown", "yellow", "pink", "purple", "orange",
    "gray"
  )
  msg <- paste("Correlation Circle")
  plot(-1.5:1.5, -1.5:1.5, type = "n", xlab = "C1", ylab = "C2", main = msg)
  abline(h = 0, lty = 3)
  abline(v = 0, lty = 3)
  symbols(0, 0, circles = 1, inches = FALSE, add = TRUE)
  c1 <- 1
  c2 <- 2
  n <- dim(prin.corre)[1]
  f <- dim(prin.corre)[2]
  CRTI <- matrix(nrow = n, ncol = f)
  CRTI <- prin.corre
  vars <- rownames(prin.corre)
  for (k in 1:n) {
    x1 <- min(CRTI[k, c1], CRTI[k, c2])
    x2 <- max(CRTI[k, c1], CRTI[k, c2])
    y1 <- min(CRTI[k, c2 + 1], CRTI[k, c2 + 2])
    y2 <- max(CRTI[k, c2 + 1], CRTI[k, c2 + 2])
    if (((x1 > 0) && (x2 > 0) && (y1 > 0) && (y2 > 0)) || ((x1 < 0) && (x2 < 0) &&
      (y1 < 0) && (y2 < 0))) {
      plotX.slice(x1, y2, x2, y1, v, vars, k)
    }
    if (((x1 < 0) && (x2 < 0) && (y1 > 0) && (y2 > 0)) || ((x1 > 0) && (x2 > 0) &&
      (y1 < 0) && (y2 < 0))) {
      plotX.slice(x1, y1, x2, y2, v, vars, k)
    }
    if ((y1 > 0) && (y2 > 0) && (x1 < 0) && (x2 > 0)) {
      plotX.slice(x1, y1, x2, y1, v, vars, k)
    }
    if ((y1 < 0) && (y2 < 0) && (x1 < 0) && (x2 > 0)) {
      plotX.slice(x1, y2, x2, y2, v, vars, k)
    }
    if ((x1 > 0) && (x2 > 0) && (y1 < 0) && (y2 > 0)) {
      plotX.slice(x1, y1, x1, y2, v, vars, k)
    }
    if ((x1 < 0) && (x2 < 0) && (y1 < 0) && (y2 > 0)) {
      plotX.slice(x2, y1, x2, y2, v, vars, k)
    }
    if ((x1 < 0) && (x2 > 0) && (y1 < 0) && (y2 > 0)) {
      plotX.slice(x2, y1, x2, y2, v, vars, k)
    }
  }
}
#line 1 "/private/var/folders/x1/bc7ln59d11jddyfmvq0f4mwm0000gn/T/RtmpK8STdo/R.INSTALL582a7c381cc/RSDA/R/sym.continuos.plot.R"
#' sym.continuos.plot
#' @keywords internal
sym.continuos.plot <- function(info, col=c("blue"), border=FALSE, show.type = TRUE) {
  if (info$sym.var.types != "$C") { # El tipo de dato es el incorrecto
    stop("The data type is wrong, only $C are accepted")
  }

  continuos <- as.numeric(info$data) # obtiene el valor continuo

  # grafica el plano
  plot(continuos + c(-0.5, 0.5), c(0, 4.1), type = "n", xlab = "", ylab = "", main = paste(info$sym.var.names, ifelse(show.type, " (Continuos)", "")), yaxt = "n")
  abline(v = continuos, col = col, lty = 2, lwd = 2) # agrega la linea vertical con el valor continuo
  text(continuos, 2, labels = as.character(round(continuos, 2)), cex = ifelse(par()$pin[1] <= 1.5, par()$pin[1], 1.5)) # agrega el label con el valor continuo en mitad del plano
  if (border) { # se pone el borde en negro
    box("figure", col = "black")
  }
}
#line 1 "/private/var/folders/x1/bc7ln59d11jddyfmvq0f4mwm0000gn/T/RtmpK8STdo/R.INSTALL582a7c381cc/RSDA/R/sym.cor.R"
#' Symbolic Correlation
#' @name sym.cor
#' @aliases sym.cor
#' @author Oldemar Rodriguez Rojas
#' @description This function compute the symbolic correlation
#' @usage sym.cor(sym.var.x, sym.var.y, method = c('centers', 'interval', 'billard', 'modal')
#' , na.rm = FALSE, ...)
#' @param sym.var.x First symbolic variables.
#' @param sym.var.y Second symbolic variables.
#' @param method The method to be use.
#' @param na.rm As in R cor function.
#' @param ... As in R cor function.
#'
#' @return Return a real number in [-1,1].
#' @references
#' Billard L. and  Diday E. (2006).
#' Symbolic data analysis: Conceptual statistics and data mining. Wiley, Chichester.
#'
#' Rodriguez, O. (2000).
#' Classification et Modeles Lineaires en Analyse des Donnees Symboliques. Ph.D. Thesis,
#' Paris IX-Dauphine University.
#'
#' @examples
#' data(example3)
#' sym.data<-example3
#' sym.cor(sym.var(sym.data,1),sym.var(sym.data,4),method='centers')
#' sym.cor(sym.var(sym.data,2),sym.var(sym.data,6),method='centers')
#' sym.cor(sym.var(sym.data,2),sym.var(sym.data,6),method='billard')
#' @keywords Symbolic Correlation
#' @export
#'
sym.cor <- function(sym.var.x, sym.var.y, method = c(
                      "centers", "interval", "billard",
                      "modal"
                    ), na.rm = FALSE, ...) {
  method <- match.arg(method)
  if (method == "centers") {
    if ((sym.var.x$var.type == "$C") && (sym.var.y$var.type == "$C")) {
      return(cor(sym.var.x$var.data.vector, sym.var.y$var.data.vector))
    }
    if ((sym.var.x$var.type == "$I") && (sym.var.y$var.type == "$I")) {
      return(cor((sym.var.x$var.data.vector[, 1] + sym.var.x$var.data.vector[
        ,
        2
      ]) / 2, (sym.var.y$var.data.vector[, 1] + sym.var.y$var.data.vector[
        ,
        2
      ]) / 2))
    } else {
      stop("Impossible to compute the Standard Deviation for this type of variable with this method")
    }
  }
  if (method == "billard") {
    if ((sym.var.x$var.type == "$I") && (sym.var.y$var.type == "$I")) {
      return(sym.cov(sym.var.x, sym.var.y, method = "billard") / (sym.sd(sym.var.x,
        method = "billard"
      ) * sym.sd(sym.var.y, method = "billard")))
    }
  }
}
#line 1 "/private/var/folders/x1/bc7ln59d11jddyfmvq0f4mwm0000gn/T/RtmpK8STdo/R.INSTALL582a7c381cc/RSDA/R/sym.cov.R"
#' Symbolic Covariance
#' @name sym.cov
#' @aliases sym.cov
#' @author Oldemar Rodriguez Rojas
#' @description This function compute the symbolic covariance.
#' @usage sym.cov(sym.var.x, sym.var.y, method = c('centers', 'interval', 'billard', 'modal'),
#' na.rm = FALSE, ...)
#' @param sym.var.x First symbolic variables.
#' @param sym.var.y Second symbolic variables.
#' @param method The method to be use.
#' @param na.rm As in R cov function.
#' @param ... As in R cov function.
#'
#' @return Return a real number.
#' @references
#' Billard L. and  Diday E. (2006).
#' Symbolic data analysis: Conceptual statistics and data mining. Wiley, Chichester.
#'
#' Rodriguez, O. (2000).
#' Classification et Modeles Lineaires en Analyse des Donnees Symboliques. Ph.D. Thesis,
#' Paris IX-Dauphine University.
#'
#' @examples
#' data(example3)
#' sym.data<-example3
#' sym.cov(sym.var(sym.data,1),sym.var(sym.data,4),method='centers')
#' sym.cov(sym.var(sym.data,2),sym.var(sym.data,6),method='centers')
#' sym.cov(sym.var(sym.data,2),sym.var(sym.data,6),method='billard')
#'
#' @keywords Symbolic Covariance
#'
#'
sym.cov <- function(sym.var.x, sym.var.y, method = c(
                      "centers", "interval", "billard",
                      "modal"
                    ), na.rm = FALSE, ...) {
  Gj <- function(a, b, vmean) {
    if ((a + b) / 2 <= vmean) {
      return(-1)
    } else {
      return(1)
    }
  }
  Qj <- function(a, b, vmean) {
    return((a - vmean)^2 + (a - vmean) * (b - vmean) + (b - vmean)^2)
  }
  method <- match.arg(method)
  if (method == "centers") {
    if ((sym.var.x$var.type == "$C") && (sym.var.y$var.type == "$C")) {
      return(cov(sym.var.x$var.data.vector, sym.var.y$var.data.vector))
    }
    if ((sym.var.x$var.type == "$I") && (sym.var.y$var.type == "$I")) {
      return(cov((sym.var.x$var.data.vector[, 1] + sym.var.x$var.data.vector[
        ,
        2
      ]) / 2, (sym.var.y$var.data.vector[, 1] + sym.var.y$var.data.vector[
        ,
        2
      ]) / 2))
    } else {
      stop("Impossible to compute the Standard Deviation for this type of variable with this method")
    }
  }
  if (method == "billard") {
    if ((sym.var.x$var.type == "$I") && (sym.var.y$var.type == "$I")) {
      ss <- 0
      vmean.x <- sym.mean(sym.var.x, method = "centers")
      vmean.y <- sym.mean(sym.var.y, method = "centers")
      for (i in 1:(sym.var.x$N)) {
        ss <- ss + Gj(sym.var.x$var.data.vector[i, 1], sym.var.x$var.data.vector[
          i,
          2
        ], vmean.x) * Gj(sym.var.y$var.data.vector[i, 1], sym.var.y$var.data.vector[
          i,
          2
        ], vmean.y) * sqrt(Qj(sym.var.x$var.data.vector[i, 1], sym.var.x$var.data.vector[
          i,
          2
        ], vmean.x) * Qj(sym.var.y$var.data.vector[i, 1], sym.var.y$var.data.vector[
          i,
          2
        ], vmean.y))
      }
      return((1 / (3 * sym.var.x$N)) * ss)
    } else {
      stop("Impossible to compute the Standard Deviation for this type of variable with this method")
    }
  }
}
#line 1 "/private/var/folders/x1/bc7ln59d11jddyfmvq0f4mwm0000gn/T/RtmpK8STdo/R.INSTALL582a7c381cc/RSDA/R/sym.data.table.to.sym.var.R"
#' sym.data.table.to.sym.var
#' @keywords internal
sym.data.table.to.sym.var <- function(sym.var) {
  new.sym.var <- list()
  new.sym.var$N <- sym.var$N
  new.sym.var$var.name <- sym.var$sym.var.names
  new.sym.var$var.type <- sym.var$sym.var.types
  new.sym.var$obj.names <- sym.var$sym.obj.names
  pos <- sym.var$sym.var.starts
  adv <- sym.var$sym.var.length
  new.sym.var$var.data.vector <- sym.var$meta[, (pos:(pos + adv - 1))]
  return(new.sym.var)
}
#line 1 "/private/var/folders/x1/bc7ln59d11jddyfmvq0f4mwm0000gn/T/RtmpK8STdo/R.INSTALL582a7c381cc/RSDA/R/sym.glm.R"
#' Lasso, Ridge and and Elastic Net Linear regression model to interval variables
#' @name sym.glm
#' @aliases sym.glm
#' @author Oldemar Rodriguez Rojas
#' @description Execute Lasso, Ridge and and Elastic Net Linear regression model to interval variables.
#' @usage sym.glm(sym.data, response = 1, method = c('cm', 'crm'),
#' alpha = 1, nfolds = 10, grouped = TRUE)
#' @param sym.data Should be a symbolic data table read with the function read.sym.table(...).
#' @param response The number of the column where is the response variable in the interval data table.
#' @param method 'cm' to generalized Center Method and 'crm' to generalized Center and Range Method.
#' @param alpha alpha=1 is the lasso penalty, and alpha=0 the ridge penalty. 0<alpha<1 is the elastic net method.
#' @param nfolds Number of folds - default is 10. Although nfolds can be as large as the sample size
#' (leave-one-out CV), it is not recommended for large datasets. Smallest value allowable
#' is nfolds=3
#' @param grouped This is an experimental argument, with default TRUE, and can be ignored by most users.
#'
#' @return An object of class 'cv.glmnet' is returned, which is a list with the ingredients of the cross-validation fit.
#' @references Rodriguez O. (2013). A generalization of Centre and Range method for fitting a linear
#' regression model to symbolic interval data using Ridge Regression, Lasso
#' and Elastic Net methods. The IFCS2013 conference of the International Federation of
#' Classification Societies, Tilburg University Holland.
#' @seealso sym.lm
#' @examples
#' data(int_prost_train)
#' data(int_prost_test)
#' res.cm.lasso<-sym.glm(sym.data=int_prost_train,response=9,method='cm',
#'                       alpha=1,nfolds=10,grouped=TRUE)
#' pred.cm.lasso<-predictsym.glm(res.cm.lasso,response=9,int_prost_test,method='cm')
#' plot(res.cm.lasso)
#' plot(res.cm.lasso$glmnet.fit, 'norm', label=TRUE)
#' plot(res.cm.lasso$glmnet.fit, 'lambda', label=TRUE)
#' RMSE.L(sym.var(int_prost_test,9),pred.cm.lasso)
#' RMSE.U(sym.var(int_prost_test,9),pred.cm.lasso)
#' R2.L(sym.var(int_prost_test,9),pred.cm.lasso)
#' R2.U(sym.var(int_prost_test,9),pred.cm.lasso)
#' deter.coefficient(sym.var(int_prost_test,9),pred.cm.lasso)
#'
#' @keywords Symbolic Regression Lasso Ridge
#' @export
#' @import glmnet
#'
sym.glm <- function(sym.data, response = 1, method = c("cm", "crm"), alpha = 1, nfolds = 10,
                    grouped = TRUE) {
  idn <- all(sym.data$sym.var.types == sym.data$sym.var.types[1])
  if (idn == FALSE) {
    stop("All variables have to be of the same type")
  }
  method <- match.arg(method)
  nn <- sym.data$N
  mm <- sym.data$M
  if (method == "cm") {
    centers <- matrix(0, nn, mm)
    for (i in 1:nn) for (j in 1:mm) centers[i, j] <- (sym.var(sym.data, j)$var.data.vector[
          i,
          1
        ] + sym.var(sym.data, j)$var.data.vector[i, 2]) / 2
    model <- cv.glmnet(centers[, -response], centers[, response],
      nfolds = nfolds,
      grouped = grouped, alpha = alpha
    )
    return(model)
  }
  if (method == "crm") {
    ## Center Model
    centers <- matrix(0, nn, mm)
    for (i in 1:nn) for (j in 1:mm) centers[i, j] <- (sym.var(sym.data, j)$var.data.vector[
          i,
          1
        ] + sym.var(sym.data, j)$var.data.vector[i, 2]) / 2
    modelc <- cv.glmnet(centers[, -response], centers[, response],
      nfolds = nfolds,
      grouped = grouped, alpha = alpha
    )
    # Range Model
    range <- matrix(0, nn, mm)
    for (i in 1:nn) for (j in 1:mm) range[i, j] <- (sym.var(sym.data, j)$var.data.vector[
          i,
          2
        ] - sym.var(sym.data, j)$var.data.vector[i, 1]) / 2
    modelr <- cv.glmnet(range[, -response], range[, response],
      nfolds = nfolds,
      grouped = grouped, alpha = alpha
    )
    return(list(CenterModel = modelc, RangeModel = modelr))
  }
}
#line 1 "/private/var/folders/x1/bc7ln59d11jddyfmvq0f4mwm0000gn/T/RtmpK8STdo/R.INSTALL582a7c381cc/RSDA/R/sym.hclust.R"
#' Symbolic Hierarchical Clustering
#' @name sym.hclust
#' @aliases sym.hclust
#' @author Oldemar Rodriguez Rojas
#' @description This function allows us to execute a symbolic
#' hierarchical clustering to interval variables.
#' @usage sym.hclust(sym.data, distance = c('hausdorff', 'centers'), p = 2,
#' method = c('ward.D2', 'single', 'complete', 'average', 'mcquitty',
#'            'median', 'centroid'), members = NULL)
#' @param sym.data The symbolic data table.
#' @param distance The distance to be use.
#' @param p The p in the Hausdorff distance :
#' \deqn{d(w_{u_1},w_{u_2}) = \left( \sum_{j=1}^m \Phi_j(w_{u_1},w_{u_2})^p  \right)^{1/p}}
#' @param method The method to be use, like in hclust R function.
#' @param members Like in hclust R function.
#'
#' @return Return a dendogram plot structure.
#' @references
#' Carvalho F., Souza R.,Chavent M., and Lechevallier Y. (2006)
#' Adaptive Hausdorff distances and dynamic clustering of symbolic interval data. Pattern
#' Recognition Letters Volume 27, Issue 3, February 2006, Pages 167-179
#'
#' Rodriguez, O. (2000).
#' Classification et Modeles Lineaires en Analyse des Donnees Symboliques. Ph.D. Thesis,
#' Paris IX-Dauphine University.
#' @examples
#' \dontrun{
#' data(oils)
#' sh<-sym.hclust(oils)
#' plot(sh)
#' sh<-sym.hclust(oils,'centers')
#' plot(sh)
#' }
#' @keywords Symbolic Clustering
#' @export
#'
sym.hclust <- function(sym.data, distance = c("hausdorff", "centers"), p = 2, method = c(
                         "ward.D2",
                         "single", "complete", "average", "mcquitty", "median", "centroid"
                       ), members = NULL) {
  distance <- match.arg(distance)
  method <- match.arg(method)
  return(hclust(interval.dist(sym.data, distance), method))
}
#line 1 "/private/var/folders/x1/bc7ln59d11jddyfmvq0f4mwm0000gn/T/RtmpK8STdo/R.INSTALL582a7c381cc/RSDA/R/sym.hist.plot.R"
#' sym.hist.plot
#' @keywords internal
sym.hist.plot <- function(info, col=c("blue"), border=FALSE, show.type = TRUE, angle = 60) {
  if (info$sym.var.types != "$H") { # El tipo de dato es el incorrecto
    stop("The data type is wrong, only $H are accepted")
  }
  dataset <- as.matrix(info$data) # obtenemos los datos

  plt <- barplot(dataset,
    ylim = c(0, 1), names.arg = colnames(dataset), col = col,
    yaxt = "n", xaxt = "n", xlab = "", ylab = "",
    main = paste(info$sym.var.names, ifelse(show.type, " (Histogram)", ""))
  )
  graphics::axis(2, at = seq(0, 1, 0.2), labels = sprintf(round(seq(0, 100, 20)), fmt = "%2.f%%"), las = 1)
  text(plt, par("usr")[3], labels = colnames(dataset), srt = angle, adj = 1.1, xpd = T)

  if (border) { # se pone el borde en negro
    box("figure", col = "black")
  }
}
#line 1 "/private/var/folders/x1/bc7ln59d11jddyfmvq0f4mwm0000gn/T/RtmpK8STdo/R.INSTALL582a7c381cc/RSDA/R/sym.histogram.pca.R"
#' Histogram Principal Components Analysis
#' @name sym.histogram.pca
#' @aliases sym.histogram.pca
#' @author Oldemar Rodriguez Rojas
#' @description This functions allows us to execute a histogram principal components analysis from a
#' symbolic data table with continuos, interval or histogram variables that can be mixed.
#' @usage sym.histogram.pca(sym.data, method = c('histogram', 'classic'))
#' @param sym.data Symbolic data table.
#' @param method The method to be used.
#'
#' @return Return a symbolic data table.
#' @references Diday, E., Rodriguez O. and Winberg S. (2000).
#' Generalization of the Principal Components Analysis to Histogram
#' Data, 4th European Conference on Principles and Practice of Knowledge Discovery in Data
#' Bases, September 12-16, 2000, Lyon, France.
#'
#' Rodriguez, O. (2000).
#' Classification et Modeles Lineaires en Analyse des Donnees Symboliques. Ph.D. Thesis,
#' Paris IX-Dauphine University.
#' @seealso sym.interval.pca
#'
#' @examples
#' data(example7)
#' res<-sym.histogram.pca(example7)
#' class(res) <- c('sym.data.table')
#' sym.scatterplot(res[,1],res[,2], labels=TRUE,col='red',main='Histogram PCA')
#' sym.scatterplot3d(res[,1],res[,2],res[,3],color='blue',
#'                   main='Histogram PCA')
#' @keywords Histogram PCA
#' @export
#' @importFrom FactoMineR PCA
#'
sym.histogram.pca <- function(sym.data, method = c("histogram", "classic")) {
  method <- match.arg(method)
  if (method == "histogram") {
    dam <- downarrow.matrix(sym.data)
    ram <- rightarrow.matrix(sym.data)
    cpc <- PCA(ram, graph = FALSE)
    res <- sym.interval.pca(dam, "centers")
    q <- min(res$Sym.Components$M, dim(cpc$ind$coord)[2])
  }
  k <- max(sym.data$sym.var.length)
  if (k == 1) {
    class(res) <- "sym.data.table"
    return(res)
  } else {
    pos <- 1
    for (i in 1:sym.data$N) {
      for (s in 1:k) {
        colm <- 2
        for (j in 1:q) {
          res$Sym.Components$meta[pos, colm] <- res$Sym.Components$meta[
            pos,
            colm
          ] + cpc$ind$coord[i, j]
          res$Sym.Components$meta[pos, colm + 1] <- res$Sym.Components$meta[
            pos,
            colm + 1
          ] + cpc$ind$coord[i, j]
          colm <- colm + 3
        }
        pos <- pos + 1
      }
    }
    dam$meta <- res$Sym.Components$meta
    class(dam) <- "sym.data.table"
    return(dam)
  }
}
#line 1 "/private/var/folders/x1/bc7ln59d11jddyfmvq0f4mwm0000gn/T/RtmpK8STdo/R.INSTALL582a7c381cc/RSDA/R/sym.interval.pc.2.j.r"
#' sym.interval.pc.2.j
#' @keywords internal
sym.interval.pc.2.j <- function(sym.data, method = c("vertex", "centers"), maxit, plot,
                                scale, center) {
  idn <- all(sym.data$sym.var.types == sym.data$sym.var.types[1])
  if (idn == FALSE) {
    stop("All variables have to be of the same type")
  }
  method <- match.arg(method)
  if ((sym.data$sym.var.types[1] != "$C") && (sym.data$sym.var.types[1] != "$I")) {
    stop("Variables have to be continuos or Interval")
  } else if (sym.data$sym.var.types[1] == "$C") {
    res <- principal.curve(sym.data$data, plot.true = plot, maxit = maxit)
  } else if (sym.data$sym.var.types[1] == "$I") {
    vertex <- vertex.interval(sym.data)
    individuals <- scale(as.matrix(vertex$vertex), scale = scale, center = center)
    if (method == "centers") {
      centers <- centers.interval.j(sym.data)
      res <- principal.curve(as.matrix(centers), plot.true = plot, maxit = maxit)
      n <- dim(individuals)
      projection.matrix <- matrix(data = NA, nrow = n[1], ncol = n[2])
      distance.vector <- rep(NA, n[1])
      lambda <- rep(NA, n[1])
      orthogonal.projection <- rep(NA, n[1])
      for (i in 1:n[1]) {
        neig <- neighbors.vertex(as.matrix(individuals[i, ]), res$s, 2)
        v <- -neig$neighbors[1, ] + neig$neighbors[2, ]
        vp <- -neig$neighbors[1, ] + individuals[i, ]
        proy <- sum(v * vp) / (norm.vect(v)^2) * v
        proy.point <- neig$neighbors[1, ] + proy
        projection.matrix[i, ] <- proy.point
        orthogonal.projection[i] <- sum((vp - proy) * v)
        distance.vector[i] <- norm.vect(vp - proy)
        lambda1 <- res$lambda[neig$order[1:2]]
        if (lambda1[1] <= lambda1[2]) {
          lambda[i] <- -lambda1[1] + norm.vect(proy)
        } else {
          lambda[i] <- lambda1[1] - norm.vect(proy)
        }
      }
      res.var.ind <- variance.princ.curve(data = individuals, curve = projection.matrix)
      res.var.mid <- variance.princ.curve(data = as.matrix(centers), curve = res$s)
      res.var <- list(res.var.ind = res.var.ind, res.var.mid = res.var.mid)
      colnames(projection.matrix) <- sym.data$sym.var.names
      res.limits <- sym.interval.pc.limits.2.j(
        sym.data = sym.data, prin.curve = projection.matrix,
        num.vertex = vertex$num.vertex, lambda = lambda
      )
      num.vars <- sym.data$M
      variables <- rep("X", num.vars)
      for (i in 1:num.vars) {
        # variables[res.var.ind$var.order[i]] <- paste0('prin_surface_', as.character(i))
        variables[i] <- paste0("prin_surface_", as.character(i))
      }
      colnames(projection.matrix) <- variables
      projection.matrix <- projection.matrix[, res.var.ind$var.order]
      correl <- cor(x = projection.matrix, y = vertex$vertex)
    } else if (method == "vertex") {
      res <- principal.curve(individuals, plot.true = plot, maxit = maxit)
      res.var <- variance.princ.curve(data = individuals, curve = res$s)
      res.limits <- sym.interval.pc.limits.2.j(
        sym.data = sym.data, prin.curve = res$s,
        num.vertex = vertex$num.vertex, lambda = res$lambda
      )

      num.vars <- sym.data$M
      variables <- rep("X", num.vars)
      for (i in 1:num.vars) {
        variables[res.var$var.order[i]] <- paste0("prin_surface_", as.character(i))
        variables[i] <- paste0("prin_surface_", as.character(i))
      }
      colnames(res$s) <- variables
      res$s <- res$s[, res.var$var.order]
      correl <- cor(x = res$s, y = vertex$vertex)
    }
    return(list(
      prin.curve = res, sym.prin.curve = res.limits, var.curve = res.var,
      cor.ps = correl
    ))
  }
  return(TRUE)
}
#line 1 "/private/var/folders/x1/bc7ln59d11jddyfmvq0f4mwm0000gn/T/RtmpK8STdo/R.INSTALL582a7c381cc/RSDA/R/sym.interval.pc.R"
#' Compute a symbolic interval principal components curves
#' @name sym.interval.pc
#' @aliases sym.interval.pc
#' @author Jorge Arce.
#' @description Compute a symbolic interval principal components curves
#' @usage sym.interval.pc(sym.data, method = c('vertex', 'centers'), maxit, plot, scale, center)
#' @param sym.data Shoud be a symbolic data table read with the function read.sym.table(...)
#' @param method It should be 'vertex' or 'centers'.
#' @param maxit Maximum number of iterations.
#' @param plot TRUE to plot immediately, FALSE if you do not want to plot.
#' @param scale TRUE to standardize the data.
#' @param center TRUE to center the data.
#'
#' @return
#' prin.curve: This a symbolic data table with the interval principal components. As
#' this is a symbolic data table we can apply over this table any other symbolic data
#' analysis method (symbolic propagation).
#'
#' cor.ps: This is the interval correlations between the original interval
#' variables and the interval principal components, it can be use to plot the symbolic
#' circle of correlations.
#' @references
#' Arce J. and Rodriguez O. (2015) 'Principal Curves and Surfaces
#' to Interval Valued Variables'. The 5th Workshop on Symbolic
#' Data Analysis, SDA2015, Orleans, France, November.
#'
#' Hastie,T. (1984).
#' Principal Curves and Surface. Ph.D Thesis Stanford University.
#'
#' Hastie,T. \& Weingessel,A. (2014).
#' princurve - Fits a Principal Curve in Arbitrary Dimension.R package version 1.1--12
#' http://cran.r-project.org/web/packages/princurve/index.html.
#'
#' Hastie,T. \& Stuetzle, W. (1989). Principal Curves.
#' Journal of the American Statistical Association, Vol. 84-406, 502--516.
#'
#' Hastie, T., Tibshirani, R. \& Friedman, J. (2008).
#' The Elements of Statistical Learning; Data Mining, Inference and Prediction. Springer, New York.
#' @seealso sym.interval.pca
#' @examples
#' \dontrun{
#' data(oils)
#' res.vertex.ps<-sym.interval.pc(oils,'vertex',150,FALSE,FALSE,TRUE)
#' class(res.vertex.ps$sym.prin.curve) <- c('sym.data.table')
#' sym.scatterplot(res.vertex.ps$sym.prin.curve[,1],res.vertex.ps$sym.prin.curve[,2],
#'                 labels=TRUE,col='red',main='PSC Oils Data')
#'
#' data(facedata)
#' res.vertex.ps<-sym.interval.pc(facedata,'vertex',150,FALSE,FALSE,TRUE)
#' class(res.vertex.ps$sym.prin.curve) <- c('sym.data.table')
#' sym.scatterplot(res.vertex.ps$sym.prin.curve[,1],res.vertex.ps$sym.prin.curve[,2],
#'                 labels=TRUE,col='red',main='PSC Face Data')
#' }
#' @keywords Principal Curve
#' @export
#' @import princurve
#'
sym.interval.pc <- function(sym.data, method = c("vertex", "centers"), maxit, plot,
                            scale, center) {
  idn <- all(sym.data$sym.var.types == sym.data$sym.var.types[1])

  if (idn == FALSE) {
    stop("All variables have to be of the same type")
  }
  method <- match.arg(method)

  if ((sym.data$sym.var.types[1] != "$C") && (sym.data$sym.var.types[1] != "$I")) {
    stop("Variables have to be continuos or Interval")
  } else if (sym.data$sym.var.types[1] == "$C") {
    res <- principal.curve(sym.data$data, plot.true = plot, maxit = maxit)
  } else if (sym.data$sym.var.types[1] == "$I") {
    vertex <- vertex.interval(sym.data)
    individuals <- scale(as.matrix(vertex$vertex), scale = scale, center = center)


    if (method == "centers") {
      centers <- centers.interval(sym.data)

      res <- principal.curve(as.matrix(centers), plot.true = plot, maxit = maxit)

      n <- dim(individuals)

      projection.matrix <- matrix(data = NA, nrow = n[1], ncol = n[2])

      distance.vector <- rep(NA, n[1])

      lambda <- rep(NA, n[1])

      orthogonal.projection <- rep(NA, n[1])

      for (i in 1:n[1]) {
        neig <- neighbors.vertex(as.matrix(individuals[i, ]), res$s, 2)
        v <- -neig$neighbors[1, ] + neig$neighbors[2, ]
        vp <- -neig$neighbors[1, ] + individuals[i, ]
        proy <- sum(v * vp) / (norm.vect(v)^2) * v
        proy.point <- neig$neighbors[1, ] + proy
        projection.matrix[i, ] <- proy.point
        orthogonal.projection[i] <- sum((vp - proy) * v)
        distance.vector[i] <- norm.vect(vp - proy)

        lambda1 <- res$lambda[neig$order[1:2]]
        if (lambda1[1] <= lambda1[2]) {
          lambda[i] <- -lambda1[1] + norm.vect(proy)
        } else {
          lambda[i] <- lambda1[1] - norm.vect(proy)
        }
      }

      res.var.ind <- variance.princ.curve(data = individuals, curve = projection.matrix)
      res.var.mid <- variance.princ.curve(data = as.matrix(centers), curve = res$s)
      res.var <- list(res.var.ind = res.var.ind, res.var.mid = res.var.mid)
      colnames(projection.matrix) <- sym.data$sym.var.names
      res.limits <- sym.interval.pc.limits(
        sym.data = sym.data, prin.curve = projection.matrix,
        num.vertex = vertex$num.vertex, lambda = lambda, res.var$res.var.mid$var.order
      )

      num.vars <- sym.data$M
      variables <- rep("X", num.vars)
      for (i in 1:num.vars) {
        variables[res.var.ind$var.order[i]] <- paste0("prin_surface_", as.character(i))
      }

      colnames(projection.matrix) <- variables
      projection.matrix <- projection.matrix[, res.var.ind$var.order]
      correl <- cor(x = projection.matrix, y = vertex$vertex)
    } else if (method == "vertex") {
      res <- principal.curve(individuals, plot.true = plot, maxit = maxit)

      res.var <- variance.princ.curve(data = individuals, curve = res$s)

      res.limits <- sym.interval.pc.limits(
        sym.data = sym.data, prin.curve = res$s,
        num.vertex = vertex$num.vertex, lambda = res$lambda, res.var$var.order
      )
      num.vars <- sym.data$M
      variables <- rep("X", num.vars)
      for (i in 1:num.vars) {
        variables[res.var$var.order[i]] <- paste0("prin_surface_", as.character(i))
      }

      colnames(res$s) <- variables
      res$s <- res$s[, res.var$var.order]
      correl <- cor(x = res$s, y = vertex$vertex)
    }


    return(list(
      prin.curve = res, sym.prin.curve = res.limits, var.curve = res.var,
      cor.ps = correl
    ))
  }

  return(TRUE)
}
#line 1 "/private/var/folders/x1/bc7ln59d11jddyfmvq0f4mwm0000gn/T/RtmpK8STdo/R.INSTALL582a7c381cc/RSDA/R/sym.interval.pc.limits.2.j.r"
#' sym.interval.pc.limits.2.j
#' @keywords internal
sym.interval.pc.limits.2.j <- function(sym.data, prin.curve, num.vertex, lambda) {
  num.vars <- sym.data$M
  num.ind <- sym.data$N

  res <- as.data.frame(prin.curve)
  res$lambda <- lambda

  nn <- sym.data$N
  sym.indiv <- rep("X", sum(num.vertex))

  start <- 1
  finish <- num.vertex[1]
  sym.indiv[start:finish] <- sym.data$sym.obj.names[1]

  for (i in 2:nn) {
    previous <- num.vertex[i - 1]
    start <- start + previous
    finish <- num.vertex[i] + finish
    sym.indiv[start:finish] <- sym.data$sym.obj.names[i]
  }

  res$symindiv <- sym.indiv
  var.type <- rep("$I", num.vars + 1)
  variables <- c(sym.data$sym.var.names, "lambda")
  browser()
  sym.res <- classic.to.sym(data = res, concept = "symindiv", variables = everything())
  # sym.res <- classic.to.sym(dataTable = res, concept = c("symindiv"), variables = variables,
  #   variables.types = var.type)
  return(sym.res)
}
#line 1 "/private/var/folders/x1/bc7ln59d11jddyfmvq0f4mwm0000gn/T/RtmpK8STdo/R.INSTALL582a7c381cc/RSDA/R/sym.interval.pc.limits.R"
#' Symbolic interval principal curves limits
#' @name sym.interval.pc.limits
#' @aliases sym.interval.pc.limits
#' @author Jorge Arce.
#' @description Symbolic interval principal curves limits.
#' @usage sym.interval.pc.limits(sym.data, prin.curve, num.vertex, lambda, var.ord)
#' @param sym.data Symbolic interval data table.
#' @param prin.curve Principal curves.
#' @param num.vertex Number of vertices of the hipercube.
#' @param lambda Lambda.
#' @param var.ord Order of the variables.
#' @references
#' Arce J. and Rodriguez O. (2015) 'Principal Curves and Surfaces
#' to Interval Valued Variables'. The 5th Workshop on Symbolic
#' Data Analysis, SDA2015, Orleans, France, November.
#'
#' Hastie,T. (1984).
#' Principal Curves and Surface. Ph.D Thesis Stanford University.
#'
#' Hastie,T. \& Weingessel,A. (2014).
#' princurve - Fits a Principal Curve in Arbitrary Dimension.R package version 1.1--12
#' http://cran.r-project.org/web/packages/princurve/index.html.
#'
#' Hastie,T. \& Stuetzle, W. (1989). Principal Curves.
#' Journal of the American Statistical Association, Vol. 84-406, 502--516.
#'
#' Hastie, T., Tibshirani, R. \& Friedman, J. (2008).
#' The Elements of Statistical Learning; Data Mining, Inference and Prediction. Springer, New York.
#' @seealso sym.interval.pc
#' @keywords Principal Curve
#' @import princurve
#' @export
#'
#'
sym.interval.pc.limits <- function(sym.data, prin.curve, num.vertex, lambda, var.ord) {
  num.vars <- sym.data$M
  num.ind <- sym.data$N

  res <- as.data.frame(prin.curve)
  res$lambda <- lambda

  sym.indiv <- rep("X", sum(num.vertex))

  start <- 1
  finish <- num.vertex[1]
  sym.indiv[start:finish] <- sym.data$sym.obj.names[1]

  for (i in 2:num.ind) {
    previous <- num.vertex[i - 1]
    start <- start + previous
    finish <- num.vertex[i] + finish
    sym.indiv[start:finish] <- sym.data$sym.obj.names[i]
  }

  res$symindiv <- sym.indiv
  var.type <- rep("$I", num.vars + 1)
  variables <- rep("X", num.vars)

  for (i in 1:num.vars) {
    variables[var.ord[i]] <- paste0("prin_surface_", as.character(i))
  }
  colnames(res)[1:num.vars] <- variables
  variables <- c(variables[var.ord], "lambda")

  sym.res <- classic.to.sym(data = res, concept = "symindiv", variables = everything())
  # sym.res <- classic.to.sym(dataTable = res, concept = c("symindiv"), variables = variables,
  #   variables.types = var.type)
  return(sym.res)
}
#line 1 "/private/var/folders/x1/bc7ln59d11jddyfmvq0f4mwm0000gn/T/RtmpK8STdo/R.INSTALL582a7c381cc/RSDA/R/sym.interval.pca.R"
#' Interval Principal Components Analysis.
#' @name sym.interval.pca
#' @aliases sym.interval.pca
#' @author Oldemar Rodriguez Rojas
#' @description Cazes, Chouakria, Diday and Schektman (1997)
#' proposed the Centers and the Tops Methods to extend the well known principal
#' components analysis method to a particular kind of symbolic objects
#' characterized by multi--values variables of interval type.
#' @usage sym.interval.pca(sym.data, method = c('classic', 'tops','centers',
#' 'principal.curves', 'optimized.distance', 'optimized.variance'))
#' @param sym.data Shoud be a symbolic data table
#' @param method It is use so select the method, 'classic' execute a classical principal component
#' analysis over the centers of the intervals, 'tops' to use the vertices algorithm
#' and 'centers' to use the centers algorithm.
#'
#' @return
#' Sym.Components: This a symbolic data table with the interval principal components. As
#' this is a symbolic data table we can apply over this table any other symbolic data
#' analysis method (symbolic propagation).
#'
#' Sym.Prin.Correlations: This is the interval correlations between the original interval
#' variables and the interval principal components, it can be use to plot the symbolic
#' circle of correlations.
#' @references
#' Bock H-H. and Diday E. (eds.) (2000).
#' Analysis of Symbolic Data. Exploratory methods for extracting statistical information from
#' complex data. Springer, Germany.
#'
#' Cazes P., Chouakria A., Diday E. et Schektman Y. (1997).  Extension de l'analyse en
#' composantes principales a des donnees de type intervalle, Rev. Statistique Appliquee,
#' Vol. XLV Num. 3 pag. 5-24, France.
#'
#' Chouakria A. (1998)
#' Extension des methodes d'analysis factorialle a des
#' donnees de type intervalle, Ph.D. Thesis, Paris IX Dauphine University.
#'
#' Makosso-Kallyth S. and Diday E. (2012).  Adaptation of interval PCA to symbolic histogram
#' variables, Advances in Data Analysis and Classification July, Volume 6, Issue 2, pp 147-159.
#'
#' Rodriguez, O. (2000).
#' Classification et Modeles Lineaires en Analyse des Donnees Symboliques. Ph.D. Thesis,
#' Paris IX-Dauphine University.
#' @seealso sym.histogram.pca
#' @examples
#' \dontrun{
#' data(oils)
#' res<-sym.interval.pca(oils,'centers')
#' class(res) <- c('sym.data.table')
#' sym.scatterplot(res$Sym.Components[,1],res$Sym.Components[,1],
#'                 labels=TRUE,col='red',main='PCA Oils Data')
#' sym.scatterplot3d(res$Sym.Components[,1],res$Sym.Components[,2],
#'                   res$Sym.Components[,3],color='blue',main='PCA Oils Data')
#' sym.scatterplot.ggplot(res$Sym.Components[,1],res$Sym.Components[,2],
#'                        labels=TRUE)
#' sym.circle.plot(res$Sym.Prin.Correlations)
#'
#' res<-sym.interval.pca(oils,'classic')
#' plot(res,choix='ind')
#' plot(res,choix='var')
#'
#' data(lynne2)
#' res<-sym.interval.pca(lynne2,'centers')
#' class(res$Sym.Components) <- c('sym.data.table')
#' sym.scatterplot(res$Sym.Components[,1],res$Sym.Components[,2],
#'                 labels=TRUE,col='red',main='PCA Lynne Data')
#' sym.scatterplot3d(res$Sym.Components[,1],res$Sym.Components[,2],
#'                   res$Sym.Components[,3],color='blue', main='PCA Lynne Data')
#' sym.scatterplot.ggplot(res$Sym.Components[,1],res$Sym.Components[,2],
#'                        labels=TRUE)
#' sym.circle.plot(res$Sym.Prin.Correlations)
#'
#' data(StudentsGrades)
#' st<-StudentsGrades
#' s.pca<-sym.interval.pca(st)
#' plot(s.pca,choix='ind')
#' plot(s.pca,choix='var')
#' }
#' @keywords PCA Intervals
#' @export
#'
sym.interval.pca <- function(sym.data, method = c(
                               "classic", "tops", "centers", "principal.curves",
                               "optimized.distance", "optimized.variance"
                             )) {
  idn <- all(sym.data$sym.var.types == sym.data$sym.var.types[1])
  if (idn == FALSE) {
    stop("All variables have to be of the same type")
  }
  method <- match.arg(method)
  if (method == "classic") {
    if ((sym.data$sym.var.types[1] != "$C") && (sym.data$sym.var.types[1] != "$I")) {
      stop("Variables have to be continuos or Interval")
    }
    if (sym.data$sym.var.types[1] == "$C") {
      res <- PCA(sym.data$data, scale.unit = TRUE, ncp = sym.data$M, graph = FALSE)
    } else if (sym.data$sym.var.types[1] == "$I") {
      nn <- sym.data$N
      mm <- sym.data$M
      centers <- matrix(0, nn, mm)
      centers <- as.data.frame(centers)
      rownames(centers) <- sym.data$sym.obj.names
      colnames(centers) <- sym.data$sym.var.names
      for (i in 1:nn) for (j in 1:mm) centers[i, j] <- (sym.var(sym.data, j)$var.data.vector[
            i,
            1
          ] + sym.var(sym.data, j)$var.data.vector[i, 2]) / 2
      res <- FactoMineR::PCA(centers, scale.unit = TRUE, ncp = sym.data$M, graph = FALSE)
    }
    return(res)
  }
  if (method == "centers") {
    nn <- sym.data$N
    mm <- sym.data$M
    centers <- matrix(0, nn, mm)
    centers.stan <- matrix(0, nn, mm)
    min.stan <- matrix(0, nn, mm)
    max.stan <- matrix(0, nn, mm)
    for (i in 1:nn) for (j in 1:mm) centers[i, j] <- (sym.var(sym.data, j)$var.data.vector[
          i,
          1
        ] + sym.var(sym.data, j)$var.data.vector[i, 2]) / 2
    # Standarized
    for (i in 1:nn) for (j in 1:mm) centers.stan[i, j] <- (centers[i, j] - mean(centers[
          ,
          j
        ])) / (sd(centers[, j]) * sqrt((nn - 1) / nn))
    # Min-Max
    for (i in 1:nn) {
      for (j in 1:mm) {
        min.stan[i, j] <- (sym.var(sym.data, j)$var.data.vector[i, 1] - mean(centers[
          ,
          j
        ])) / (sd(centers[, j]) * sqrt((nn - 1) / nn))
        max.stan[i, j] <- (sym.var(sym.data, j)$var.data.vector[i, 2] - mean(centers[
          ,
          j
        ])) / (sd(centers[, j]) * sqrt((nn - 1) / nn))
      }
    }
    # Correlation Centers Matrix
    R <- t(centers.stan) %*% centers.stan
    svd <- eigen(R)
    sym.comp <- sym.data
    # Interval Principal Components
    for (i in 1:nn) {
      posd <- 1
      for (j in 1:mm) {
        smin <- 0
        smax <- 0
        for (k in 1:mm) {
          if (svd$vectors[k, j] < 0) {
            smin <- smin + max.stan[i, k] * svd$vectors[k, j]
          } else {
            smin <- smin + min.stan[i, k] * svd$vectors[k, j]
          }
          if (svd$vectors[k, j] < 0) {
            smax <- smax + min.stan[i, k] * svd$vectors[k, j]
          } else {
            smax <- smax + max.stan[i, k] * svd$vectors[k, j]
          }
        }
        sym.comp$meta[i, sym.comp$sym.var.starts[j]] <- smin
        sym.comp$meta[i, sym.comp$sym.var.starts[j] + 1] <- smax
        sym.comp$data[i, posd] <- smin
        sym.comp$data[i, posd + 1] <- smax
        posd <- posd + 2
      }
    }
    pos <- 1
    for (j in 1:mm) {
      comp.name <- paste("C", j, sep = "")
      sym.comp$sym.var.names[j] <- comp.name
      comp.name <- paste("Min.C", j, sep = "")
      colnames(sym.comp$data)[pos] <- comp.name
      comp.name <- paste("Max.C", j, sep = "")
      colnames(sym.comp$data)[pos + 1] <- comp.name
      pos <- pos + 2
      comp.name <- paste("Min.C", j, sep = "")
      colnames(sym.comp$meta)[sym.comp$sym.var.starts[j]] <- comp.name
      comp.name <- paste("Max.C", j, sep = "")
      colnames(sym.comp$meta)[sym.comp$sym.var.starts[j] + 1] <- comp.name
    }
    # Interval Principal Correlations
    svdV <- matrix(0, nn, nn)
    for (i in 1:nn) {
      for (j in 1:mm) {
        ss <- 0
        for (k in 1:mm) {
          ss <- ss + centers.stan[i, k] * svd$vectors[k, j]
        }
        svdV[i, j] <- (1 / sqrt(svd$values[j])) * ss
      }
    }
    IPrinCorre <- matrix(0, mm, 2 * mm)
    for (i in 1:mm) {
      pcol <- 1
      for (j in 1:mm) {
        smin <- 0
        smax <- 0
        for (k in 1:nn) {
          if (svdV[k, j] < 0) {
            smin <- smin + (1 / sqrt(nn)) * max.stan[k, i] * svdV[k, j]
          } else {
            smin <- smin + (1 / sqrt(nn)) * min.stan[k, i] * svdV[k, j]
          }
          if (svdV[k, j] < 0) {
            smax <- smax + (1 / sqrt(nn)) * min.stan[k, i] * svdV[k, j]
          } else {
            smax <- smax + (1 / sqrt(nn)) * max.stan[k, i] * svdV[k, j]
          }
        }
        IPrinCorre[i, pcol] <- smin
        IPrinCorre[i, pcol + 1] <- smax
        pcol <- pcol + 2
      }
    }
    IPrinCorre <- as.data.frame(IPrinCorre)
    rownames(IPrinCorre) <- sym.data$sym.var.names
    class(sym.comp) <- "sym.data.table"
    return(list(Sym.Components = sym.comp, Sym.Prin.Correlations = IPrinCorre))
  }
  if (method == "tops") {
    res <- vertex.pca.j(sym.data)
    return(res)
  }
  if (method == "principal.curves") {
    res <- sym.interval.pc(sym.data, "vertex", 150, FALSE, FALSE, TRUE)
    return(res)
  }
  if (method == "optimized.distance") {
    res <- optim.pca.distance.j(sym.data)
    return(res)
  }
  if (method == "optimized.variance") {
    res <- optim.pca.variance.j(sym.data, num.dimension = 3)
    return(res)
  }
  return(TRUE)
}
#line 1 "/private/var/folders/x1/bc7ln59d11jddyfmvq0f4mwm0000gn/T/RtmpK8STdo/R.INSTALL582a7c381cc/RSDA/R/sym.interval.pca.limits.new.j.r"
#' sym.interval.pca.limits.new.j
#' @keywords internal
sym.interval.pca.limits.new.j <- function(sym.data, prin.comp, num.vertex) {
  num.vars <- sym.data$M
  num.ind <- sym.data$N

  res <- as.data.frame(prin.comp)

  nn <- sym.data$N
  sym.indiv <- rep("X", sum(num.vertex))

  start <- 1
  finish <- num.vertex[1]
  sym.indiv[start:finish] <- sym.data$sym.obj.names[1]

  for (i in 2:nn) {
    previous <- num.vertex[i - 1]
    start <- start + previous
    finish <- num.vertex[i] + finish
    sym.indiv[start:finish] <- sym.data$sym.obj.names[i]
  }

  res$symindiv <- sym.indiv
  var.type <- rep("$I", num.vars)
  variables <- colnames(prin.comp)
  sym.res <- classic.to.sym(data = res, concept = "symindiv", variables = everything())
  # sym.res <- classic.to.sym(dataTable = res, concept = c("symindiv"), variables = variables,
  # variables.types = var.type)
  return(sym.res)
}
#line 1 "/private/var/folders/x1/bc7ln59d11jddyfmvq0f4mwm0000gn/T/RtmpK8STdo/R.INSTALL582a7c381cc/RSDA/R/sym.interval.plot.R"
#' sym.interval.plot
#' @keywords internal
sym.interval.plot <- function(info, col=c("blue"), border=FALSE, show.type = TRUE) {
  if (info$sym.var.types != "$I") { # El tipo de dato es el incorrecto
    stop("The data type is wrong, only $I are accepted")
  }

  interval <- as.numeric(info$data[1, ]) # sacamos el intervalo
  name <- paste("[", round(interval[1], 2), ",", round(interval[2], 2), "]") # El label que va en el centro del grafico

  # grafica el plano
  plot(interval + c(-0.4, 0.4), c(0, 3.5),
    type = "n", xlab = "", ylab = "", yaxt = "n",
    main = paste(toupper(info$sym.var.names), ifelse(show.type, " (Interval)", ""))
  )
  rect(interval[1], -1, interval[2], 3.5, col = col) # rectangulo del intervalo
  center <- c(mean(c(interval[1], interval[2])), mean(c(-1, 4))) # encuentra el centro del rectangulo
  text(center[1], center[2],
    labels = name, # pone el label con el intevalo en el centro
    cex = ifelse(par()$pin[1] <= 1.5, par()$pin[1], 1.5)
  ) # decide ele tamao del label
  if (border) { # se pone el borde en negro
    box("figure", col = "black")
  }
}
#line 1 "/private/var/folders/x1/bc7ln59d11jddyfmvq0f4mwm0000gn/T/RtmpK8STdo/R.INSTALL582a7c381cc/RSDA/R/sym.interval.vertex.pca.j.r"
#' sym.interval.vertex.pca.j
#' @keywords internal
sym.interval.vertex.pca.j <- function(data.sym) {
  vertex.sym <- vertex.interval.new.j(data.sym)
  data.vertex <- as.matrix(vertex.sym$vertex)
  dim.sym <- dim(data.vertex)
  indx.cols <- data.frame(i = 1:dim.sym[2])


  medias <- apply(indx.cols, 1, function(i) {
    mean(data.vertex[, i])
  })
  data.vertex.centrada <- t(t(data.vertex) - medias)

  desviaciones <- apply(indx.cols, 1, function(i) {
    sd(data.vertex[, i])
  })
  desviaciones <- desviaciones * sqrt((dim.sym[1] - 1) / dim.sym[1])

  data.vertex.centrada <- t(t(data.vertex.centrada) / desviaciones)

  matrix.data <- as.matrix(data.sym$data)
  matrix.data.centrada <- as.matrix(data.sym$data)
  m <- data.sym$M
  n <- data.sym$N

  indx <- data.frame(pos = 1:m)

  list.stand <- apply(indx, 1, function(i) {
    pos.ini <- 2 * (i - 1) + 1
    pos.fin <- 2 * i
    matrix.data.centrada[, pos.ini:pos.fin] <<- (matrix.data[, pos.ini:pos.fin] -
      medias[i]) / desviaciones[i]
  })

  cor.matrix <- t(data.vertex.centrada) %*% data.vertex.centrada / dim.sym[1]
  cor.matrix.eigen <- eigen(cor.matrix)
  vector.propios <- cor.matrix.eigen$vectors
  vector.propios.pos <- vector.propios

  vector.propios.pos <- apply(indx, 1, function(i) {
    apply(indx, 1, function(j) {
      if (vector.propios[j, i] > 0) {
        vector.propios[j, i]
      } else {
        0
      }
    })
  })


  vector.propios.neg <- vector.propios - vector.propios.pos

  indx.max <- seq(2, to = 2 * m, by = 2)
  indx.min <- seq(1, to = 2 * m, by = 2)

  max.neg <- matrix.data.centrada[, indx.max] %*% vector.propios.neg
  min.neg <- matrix.data.centrada[, indx.min] %*% vector.propios.neg

  max.pos <- matrix.data.centrada[, indx.max] %*% vector.propios.pos
  min.pos <- matrix.data.centrada[, indx.min] %*% vector.propios.pos

  maximos <- max.pos + min.neg
  minimos <- min.pos + max.neg

  names.sal <- paste0("Dim.", t(indx))
  sal.sym <- as.data.frame(matrix(rep(0, n * 2 * m), nrow = n))
  colnames(sal.sym)[indx.min] <- names.sal
  colnames(sal.sym)[indx.max] <- paste0(names.sal, ".1")

  sal.sym[, indx.max] <- maximos
  sal.sym[, indx.min] <- minimos

  row.names(sal.sym) <- data.sym$sym.obj.names

  return(list(
    Sym.Components = data.frame.to.RSDA.inteval.table.j(sal.sym), pos.coord.eigen = vector.propios.pos,
    neg.coord.eigen = vector.propios.neg, mean.vertex = medias, sd.vertex = desviaciones
  ))
}
#line 1 "/private/var/folders/x1/bc7ln59d11jddyfmvq0f4mwm0000gn/T/RtmpK8STdo/R.INSTALL582a7c381cc/RSDA/R/sym.kmeans.R"
#' Symbolic k-Means
#' @name sym.kmeans
#' @aliases sym.kmeans
#' @author Oldemar Rodriguez Rojas
#' @description This is a function is to carry out a k-means overs a interval symbolic data matrix.
#' @usage sym.kmeans(sym.data, k = 3, iter.max = 10, nstart = 1,
#' algorithm = c('Hartigan-Wong', 'Lloyd', 'Forgy', 'MacQueen'))
#' @param sym.data Symbolic data table.
#' @param k The number of clusters.
#' @param iter.max Maximun number of iterations.
#' @param nstart As in R kmeans function.
#' @param algorithm The method to be use, as in kmeans R function.
#'
#' @return
#' This function return the following information: \cr
#'
#' K-means clustering with 3 clusters of sizes 2, 2, 4\cr
#'
#' Cluster means:\cr
#'
#'   GRA     FRE     IOD    SAP\cr
#'
#' 1 0.93300 -13.500 193.500 174.75\cr
#'
#' 2 0.86300  30.500  54.500 195.25\cr
#'
#' 3 0.91825  -6.375  95.375 191.50\cr
#'
#'
#' Clustering vector:\cr
#'
#'   L  P Co  S Ca  O  B  H \cr
#'
#' 1  1  3  3  3  3  2  2 \cr
#'
#' Within cluster sum of squares by cluster:\cr
#'
#'   [1] 876.625 246.125 941.875\cr
#'
#' (between_SS / total_SS =  92.0 %) \cr
#'
#' Available components:\cr
#'
#'   [1] 'cluster'      'centers'      'totss'        'withinss'     'tot.withinss' 'betweenss'  \cr
#'
#' [7] 'size'        \cr
#'
#' @references
#' Carvalho F., Souza R.,Chavent M., and Lechevallier Y. (2006)
#' Adaptive Hausdorff distances and dynamic clustering of symbolic interval data. Pattern
#' Recognition Letters Volume 27, Issue 3, February 2006, Pages 167-179
#'
#' @seealso sym.hclust
#' @examples
#' data(oils)
#' sk<-sym.kmeans(oils,k=3)
#' sk$cluster
#' @keywords Symbolic Kmeans
#' @export
#'
sym.kmeans <- function(sym.data, k = 3, iter.max = 10, nstart = 1, algorithm = c(
                         "Hartigan-Wong",
                         "Lloyd", "Forgy", "MacQueen"
                       )) {
  algorithm <- match.arg(algorithm)
  idn <- all(sym.data$sym.var.types == "$I")
  if (idn == FALSE) {
    stop("The two variables have to be interval type")
  }
  nn <- sym.data$N
  mm <- sym.data$M
  centers <- matrix(0, nn, mm)
  centers <- as.data.frame(centers)
  rownames(centers) <- sym.data$sym.obj.names
  colnames(centers) <- sym.data$sym.var.names
  for (i in 1:nn) for (j in 1:mm) centers[i, j] <- (sym.var(sym.data, j)$var.data.vector[
        i,
        1
      ] + sym.var(sym.data, j)$var.data.vector[i, 2]) / 2
  return(kmeans(centers, k, iter.max, nstart, algorithm))
}
#line 1 "/private/var/folders/x1/bc7ln59d11jddyfmvq0f4mwm0000gn/T/RtmpK8STdo/R.INSTALL582a7c381cc/RSDA/R/sym.lm.R"
#' CM and CRM Linear regression model.
#' @name sym.lm
#' @aliases sym.lm
#' @author Oldemar Rodriguez Rojas
#' @description To execute the Center Method (CR) and Center and Range Method (CRM) to Linear regression.
#' @usage sym.lm(formula, sym.data, method = c('cm', 'crm'))
#' @param formula An object of class 'formula' (or one that can be coerced to that class): a symbolic description
#' of the model to be fitted.
#' @param sym.data Should be a symbolic data table read with the function read.sym.table(...).
#' @param method 'cm' to Center Method and 'crm' to Center and Range Method.
#' @details
#' Models for lm are specified symbolically. A typical model has the form response ~
#' terms where response is the (numeric) response vector and terms is a series of
#' terms which specifies a linear predictor for response. A terms specification of
#' the form first + second indicates all the terms in first together with all the
#' terms in second with duplicates removed. A specification of the form first:second indicates
#' the set of terms obtained by taking the interactions of all terms in first with all terms
#' in second. The specification first*second indicates the cross of first and second.
#' This is the same as first + second + first:second.
#' @return sym.lm returns an object of class 'lm' or for multiple responses of class c('mlm', 'lm')
#' @references
#' LIMA-NETO, E.A., DE CARVALHO, F.A.T., (2008). Centre and range method
#' to fitting a linear regression model on symbolic interval data. Computational
#' Statistics and Data Analysis 52, 1500-1515.
#'
#' LIMA-NETO, E.A., DE CARVALHO, F.A.T., (2010). Constrained linear regression models
#' for symbolic interval-valued variables. Computational Statistics and
#' Data Analysis 54, 333-347.
#'
#' @examples
#' data(int_prost_train)
#' data(int_prost_test)
#' res.cm<-sym.lm(lpsa~.,sym.data=int_prost_train,method='cm')
#' pred.cm<-predictsym.lm(res.cm,int_prost_test,method='cm')
#' RMSE.L(sym.var(int_prost_test,9),pred.cm$Fitted)
#' RMSE.U(sym.var(int_prost_test,9),pred.cm$Fitted)
#' R2.L(sym.var(int_prost_test,9),pred.cm$Fitted)
#' R2.U(sym.var(int_prost_test,9),pred.cm$Fitted)
#' deter.coefficient(sym.var(int_prost_test,9),pred.cm$Fitted)
#' @keywords Symbolic lm
#' @import stats scales
#' @export
#'
sym.lm <- sym.lm <- function(formula, sym.data, method = c("cm", "crm")) {
  idn <- all(sym.data$sym.var.types == sym.data$sym.var.types[1])
  if (idn == FALSE) {
    stop("All variables have to be of the same type")
  }
  method <- match.arg(method)
  nn <- sym.data$N
  mm <- sym.data$M
  if (method == "cm") {
    centers <- matrix(0, nn, mm)
    for (i in 1:nn) for (j in 1:mm) centers[i, j] <- (sym.var(sym.data, j)$var.data.vector[
          i,
          1
        ] + sym.var(sym.data, j)$var.data.vector[i, 2]) / 2
    centers <- as.data.frame(centers)
    colnames(centers) <- sym.data$sym.var.names
    model <- lm(formula, data = centers)
    return(model)
  }
  if (method == "crm") {
    # Center Model
    centers <- matrix(0, nn, mm)
    for (i in 1:nn) for (j in 1:mm) centers[i, j] <- (sym.var(sym.data, j)$var.data.vector[
          i,
          1
        ] + sym.var(sym.data, j)$var.data.vector[i, 2]) / 2
    centers <- as.data.frame(centers)
    colnames(centers) <- sym.data$sym.var.names
    modelc <- lm(formula, data = centers)
    # Range Model
    range <- matrix(0, nn, mm)
    for (i in 1:nn) for (j in 1:mm) range[i, j] <- (sym.var(sym.data, j)$var.data.vector[
          i,
          2
        ] - sym.var(sym.data, j)$var.data.vector[i, 1]) / 2
    range <- as.data.frame(range)
    colnames(range) <- sym.data$sym.var.names
    modelr <- lm(formula, data = range)
    return(list(CenterModel = modelc, RangeModel = modelr))
  }
}
#line 1 "/private/var/folders/x1/bc7ln59d11jddyfmvq0f4mwm0000gn/T/RtmpK8STdo/R.INSTALL582a7c381cc/RSDA/R/sym.lm.bi.R"
#' Symbolic Linear Regression for two variables.
#' @name sym.lm.bi
#' @aliases sym.lm.bi
#' @author Oldemar Rodriguez Rojas
#' @description The function build a symbolic regression for two interval or continuos variables.
#' @usage sym.lm.bi(sym.var.x, sym.var.y, method = c('mid-points', 'tops', 'inf-sup',
#' 'billard'))
#' @param sym.var.x The firth symbolic variable.
#' @param sym.var.y The second symbolic variable.
#' @param method The thirth symbolic variable.
#'
#' @return
#' This function return a regression structure as folllows:\cr
#'
#' $Intercept \cr
#' [1] 38.64236\cr
#' \cr
#' $Beta1\cr
#' [1] 0.3081313\cr
#' @references
#' Billard L. and  Diday E. (2006).
#' Symbolic data analysis: Conceptual statistics and data mining. Wiley, Chichester.
#'
#' Rodriguez, O. (2000).
#' Classification et Modeles Lineaires en Analyse des Donnees Symboliques. Ph.D. Thesis,
#' Paris IX-Dauphine University.
#'
#' @examples
#' data(example3)
#' sym.data<-example3
#' class(sym.data) <- c('sym.data.table')
#' lm.mod<-sym.lm.bi(sym.var(sym.data,1),sym.var(sym.data,4))
#' sym.scatterplot(sym.data[,1],sym.data[,4],col='blue',
#'                 main='Linear Regression')
#' abline(lm.mod,lwd=3)
#'
#' lm.mod<-sym.lm.bi(sym.var(sym.data,2),sym.var(sym.data,6))
#' sym.scatterplot(sym.data[,2],sym.data[,6],
#'                 col='blue',main='Linear Regression')
#' abline(lm.mod,lwd=3)
#'
#' data(lynne1)
#' sym.data<-lynne1
#' class(sym.data) <- c('sym.data.table')
#' lm.mod<-sym.lm.bi(sym.var(lynne1,2),sym.var(lynne1,1))
#' sym.scatterplot(sym.data[,2],sym.data[,1],labels=TRUE,
#'                 col='red',main='Linear Regression')
#' abline(lm.mod,lwd=3,col='blue')
#'
#' lm.mod<-sym.lm.bi(sym.var(lynne1,2),sym.var(lynne1,1),method='inf-sup')
#' sym.scatterplot(sym.data[,2],sym.data[,1],labels=TRUE,
#'                 col='red',main='Linear Regression')
#' abline(lm.mod$inf,lwd=3,col='blue')
#' abline(lm.mod$sup,lwd=3,col='blue')
#'
#' lm.mod<-sym.lm.bi(sym.var(lynne1,2),sym.var(lynne1,1),method='tops')
#' sym.scatterplot(sym.data[,2],sym.data[,1],labels=TRUE,
#'                 col='red',main='Linear Regression')
#' abline(lm.mod,lwd=3,col='blue')
#'
#' lm.mod<-sym.lm.bi(sym.var(lynne1,2),sym.var(lynne1,1),method='billard')
#' sym.scatterplot(sym.data[,2],sym.data[,1],labels=TRUE,
#'                 col='red',main='Linear Regression')
#' abline(lm.mod$Intercept,lm.mod$Beta1,lwd=3,col='blue')
#' @keywords Symbolic Regression
#' @export
#'
sym.lm.bi <- function(sym.var.x, sym.var.y, method = c(
                        "mid-points", "tops", "inf-sup",
                        "billard"
                      )) {
  method <- match.arg(method)
  if (((sym.var.x$var.type != "$C") || (sym.var.y$var.type != "$C")) && ((sym.var.x$var.type !=
    "$I") || (sym.var.y$var.type != "$I"))) {
    stop("Impossible to use lm this type of variable")
  }
  if (method == "mid-points") {
    if ((sym.var.x$var.type == "$C") && (sym.var.y$var.type == "$C")) {
      lm1 <- lm(sym.var.y$var.data.vector ~ sym.var.x$var.data.vector)
    }
    if ((sym.var.x$var.type == "$I") && (sym.var.y$var.type == "$I")) {
      vx <- (sym.var.x$var.data.vector[, 1] + sym.var.x$var.data.vector[, 2]) / 2
      vy <- (sym.var.y$var.data.vector[, 1] + sym.var.y$var.data.vector[, 2]) / 2
      lm1 <- lm(vy ~ vx)
    }
    return(lm1)
  }
  if (method == "inf-sup") {
    if ((sym.var.x$var.type == "$I") && (sym.var.y$var.type == "$I")) {
      vx <- sym.var.x$var.data.vector[, 2]
      vy <- sym.var.y$var.data.vector[, 1]
      lm1 <- lm(vy ~ vx)
      vx <- sym.var.x$var.data.vector[, 1]
      vy <- sym.var.y$var.data.vector[, 2]
      lm2 <- lm(vy ~ vx)
    }
    return(list(inf = lm1, sup = lm2))
  }
  if (method == "tops") {
    if ((sym.var.x$var.type == "$I") && (sym.var.y$var.type == "$I")) {
      vx <- c(
        sym.var.x$var.data.vector[, 1], sym.var.x$var.data.vector[, 1],
        sym.var.x$var.data.vector[, 2], sym.var.x$var.data.vector[, 2]
      )
      vy <- c(
        sym.var.y$var.data.vector[, 1], sym.var.y$var.data.vector[, 2],
        sym.var.y$var.data.vector[, 1], sym.var.y$var.data.vector[, 2]
      )
      lm1 <- lm(vy ~ vx)
    }
    return(lm1)
  }
  if (method == "billard") {
    if ((sym.var.x$var.type == "$I") && (sym.var.y$var.type == "$I")) {
      vx <- sym.var.x
      vy <- sym.var.y
      beta1 <- sym.cov(vx, vy, method = "billard") / sym.variance(vx, method = "billard")
      intercept <- sym.mean(vy) - beta1 * sym.mean(vx)
    }
    return(list(Intercept = intercept, Beta1 = beta1))
  }
}
#line 1 "/private/var/folders/x1/bc7ln59d11jddyfmvq0f4mwm0000gn/T/RtmpK8STdo/R.INSTALL582a7c381cc/RSDA/R/sym.mcfa.r"
#' sym.mcfa
#' @aliases sym.mcfa
#' @author Jorge Arce
#' @param sym.data A symbolic data table containing at least two set type variables.
#' @param pos.var Column numbers in the symbolic data table that contain the set type variables.
#' @description This function executes a Multiple Correspondence Factor Analysis for variables of set type.
#' @usage sym.mcfa(sym.data, pos.var)
#' @references  Arce J. and Rodriguez, O. (2018). Multiple Correspondence Analysis for Symbolic MultiValued Variables. On the Symbolic Data Analysis Workshop SDA 2018.
#'
#' Benzecri, J.P. (1973). L' Analyse des Donnes. Tomo 2: L'Analyse des Correspondances. Dunod, Paris.
#'
#' Castillo, W. and Rodriguez O. (1997). Algoritmo e implementacion del analisis factorial de correspondencias. Revista de Matematicas: Teoria y Aplicaciones, 24-31.
#'
#' Takagi I. and Yadosiha H. (2011). Correspondence Analysis for symbolic contingency tables base on interval algebra. Elsevier Procedia Computer Science, 6, 352-357.
#'
#' Rodriguez, O. (2007). Correspondence Analysis for Symbolic Multi--Valued Variables. CARME 2007 (Rotterdam, The Netherlands), http://www.carme-n.org/carme2007.
#'
#' @examples
#' data("ex_mcfa1")
#' sym.table <- classic.to.sym(ex_mcfa1, concept = "suspect",
#'                    variables.types = c(hair = type.set(),
#'                                        eyes = type.set(),
#'                                        region = type.set()))
#'
#' res <- sym.mcfa(sym.table, c(1,2))
#' mcfa.scatterplot(res[,1], res[,2], sym.data = sym.table, pos.var = c(1,2))
#'

sym.mcfa <- function (sym.data, pos.var)
{
  sym.data <- calc.burt.sym(sym.data, pos.var)
  idn <- all(sym.data$sym.var.types == sym.data$sym.var.types[1])
  if (idn == FALSE)
    stop("All variables have to be of the same type")
  res <- cfa.totals(sym.data)
  Z <- cfa.MatrixZ(sym.data, res$TotalRows, res$TotalColumns)
  svd <- eigen(Z)
  # se aplica cambio enviado por jorge
  svd$values <- svd$values*svd$values

  MVPRealz <- cfa.CVPRealz(sym.data, res$TotalRows, res$TotalColumns,
                           res$Total, svd$vectors)
  Mzz <- cfa.Czz(sym.data, res$TotalRows, res$TotalColumns,
                 MVPRealz, svd$values)
  CMM <- cfa.minmax.new(sym.data, res$TotalRows, res$TotalRowsMin,
                    res$TotalRowsMax, res$TotalColumns, res$TotalColumnsMin,
                    res$TotalColumnsMax, res$Total, MVPRealz, Mzz)
  n.sym.objects <- sym.data$N
  n.sym.var <- sym.data$M - 1
  sym.var.types <- list()
  sym.var.length <- rep(0, n.sym.var)
  sym.var.names <- list()
  sym.var.starts <- rep(0, n.sym.var)
  posd <- 1
  posdd <- 2
  for (ss in 1:n.sym.var) {
    sym.var.types[ss] <- "$I"
    sym.var.length[ss] <- 2
    sym.var.names[ss] <- paste("C", ss, sep = "")
    sym.var.starts[ss] <- posdd
    posd <- posd + 2
    posdd <- posdd + 3
  }
  sym.obj.names <- sym.data$sym.obj.names
  data.matrix <- matrix(0, n.sym.objects, 2 * n.sym.var)
  meta.data <- matrix(0, n.sym.objects, 2 * n.sym.var)
  for (i in 1:n.sym.objects) {
    posd <- 1
    for (j in 1:n.sym.var) {
      meta.data[i, posd] <- CMM$Min[i, j]
      meta.data[i, posd + 1] <- CMM$Max[i, j]
      data.matrix[i, posd] <- CMM$Min[i, j]
      data.matrix[i, posd + 1] <- CMM$Max[i, j]
      posd <- posd + 2
    }
  }
  col.types <- matrix(0, n.sym.objects, 1)
  for (ss in 1:n.sym.objects) {
    col.types[ss] <- "$I"
  }
  qq <- matrix(0, n.sym.objects, 3 * n.sym.var)
  qq <- cbind(col.types, meta.data[, 1:2])
  posd <- 3
  for (ss in 2:n.sym.var) {
    qq <- cbind(qq, col.types)
    qq <- cbind(qq, meta.data[, posd])
    qq <- cbind(qq, meta.data[, posd + 1])
    posd <- posd + 2
  }
  meta.data <- qq
  tt <- list()
  ttt <- list()
  posd <- 1
  posdd <- 1
  for (ss in 1:n.sym.var) {
    tt[posd] <- paste("C", ss, sep = "")
    tt[posd + 1] <- paste("C", ss, sep = "")
    posd <- posd + 2
    ttt[posdd] <- "$I"
    ttt[posdd + 1] <- paste("C", ss, sep = "")
    ttt[posdd + 2] <- paste("C", ss, sep = "")
    posdd <- posdd + 3
  }
  meta.data <- as.data.frame(meta.data)
  data.matrix <- as.data.frame(data.matrix)
  rownames(data.matrix) <- sym.obj.names
  colnames(data.matrix) <- tt
  rownames(meta.data) <- sym.obj.names
  colnames(meta.data) <- ttt
  posdd <- 1
  for (ss in 1:n.sym.var) {
    meta.data[, posdd + 1] <- as.numeric(as.vector(meta.data[,
                                                             posdd + 1]))
    meta.data[, posdd + 2] <- as.numeric(as.vector(meta.data[,
                                                             posdd + 2]))
    posdd <- posdd + 3
  }
  sym.data <- list(N = n.sym.objects, M = n.sym.var, sym.obj.names = sym.obj.names,
                   sym.var.names = unlist(sym.var.names), sym.var.types = unlist(sym.var.types),
                   sym.var.length = sym.var.length, sym.var.starts = unlist(sym.var.starts),
                   meta = meta.data, data = data.matrix)
  class(sym.data) <- "sym.data.table"
  return(sym.data)
}
#line 1 "/private/var/folders/x1/bc7ln59d11jddyfmvq0f4mwm0000gn/T/RtmpK8STdo/R.INSTALL582a7c381cc/RSDA/R/sym.mds.R"
#' Symbolic Multidemensional Scaling
#' @name sym.mds
#' @aliases sym.mds
#' @author Oldemar Rodriguez Rojas
#' @description This function execute a multidimensional scaling from a interval symbolic data matrix.
#' @usage sym.mds(sym.data, distance = c('hausdorff', 'centers'), p = 2,
#' method = c('classic', 'INTERSCAL'))
#' @param sym.data The symbolic data matrix.
#' @param distance The distance to be use.
#' @param p The p in the Hausdorff distance
#'
#' \deqn{d(w_{u_1},w_{u_2}) = \left( \sum_{j=1}^m \Phi_j(w_{u_1},w_{u_2})^p  \right)^{1/p}}
#' @param method The method to be used.
#'
#' @return Return the coordanates to plot the graphic.
#' @references Groenen, P.J.F., Winsberg, S., Rodriguez, O., Diday, E. (2006). I-Scal: Multidimensional
#' scaling of interval dissimilarities. Computational Statistics and Data Analysis, 51,
#' 360-378.
#'
#' Rodriguez, O. (2000).
#' Classification et Modeles Lineaires en Analyse des Donnees Symboliques. Ph.D. Thesis,
#' Paris IX-Dauphine University.
#' @seealso sym.interval.pca
#' @examples
#' \dontrun{
#' data(oils)
#' res<-sym.mds(oils)
#' plot(res,pch = 23, bg = 'red', xlab = 'Score 1', ylab = 'Score 2')
#' res<-sym.mds(oils,distance='centers')
#' plot(res,pch = 23, bg = 'red', xlab = 'Score 1', ylab = 'Score 2')
#' }
#' @keywords Symbolic MDS
#' @export
#'
sym.mds <- function(sym.data, distance = c("hausdorff", "centers"), p = 2, method = c(
                      "classic",
                      "INTERSCAL"
                    )) {
  distance <- match.arg(distance)
  method <- match.arg(method)
  if (method == "classic") {
    return(cmdscale(interval.dist(sym.data, distance)))
  }
}
#line 1 "/private/var/folders/x1/bc7ln59d11jddyfmvq0f4mwm0000gn/T/RtmpK8STdo/R.INSTALL582a7c381cc/RSDA/R/sym.mean.R"
#' Symbolic Mean
#' @name sym.mean
#' @aliases sym.mean
#' @author Oldemar Rodriguez Rojas
#' @description This function compute the symbolic mean
#' @usage sym.mean(sym.var, method = c('centers', 'interval', 'modal'),
#' trim = 0, na.rm = FALSE, ...)
#' @param sym.var The symbolic variable.
#' @param method The method to be use.
#' @param trim As in R mean function.
#' @param na.rm As in R mean function.
#' @param ... As in R mean function.
#'
#' @return Return a real number.
#' @references
#' Billard L. and  Diday E. (2006).
#' Symbolic data analysis: Conceptual statistics and data mining. Wiley, Chichester.
#'
#' Rodriguez, O. (2000).
#' Classification et Modeles Lineaires en Analyse des Donnees Symboliques. Ph.D. Thesis,
#' Paris IX-Dauphine University.
#'
#' @examples
#' data(example3)
#' sym.data<-example3
#' sym.mean(sym.var(sym.data,1))
#' sym.mean(sym.var(sym.data,2))
#' sym.mean(sym.var(sym.data,2),method='interval')
#' sym.mean(sym.var(sym.data,3),method='modal')
#'
#' @keywords Symbolic Mean
#' @export
#'
#'
sym.mean <- function(sym.var, method = c("centers", "interval", "modal"), trim = 0,
                     na.rm = FALSE, ...) {
  method <- match.arg(method)
  if (method == "centers") {
    if (sym.var$var.type == "$C") {
      return(mean(sym.var$var.data.vector, trim, na.rm))
    }
    if (sym.var$var.type == "$I") {
      return(mean((sym.var$var.data.vector[, 1] + sym.var$var.data.vector[, 2]) / 2))
    } else {
      stop("Impossible to compute the mean for this type of variable with this method")
    }
  }
  if (method == "interval") {
    if (sym.var$var.type == "$I") {
      return(colMeans(sym.var$var.data.vector))
    } else {
      stop("Impossible to compute the mean for this type of variable with this method")
    }
  }
  if (method == "modal") {
    if (sym.var$var.type == "$M") {
      return(colMeans(sym.var$var.data.vector))
    } else {
      stop("Impossible to compute the mean for this type of variable with this method")
    }
  }
}
#line 1 "/private/var/folders/x1/bc7ln59d11jddyfmvq0f4mwm0000gn/T/RtmpK8STdo/R.INSTALL582a7c381cc/RSDA/R/sym.median.R"
#' Symbolic Median
#' @name sym.median
#' @aliases sym.median
#' @author Oldemar Rodriguez Rojas
#' @description This function compute the symbolic median.
#' @usage sym.median(sym.var, method = c('centers', 'interval', 'modal'), na.rm = FALSE, ...)
#' @param sym.var The symbolic variable.
#' @param method The method to be use.
#' @param na.rm As in R median function.
#' @param ... As in R median function.
#'
#' @return Return a real number.
#' @references
#' Billard L. and  Diday E. (2006).
#' Symbolic data analysis: Conceptual statistics and data mining. Wiley, Chichester.
#'
#' Rodriguez, O. (2000).
#' Classification et Modeles Lineaires en Analyse des Donnees Symboliques. Ph.D. Thesis,
#' Paris IX-Dauphine University.
#'
#' @examples
#' data(example3)
#' sym.data<-example3
#' sym.median(sym.var(sym.data,1))
#' sym.median(sym.var(sym.data,2))
#' sym.median(sym.var(sym.data,6),method='interval')
#' sym.median(sym.var(sym.data,3),method='modal')
#' @keywords Symbolic Median
#' @export
#'
sym.median <- function(sym.var, method = c("centers", "interval", "modal"), na.rm = FALSE,
                       ...) {
  method <- match.arg(method)
  if (method == "centers") {
    if (sym.var$var.type == "$C") {
      return(median(sym.var$var.data.vector, na.rm))
    }
    if (sym.var$var.type == "$I") {
      return(median(sym.var$var.data.vector[, 1] + sym.var$var.data.vector[
        ,
        2
      ]) / 2)
    } else {
      stop("Impossible to compute the median for this type of variable with this method")
    }
  }
  if (method == "interval") {
    if (sym.var$var.type == "$I") {
      return(sapply(sym.var$var.data.vector, median))
    } else {
      stop("Impossible to compute the median for this type of variable with this method")
    }
  }
  if (method == "modal") {
    if (sym.var$var.type == "$M") {
      return(sapply(sym.var$var.data.vector, median))
    } else {
      stop("Impossible to compute the median for this type of variable with this method")
    }
  }
}
#line 1 "/private/var/folders/x1/bc7ln59d11jddyfmvq0f4mwm0000gn/T/RtmpK8STdo/R.INSTALL582a7c381cc/RSDA/R/sym.modal.plot.R"
#' sym.modal.plot
#' @keywords internal
sym.modal.plot <- function(info, col=c("blue"), border=FALSE, show.type = TRUE, reduce=FALSE) {
  if (info$sym.var.types != "$M") { # El tipo de dato es el incorrecto
    stop("The data type is wrong, only $M are accepted")
  }

  mt <- info$data # obenemos los datos
  names <- colnames(info$data) # obtenemos los nombres

  if (reduce) { # Si el modo reduce esta activado
    if (any(mt == 0)) { # Si alguna de las columnas tiene cero
      mt <- cbind(mt[, select <- colSums(mt) != 0], 0) # Se crea "select" (las columnas con valores mayores a cero),
      # se seleccionan los valores mayores a cero y
      # se les agraga una columna extra en cero(representativa de los valores en cero)
      names <- c(names[select], "...") # Se seleccionan los nombres de columnas con valores distintos de cero y
      # se crea el nombre de la columna representativa
      col <- col[select] # selecciona los colores corespondientes
    }
  }
  mt <- as.matrix(mt) # obligatorio

  # graficamos las barras
  graphics::barplot(mt,
    main = paste(info$sym.var.names, ifelse(show.type, " (Modal)", "")), xlab = "", ylab = "", yaxt = "n",
    col = col, beside = TRUE, names.arg = names, cex.names = .8, space = c(0, 0.05)
  )
  graphics::axis(2, at = seq(0, 1, 0.2), labels = sprintf(round(seq(0, 100, 20)), fmt = "%2.f%%"), las = 1) # los y labels con %

  if (border) { # se pone el borde en negro
    box("figure", col = "black")
  }
}
#line 1 "/private/var/folders/x1/bc7ln59d11jddyfmvq0f4mwm0000gn/T/RtmpK8STdo/R.INSTALL582a7c381cc/RSDA/R/sym.normalize.R"
#' sym.normalize
#' @keywords internal
sym.normalize <- function(sym.data) {
  nn <- sym.data$N
  mm <- sym.data$M
  pos <- 1
  for (j in 1:mm) {
    sdc <- sym.sd(sym.var(sym.data, j))
    mc <- sym.mean(sym.var(sym.data, j))
    for (i in 1:nn) {
      sym.data$meta[i, sym.data$sym.var.starts[j]] <- (sym.data$meta[i, sym.data$sym.var.starts[j]] -
        mc) / sdc
      sym.data$meta[i, sym.data$sym.var.starts[j] + 1] <- (sym.data$meta[i, sym.data$sym.var.starts[j] +
        1] - mc) / sdc
      sym.data$data[i, pos] <- (sym.data$data[i, pos] - mc) / sdc
      sym.data$data[i, pos + 1] <- (sym.data$data[i, pos + 1] - mc) / sdc
    }
    pos <- pos + 2
  }
  return(sym.data)
}
#line 1 "/private/var/folders/x1/bc7ln59d11jddyfmvq0f4mwm0000gn/T/RtmpK8STdo/R.INSTALL582a7c381cc/RSDA/R/sym.obj.R"
#' Symbolic Object
#' @name sym.obj
#' @aliases sym.obj
#' @author Oldemar Rodriguez Rojas
#' @description This function get a symbolic object (row or a case) from a symbolic data table.
#' @usage sym.obj(sym.data, number.sym.obj)
#' @param sym.data Symboli data matrix.
#' @param number.sym.obj The number of the row for the symbolic object (case) that we want to get.
#'
#' @return
#' Return a symbolic object with the following internal format: \cr
#'
#' $M\cr
#'
#' [1] 5\cr
#'
#' $var.types\cr
#'
#' [1] '$C' '$H' '$I' '$H' '$C'\cr
#'
#' $var.length\cr
#'
#' [1] 1 5 2 3 1\cr
#'
#' $var.names\cr
#'
#' [1] 'F1' 'F2' 'F3' 'F4' 'F5'\cr
#'
#' $obj.data.vector\cr
#'
#' F1  M1  M2  M3  M4  M5 F3 F3.1 M1.1 M2.1 M3.1 F5\cr
#'
#' Case4 -2.1 0.4 0.1 0.1 0.1 0.3  0    2  0.9    0  0.1  0\cr
#' @references
#' Billard L. and  Diday E. (2006).
#' Symbolic data analysis: Conceptual statistics and data mining. Wiley, Chichester.
#'
#' Bock H-H. and Diday E. (eds.) (2000).
#' Analysis of Symbolic Data. Exploratory methods for extracting statistical information
#' from complex data. Springer, Germany.
#'
#' @examples
#' data(example7)
#' sym.obj(example7,4)
#' @keywords Symbolic Object
#' @export
#'
sym.obj <- function(sym.data, number.sym.obj) {
  if ((number.sym.obj > sym.data$N) || (number.sym.obj <= 0)) {
    stop("number.sym.obj out of range")
  }
  sym.obj <- list(
    M = sym.data$M, var.types = sym.data$sym.var.types, var.length = sym.data$sym.var.length,
    var.names = sym.data$sym.var.names, obj.data.vector = sym.data$data[number.sym.obj, ]
  )
  return(sym.obj)
}
#line 1 "/private/var/folders/x1/bc7ln59d11jddyfmvq0f4mwm0000gn/T/RtmpK8STdo/R.INSTALL582a7c381cc/RSDA/R/sym.radar.plot.R"
#' Internal sym.radar.plot the distence between two rows
#' @keywords internal
#' Radar Plot For Symbolic Interval Variables
#'
#' @param dat The symbolic data.
#' @param rad.main the title of the final plot (optional).
#' @param indivs an array that indicates which individuals to use (optional).
#' @param vars an array that indicates which variables to use (optional).
#' @param use.pct a logical value indicating if use percentage or real distance for plot.
#'
#' @return A radar plot.
#' @export
#'
sym.radar.plot <- function(dat, indivs, vars, rad.main = "", rad.legend = "Individuals", use.pct = F) {
  nom.vars <- dat$sym.var.names # Takes the names of the variables
  dat <- dat$data # Takes the dataset of the symbolic data.
  if (!missing(indivs)) {
    dat <- dat[indivs, ] # If individuals given, take just that indiduals for the analysis.
  }
  if (!missing(vars)) {
    if (length(vars) <= 2) {
      stop("You must specify 3 or more variables in vars")
    }
    nom.vars <- nom.vars[vars] # If variables given, take just that variables names for the analysis.
    vars <- sort(c(2 * vars - 1, 2 * vars))
    dat <- dat[, vars] # If variables given, take just that variables for the analysis.
  }

  dat <- sym.radar.data(dat, nom.vars, use.pct) # Turn dataset to a molten data.

  # Plot the radar plot with the points of the intervals.
  res.radar <- ggplot(dat, aes(x = Variables, y = value)) +
    geom_point(aes(color = Individuals), size = 1) +
    theme(
      panel.background = element_rect(fill = "transparent"),
      plot.background = element_rect(fill = "transparent"),
      panel.grid.major = element_line(size = 0.5, linetype = "solid", colour = "#dddddd"),
      axis.text.x = element_text(size = rel(1.2)),
      axis.text.y = element_blank(),
      axis.ticks = element_blank()
    ) +
    scale_y_continuous(limits = c(-0.3, 1.1), breaks = c(0, 0.25, 0.5, 0.75, 1)) +
    ggtitle(rad.main) + xlab("") + ylab("") +
    coord_radar()

  # Lables with some values of the intervals are added.
  if (use.pct) {
    plots <- list()
    for (i in unique(dat$pos.var)) {
      res.radar <- res.radar +
        geom_text(aes_string(x = i, y = -0.1, label = round(min(dat[dat$pos.var == i, ]$real.value), 3)), size = 3, colour = "gray", family = "Arial") +
        geom_text(aes_string(x = i, y = 1.1, label = round(max(dat[dat$pos.var == i, ]$real.value), 3)), size = 3, colour = "gray", family = "Arial")
    }
  } else {
    res.radar <- res.radar +
      geom_text(aes(x = 0.5, y = 0, label = round(min(dat$real.value), 3)), size = 3, colour = "gray", family = "Arial") +
      geom_text(aes(x = 0.5, y = 0.25, label = inverse.rescale(0.25, dat$real.value)), size = 3, colour = "gray", family = "Arial") +
      geom_text(aes(x = 0.5, y = 0.5, label = inverse.rescale(0.5, dat$real.value)), size = 3, colour = "gray", family = "Arial") +
      geom_text(aes(x = 0.5, y = 0.75, label = inverse.rescale(0.75, dat$real.value)), size = 3, colour = "gray", family = "Arial") +
      geom_text(aes(x = 0.5, y = 1, label = round(max(dat$real.value), 3)), size = 3, colour = "gray", family = "Arial")
  }

  # Paths which connect the points of the interval are added.
  res.radar + ggpolypath::geom_polypath(data = dat, aes(x = pos.var, y = value, fill = Individuals), alpha = 0.3, rule = "evenodd") +
    scale_fill_discrete(name = rad.legend) + scale_color_discrete(name = rad.legend)
}

#' Internal sym.radar.data
#' @keywords internal
#' Molten data for radar plot
#'
#' @param dat The symbolic data.
#' @param nom.vars Names of the variables.
#' @param use.pct a logical value indicating if use percentage or real distance for plot.
#'
#' @return A molten data.
#' @export
#'
sym.radar.data <- function(dat, nom.vars, use.pct = F) {
  n <- ncol(dat) # Number of variables (2 for each variable (minimum and maximum)).
  m <- n / 2 # Number of variables (Real number).
  datos.L <- dat[, seq(1, n, 2)] # Takes the minimum values of the dataset
  datos.R <- dat[, seq(2, n, 2)] # Takes the maximum values of the dataset
  colnames(datos.R) <- nom.vars # Names of the variables are placed to the dataset of minimum.
  colnames(datos.L) <- nom.vars # Names of the variables are placed to the dataset of maximum.
  datos.L <- reshape::melt(t(datos.L), varnames = c("Variables", "Individuals")) # Turn the dataset to a molten data
  datos.R <- reshape::melt(t(datos.R), varnames = c("Variables", "Individuals")) # Turn the dataset to a molten data
  datos.L <- datos.L[order(datos.L$Individuals, datos.L$Variables), ] # Sort the dataset
  datos.R <- datos.R[order(datos.R$Individuals, datos.R$Variables), ] # Sort the dataset
  datos.L <- cbind(datos.L, c(1:m)) # Add a column with the position of each variable
  datos.R <- cbind(datos.R, c(1:m)) # Add a column with the position of each variable
  colnames(datos.L)[ncol(datos.L)] <- "pos.var" # Give a name to the column
  colnames(datos.R)[ncol(datos.R)] <- "pos.var" # Give a name to the column
  # Merge the datasets and adds rows with the values of the first variable for each individual (It is necessary to the radar plot).
  dat <- rbind(datos.R, datos.R[seq(1, nrow(datos.R), m), ], datos.L, datos.L[seq(1, nrow(datos.L), m), ])
  rm(list = c(c("datos.L"), c("datos.R")))
  real.value <- dat$value
  if (use.pct) {
    for (name.var in unique(dat$Variables)) {
      # Rescale the values between 0 and 1 for each variable.
      dat$value[dat$Variables == name.var] <- rescale(dat$value[dat$Variables == name.var], to = c(0, 1))
    }
  } else {
    dat$value <- scales::rescale(dat$value, to = c(0, 1)) # Rescale the values between 0 and 1 for all the dataset.
  }


  dat <- cbind(dat, real.value) # Add a column with the real values.

  # Fix the type of data if is not correctly.
  if (!is.factor(dat$Variables)) dat$Variables <- as.factor(dat$Variables)
  if (!is.factor(dat$Individuals)) dat$Individuals <- as.factor(dat$Individuals)
  if (!is.numeric(dat$value)) dat$value <- as.numeric(dat$value)
  if (!is.numeric(dat$pos.var)) dat$pos.var <- as.numeric(dat$pos.var)

  return(dat)
}

# Turns the rescale value to the real value.
inverse.rescale <- function(pct, values) {
  return(round((pct * (max(values) - min(values))) + min(values), 3))
}

# Function required to make the radar plot
coord_radar <- function(theta = "x", start = 0, direction = 1) {
  theta <- match.arg(theta, c("x", "y"))
  r <- if (theta == "x") "y" else "x"
  ggproto("CordRadar", CoordPolar, theta = theta, r = r, start = start, direction = sign(direction), is_linear = function(coord) TRUE)
}
#line 1 "/private/var/folders/x1/bc7ln59d11jddyfmvq0f4mwm0000gn/T/RtmpK8STdo/R.INSTALL582a7c381cc/RSDA/R/sym.scale.interval.j.r"
sym.scale.interval <- function(sym.data, mean.var, desv.var) {
  data <- sym.data$data
  M <- sym.data$M
  for (i in 1:M) {
    indx <- (2 * i - 1):(2 * i)
    data[, indx] <- (data[, indx] - mean.var[i]) / desv.var[i]
  }
  return(data)
}
#line 1 "/private/var/folders/x1/bc7ln59d11jddyfmvq0f4mwm0000gn/T/RtmpK8STdo/R.INSTALL582a7c381cc/RSDA/R/sym.scatterplot.R"
#' Symbolic Scatter Plot
#' @name sym.scatterplot
#' @aliases sym.scatterplot
#' @author Oldemar Rodriguez Rojas
#' @description This function could be use to plot two symbolic variables in a X-Y plane.
#' @usage sym.scatterplot(sym.var.x, sym.var.y, labels = FALSE, ...)
#' @param sym.var.x First symbolic variable
#' @param sym.var.y Second symbolic variable.
#' @param labels As in R plot function.
#' @param ... As in R plot function.
#'
#' @return Return a graphics.
#' @references
#' Bock H-H. and Diday E. (eds.) (2000).
#' Analysis of Symbolic Data. Exploratory methods for extracting statistical information
#' from complex data. Springer, Germany.
#'
#' Rodriguez, O. (2000).
#' Classification et Modeles Lineaires en Analyse des Donnees Symboliques. Ph.D. Thesis,
#' Paris IX-Dauphine University.
#' @seealso sym.scatterplot3d
#' @examples
#' data(example3)
#' sym.data <- example3
#' class(sym.data) <- c('sym.data.table')
#' sym.scatterplot(sym.data[,1], sym.data[,4],col='blue',
#'                 main='Main Title')
#' sym.scatterplot(sym.data[,1], sym.data[,4],labels=TRUE,col='blue',
#'                 main='Main Title')
#' sym.scatterplot(sym.data[,2], sym.data[,6],labels=TRUE,
#'                 col='red',main='Main Title',lwd=3)
#'
#' data(oils)
#' sym.scatterplot(oils[,2],oils[,3],labels=TRUE,
#'                 col='red',main='Oils Data')
#' data(lynne1)
#'
#' sym.scatterplot(lynne1[,2],lynne1[,1],labels=TRUE,
#'                 col='red',main='Lynne Data')
#'
#' @keywords Symbolic Plot
#' @export
#'
sym.scatterplot <- function(sym.var.x, sym.var.y, labels = FALSE, ...) {
  if (((sym.var.x$sym.var.types != "$C") || (sym.var.y$sym.var.types != "$C")) &&
    ((sym.var.x$sym.var.types != "$I") || (sym.var.y$sym.var.types != "$I"))) {
    stop("Impossible to plot this type of variable")
  }


  if ((sym.var.x$sym.var.types == "$C") && (sym.var.y$sym.var.types == "$C")) {
    if (labels == FALSE) {
      plot(sym.var.x$data[, 1], sym.var.y$data[, 1],
        xlab = sym.var.x$sym.var.names,
        ylab = sym.var.y$sym.var.names, ...
      )
    } else {
      ltext <- sym.var.x$sym.var.names
      plot(sym.var.x$data[, 1], sym.var.y$data[, 1],
        type = "n", xlab = sym.var.x$sym.var.names,
        ylab = sym.var.y$sym.var.names, ...
      )
      text(sym.var.x$data[, 1], sym.var.y$data[, 1], ltext)
    }
  }
  if ((sym.var.x$sym.var.types == "$I") && (sym.var.y$sym.var.types == "$I")) {
    xmin1 <- min(sym.var.x$data[, 1])
    xmin2 <- min(sym.var.x$data[, 2])
    xmin <- min(xmin1, xmin2)
    xmax1 <- max(sym.var.x$data[, 1])
    xmax2 <- max(sym.var.x$data[, 2])
    xmax <- max(xmax1, xmax2)
    ymin1 <- min(sym.var.y$data[, 1])
    ymin2 <- min(sym.var.y$data[, 2])
    ymin <- min(ymin1, ymin2)
    ymax1 <- max(sym.var.y$data[, 1])
    ymax2 <- max(sym.var.y$data[, 2])
    ymax <- max(ymax1, ymax2)
    plot(c(xmin, xmax), c(ymin, ymax),
      type = "n", xlab = sym.var.x$sym.var.names,
      ylab = sym.var.y$sym.var.names, ...
    )
    for (i in 1:sym.var.x$N) {
      x1 <- sym.var.x$data[i, 1]
      y1 <- sym.var.y$data[i, 1]
      x2 <- sym.var.x$data[i, 2]
      y2 <- sym.var.y$data[i, 2]
      rect(x1, y1, x2, y2, lwd = 2, border = i + 1)
    }
    if (labels == TRUE) {
      ltext <- sym.var.x$sym.obj.names
      text(jitter(sym.var.x$data[, 1]), jitter(sym.var.y$data[, 1]), ltext)
    }
  }
}
#line 1 "/private/var/folders/x1/bc7ln59d11jddyfmvq0f4mwm0000gn/T/RtmpK8STdo/R.INSTALL582a7c381cc/RSDA/R/sym.scatterplot.ggplot.R"
#' Symbolic Scatter GGPlot
#' @name sym.scatterplot.ggplot
#' @aliases sym.scatterplot.ggplot
#' @author Oldemar Rodriguez Rojas
#' @description This function could be use to plot two symbolic variables in a X-Y plane using ggplot
#' R package.
#' @usage sym.scatterplot.ggplot(sym.var.x, sym.var.y, labels = FALSE, ...)
#' @param sym.var.x First symbolic variable.
#' @param sym.var.y Second symbolic variable.
#' @param labels As in ggplot.
#' @param ... As in ggplot.
#'
#' @return return a ggplot graphic.
#' @references
#' Bock H-H. and Diday E. (eds.) (2000).
#' Analysis of Symbolic Data. Exploratory methods for extracting statistical information
#' from complex data. Springer, Germany.
#'
#' Rodriguez, O. (2000).
#' Classification et Modeles Lineaires en Analyse des Donnees Symboliques. Ph.D. Thesis,
#' Paris IX-Dauphine University.
#' @seealso sym.scatterplot
#' @examples
#' data(lynne1)
#' class(lynne1) <- c('sym.data.table')
#' sym.scatterplot.ggplot(lynne1[,1], lynne1[,3],labels=TRUE)
#' data(oils)
#' sym.scatterplot.ggplot(oils[,2], oils[,3],labels=TRUE)
#' @keywords Symbolic ggplot
#' @export
#' @import ggplot2
#'
sym.scatterplot.ggplot <- function(sym.var.x, sym.var.y, labels = FALSE, ...) {
  x <- 0
  y <- 0
  xmin <- 0
  xmax <- 0
  ymin <- 0
  ymax <- 0
  if (((sym.var.x$sym.var.types != "$C") || (sym.var.y$sym.var.types != "$C")) &&
    ((sym.var.x$sym.var.types != "$I") || (sym.var.y$sym.var.types != "$I"))) {
    stop("Impossible to plot this type of variable")
  }
  if ((sym.var.x$sym.var.types == "$C") && (sym.var.y$sym.var.types == "$C")) {
    df <- data.frame(sym.var.x$data, sym.var.y$data)
    names(df) <- c("x", "y")
    p <- ggplot(df, aes(x, y)) + labs(x = sym.var.x$sym.var.names, y = sym.var.y$sym.var.names)
    if (labels == FALSE) {
      p <- p + geom_point()
    } else {
      ltext <- sym.var.x$sym.obj.names
      p <- p + geom_text(label = ltext)
    }
  }
  if ((sym.var.x$sym.var.types == "$I") && (sym.var.y$sym.var.types == "$I")) {
    df <- data.frame(sym.var.x$data, sym.var.y$data)
    names(df) <- c("xmin", "xmax", "ymin", "ymax")
    p <- ggplot(df) + labs(x = sym.var.x$sym.var.names, y = sym.var.y$sym.var.names) +
      geom_rect(
        data = df, aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),
        fill = alpha(1:sym.var.x$N, 2 / 3)
      )

    if (labels == TRUE) {
      ltext <- sym.var.x$sym.obj.names
      p <- p + geom_text(aes((xmin + xmax) / 2, (ymin + ymax) / 2), label = ltext)
    }
  }
  print(p)
  invisible(p)
}
#line 1 "/private/var/folders/x1/bc7ln59d11jddyfmvq0f4mwm0000gn/T/RtmpK8STdo/R.INSTALL582a7c381cc/RSDA/R/sym.scatterplot3d.R"
#' Symbolic Scatter Plot 3D
#' @name sym.scatterplot3d
#' @aliases sym.scatterplot3d
#' @author Oldemar Rodriguez Rojas
#' @description This function could be use to plot two symbolic variables in 3D i.e. in a X-Y-Z plane.
#' @usage sym.scatterplot3d(sym.var.x, sym.var.y, sym.var.z, labels = FALSE, ...)
#' @param sym.var.x First symbolic variable.
#' @param sym.var.y Second symbolic variable.
#' @param sym.var.z Third symbolic variable.
#' @param labels As in R plot function.
#' @param ... As in R plot function.
#'
#' @return 3D Plot graphic.
#' @references
#' Bock H-H. and Diday E. (eds.) (2000).
#' Analysis of Symbolic Data. Exploratory methods for extracting statistical information
#' from complex data. Springer, Germany.
#'
#' @examples
#' data(lynne1)
#' class(lynne1) <- c('sym.data.table')
#' sym.scatterplot3d(lynne1[,1], lynne1[,2], lynne1[,3],
#'                  color='blue', main='Lynne Data')
#' @keywords Symbolic 3DPlot
#' @export
#' @importFrom scatterplot3d scatterplot3d
#'
sym.scatterplot3d <- function(sym.var.x, sym.var.y, sym.var.z, labels = FALSE, ...) {
  if (((sym.var.x$sym.var.types != "$C") || (sym.var.y$sym.var.types != "$C") ||
    (sym.var.z$sym.var.types != "$C")) && ((sym.var.x$sym.var.types != "$I") ||
    (sym.var.y$sym.var.types != "$I") || (sym.var.y$sym.var.types != "$I"))) {
    stop("Impossible to plot this type of variable")
  }
  if ((sym.var.x$sym.var.types == "$C") && (sym.var.y$sym.var.types == "$C") && (sym.var.z$sym.var.types ==
    "$C")) {
    if (labels == FALSE) {
      p <- scatterplot3d(sym.var.x$data[, 1], sym.var.y$data[, 1], sym.var.z$data[
        ,
        1
      ],
      xlab = sym.var.x$sym.var.names, ylab = sym.var.y$sym.var.names,
      zlab = sym.var.z$sym.var.names, ...
      )
    } else {
      p <- scatterplot3d(sym.var.x$data[, 1], sym.var.y$data[, 1], sym.var.z$data[
        ,
        1
      ],
      xlab = sym.var.x$sym.var.names, ylab = sym.var.y$sym.var.names,
      zlab = sym.var.z$sym.var.names, type = "n", ...
      )
      ltext <- sym.var.x$sym.obj.names
      text(p$xyz.convert(sym.var.x$data[, 1], sym.var.y$data[, 1], sym.var.z$data[
        ,
        1
      ]), labels = ltext)
    }
  }
  if ((sym.var.x$sym.var.types == "$I") && (sym.var.y$sym.var.types == "$I") && (sym.var.z$sym.var.types ==
    "$I")) {
    xmin1 <- min(sym.var.x$data[, 1])
    xmin2 <- min(sym.var.x$data[, 2])
    xmin <- min(xmin1, xmin2)
    xmax1 <- max(sym.var.x$data[, 1])
    xmax2 <- max(sym.var.x$data[, 2])
    xmax <- max(xmax1, xmax2)
    ymin1 <- min(sym.var.y$data[, 1])
    ymin2 <- min(sym.var.y$data[, 2])
    ymin <- min(ymin1, ymin2)
    ymax1 <- max(sym.var.y$data[, 1])
    ymax2 <- max(sym.var.y$data[, 2])
    ymax <- max(ymax1, ymax2)
    zmin1 <- min(sym.var.z$data[, 1])
    zmin2 <- min(sym.var.z$data[, 2])
    zmin <- min(zmin1, zmin2)
    zmax1 <- max(sym.var.z$data[, 1])
    zmax2 <- max(sym.var.z$data[, 2])
    zmax <- max(zmax1, zmax2)
    p <- scatterplot3d(c(xmin, xmax), c(ymin, ymax), c(zmin, zmax),
      xlab = sym.var.x$sym.var.names,
      ylab = sym.var.y$sym.var.names, zlab = sym.var.z$sym.var.names, type = "n",
      ...
    )
    cube <- rbind(c(1, 1, 1), c(2, 1, 1), c(2, 1, 2), c(1, 1, 2), c(1, 1, 1), c(
      1,
      2, 1
    ), c(1, 2, 2), c(2, 2, 2), c(2, 2, 1), c(1, 2, 1), c(1, 2, 2), c(
      1,
      1, 2
    ), c(2, 1, 2), c(2, 2, 2), c(2, 2, 1), c(2, 1, 1))
    for (i in 1:sym.var.x$N) {
      vec.x <- sym.var.x$data[i, cube[, 1]]
      vec.y <- sym.var.y$data[i, cube[, 2]]
      vec.z <- sym.var.z$data[i, cube[, 3]]

      p$points3d(vec.x, vec.y, vec.z, type = "l", lty = 1, col = i + 1)
    }
    if (labels == TRUE) {
      ltext <- sym.var.x$sym.obj.names
      textPoints <- cbind((sym.var.x$data[, 1] + sym.var.x$data[, 2]) / 2, (sym.var.y$data[
        ,
        1
      ] + sym.var.y$data[, 2]) / 2, (sym.var.z$data[, 1] + sym.var.z$data[
        ,
        2
      ]) / 2)
      text(p$xyz.convert(textPoints), labels = ltext)
    }
  }
}
#line 1 "/private/var/folders/x1/bc7ln59d11jddyfmvq0f4mwm0000gn/T/RtmpK8STdo/R.INSTALL582a7c381cc/RSDA/R/sym.sd.R"
#' Symbolic Standard Desviation
#' @name sym.sd
#' @aliases sym.sd
#' @author Oldemar Rodriguez Rojas
#' @description Compute the symbolic standard desviation.
#' @usage sym.sd(sym.var, method =
#' c('centers', 'interval', 'billard', 'modal'), na.rm = FALSE, ...)
#' @param sym.var The symbolic variable.
#' @param method The method to be use.
#' @param na.rm As in R sd function.
#' @param ... As in R sd function.
#'
#' @return return a real number.
#' @references Billard L. and  Diday E. (2006).
#' Symbolic data analysis: Conceptual statistics and data mining. Wiley, Chichester.
#'
#' Rodriguez, O. (2000).
#' Classification et Modeles Lineaires en Analyse des Donnees Symboliques. Ph.D. Thesis,
#' Paris IX-Dauphine University.
#'
#' @examples
#' data(example3)
#' sym.data<-example3
#' sym.sd(sym.var(sym.data,1))
#' sym.sd(sym.var(sym.data,2))
#' sym.sd(sym.var(sym.data,6))
#' sym.sd(sym.var(sym.data,6),method='interval')
#' sym.sd(sym.var(sym.data,6),method='billard')
#' sym.sd(sym.var(sym.data,3),method='modal')
#' @keywords Symbolic sd
#' @export
#'
sym.sd <- function(sym.var, method = c("centers", "interval", "billard", "modal"),
                   na.rm = FALSE, ...) {
  method <- match.arg(method)
  if (method == "centers") {
    if (sym.var$var.type == "$C") {
      return(sd(sym.var$var.data.vector))
    }
    if (sym.var$var.type == "$I") {
      return(sd(sym.var$var.data.vector[, 1] + sym.var$var.data.vector[, 2]) / 2)
    } else {
      stop("Impossible to compute the Standard Deviation for this type of variable with this method")
    }
  }
  if (method == "interval") {
    if (sym.var$var.type == "$I") {
      return(sapply(sym.var$var.data.vector, sd))
    } else {
      stop("Impossible to compute the Standard Deviation for this type of variable with this method")
    }
  }
  if (method == "billard") {
    if (sym.var$var.type == "$I") {
      return(sqrt((1 / (3 * sym.var$N)) * sum(sym.var$var.data.vector[, 1]^2 +
        (sym.var$var.data.vector[, 1] * sym.var$var.data.vector[, 2]) + sym.var$var.data.vector[
          ,
          2
        ]^2) - (1 / (4 * (sym.var$N)^2)) * sum(sym.var$var.data.vector[, 1] +
        sym.var$var.data.vector[, 2])^2))
    } else {
      stop("Impossible to compute the Standard Deviation for this type of variable with this method")
    }
  }
  if (method == "modal") {
    if (sym.var$var.type == "$M") {
      return(sapply(sym.var$var.data.vector, sd))
    } else {
      stop("Impossible to compute the Standard Deviation for this type of variable with this method")
    }
  }
}
#line 1 "/private/var/folders/x1/bc7ln59d11jddyfmvq0f4mwm0000gn/T/RtmpK8STdo/R.INSTALL582a7c381cc/RSDA/R/sym.set.plot.R"
#' sym.set.plot
#' @keywords internal
sym.set.plot <- function(info, col=c("blue"), border=FALSE, show.type = TRUE, reduce=FALSE) {
  if (info$sym.var.types != "$S") { # El tipo de dato es el incorrecto
    stop("The data type is wrong, only $S are accepted")
  }

  mt <- info$data # obenemos los datos
  mt[, mt > 0] <- 1 / sum(mt > 0) # arreglamos la escala de los set.
  names <- colnames(info$data) # obtenemos los nombres

  if (reduce) { # Si el modo reduce esta activado
    if (any(mt == 0)) { # Si alguna de las columnas tiene cero
      mt <- cbind(mt[, select <- colSums(mt) != 0], 0) # Se crea "select" (las columnas con valores mayores a cero),
      # se seleccionan los valores mayores a cero y
      # se les agraga una columna extra en cero(representativa de los valores en cero)
      names <- c(names[select], "...") # Se seleccionan los nombres de columnas con valores distintos de cero y
      # se crea el nombre de la columna representativa
      col <- col[select] # selecciona los colores corespondientes
    }
  }

  mt <- as.matrix(mt) # obligatorio

  # graficamos las barras
  barplot(mt,
    main = paste(info$sym.var.names, ifelse(show.type, " (Set)", "")), xlab = "", ylab = "", yaxt = "n",
    names.arg = names, ylim = c(0, ifelse(max(mt) < 0.5, 0.5, 1)), beside = TRUE, col = col, cex.names = .8
  )
  graphics::axis(2, at = seq(0, 1, 0.2), labels = sprintf(round(seq(0, 100, 20)), fmt = "%2.f%%"), las = 1) # los y labels con %

  if (border) { # se pone el borde en negro
    box("figure", col = "black")
  }
}
#line 1 "/private/var/folders/x1/bc7ln59d11jddyfmvq0f4mwm0000gn/T/RtmpK8STdo/R.INSTALL582a7c381cc/RSDA/R/sym.table.to.latex.j.r"
#' sym.table.latex
#' @keywords internal
sym.table.latex <- function(sym.data) {
  return(xtable(generate.sym.table(sym.data)))
}
#line 1 "/private/var/folders/x1/bc7ln59d11jddyfmvq0f4mwm0000gn/T/RtmpK8STdo/R.INSTALL582a7c381cc/RSDA/R/sym.var.R"
#' Symbolic Variable (Feature)
#' @name sym.var
#' @aliases sym.var
#' @author Oldemar Rodriguez Rojas
#' @description This function get a symbolic variable from a symbolic data table.
#' @usage sym.var(sym.data, number.sym.var)
#' @param sym.data The symbolic data table
#' @param number.sym.var The number of the column for the variable (feature) that we want to get.
#'
#' @return
#' Return a symbolic data variable with the following structure: \cr
#'
#' $N\cr
#'
#' [1] 7\cr
#'
#' $var.name\cr
#'
#' [1] 'F6'\cr
#'
#' $var.type\cr
#'
#' [1] '$I'\cr
#'
#' $obj.names\cr
#'
#' [1] 'Case1' 'Case2' 'Case3' 'Case4' 'Case5' 'Case6' 'Case7'\cr
#'
#' $var.data.vector\cr
#'
#' F6  F6.1\cr
#'
#' Case1   0.00 90.00\cr
#'
#' Case2 -90.00 98.00\cr
#'
#' Case3  65.00 90.00\cr
#'
#' Case4  45.00 89.00\cr
#'
#' Case5  20.00 40.00\cr
#'
#' Case6   5.00  8.00\cr
#'
#' Case7   3.14  6.76\cr
#'
#' @references
#' Billard L. and  Diday E. (2006).
#' Symbolic data analysis: Conceptual statistics and data mining. Wiley, Chichester.
#'
#' Bock H-H. and Diday E. (eds.) (2000).
#' Analysis of Symbolic Data. Exploratory methods for extracting statistical information
#' from complex data. Springer, Germany.
#'
#' @seealso sym.obj
#' @examples
#' data(example3)
#' sym.data<-example3
#' sym.var(sym.data,4)
#' sym.var(sym.data,6)
#' @keywords Symbolic Variable
#' @export
#'
#'
sym.var <- function(sym.data, number.sym.var) {
  if ((number.sym.var > sym.data$M) || (number.sym.var <= 0)) {
    stop("number.sym.var out of range")
  }
  pos <- sym.data$sym.var.starts[number.sym.var]
  adv <- sym.data$sym.var.length[number.sym.var]
  sym.var <- list(
    N = sym.data$N, var.name = sym.data$sym.var.names[number.sym.var],
    var.type = sym.data$sym.var.types[number.sym.var], obj.names = sym.data$sym.obj.names,
    var.data.vector = sym.data$meta[, pos:(pos + adv - 1)]
  )
  return(sym.var)
}
#line 1 "/private/var/folders/x1/bc7ln59d11jddyfmvq0f4mwm0000gn/T/RtmpK8STdo/R.INSTALL582a7c381cc/RSDA/R/sym.variance.R"
#' Symbolic Variance
#' @name sym.variance
#' @aliases sym.variance
#' @author Oldemar Rodriguez Rojas
#' @description Compute the symbolic variance.
#' @usage sym.variance(sym.var, method = c('centers', 'interval', 'billard', 'modal'),
#'  na.rm = FALSE, ...)
#' @param sym.var The symbolic variable.
#' @param method The method to be use.
#' @param na.rm As in R var function.
#' @param ... As in R var function.
#'
#' @return Return a real number.
#' @references
#' Billard L. and  Diday E. (2006).
#' Symbolic data analysis: Conceptual statistics and data mining. Wiley, Chichester.
#'
#' Rodriguez, O. (2000).
#' Classification et Modeles Lineaires en Analyse des Donnees Symboliques. Ph.D. Thesis,
#' Paris IX-Dauphine University.
#'
#' @examples
#' data(example3)
#' sym.data<-example3
#' sym.variance(sym.var(sym.data,1))
#' sym.variance(sym.var(sym.data,2))
#' sym.variance(sym.var(sym.data,6))
#' sym.variance(sym.var(sym.data,6),method='interval')
#' sym.variance(sym.var(sym.data,6),method='billard')
#' sym.variance(sym.var(sym.data,3),method='modal')
#' @keywords Symbolic Variance
#' @export
#'
sym.variance <- function(sym.var, method = c("centers", "interval", "billard", "modal"),
                         na.rm = FALSE, ...) {
  method <- match.arg(method)
  if (method == "centers") {
    if (sym.var$var.type == "$C") {
      return(var(sym.var$var.data.vector))
    }
    if (sym.var$var.type == "$I") {
      return(var(sym.var$var.data.vector[, 1] + sym.var$var.data.vector[, 2]) / 2)
    } else {
      stop("Impossible to compute the variance for this type of variable with this method")
    }
  }
  if (method == "interval") {
    if (sym.var$var.type == "$I") {
      return(sapply(sym.var$var.data.vector, var))
    } else {
      stop("Impossible to compute the variance for this type of variable with this method")
    }
  }
  if (method == "billard") {
    if (sym.var$var.type == "$I") {
      return((1 / (3 * sym.var$N)) * sum(sym.var$var.data.vector[, 1]^2 + (sym.var$var.data.vector[
        ,
        1
      ] * sym.var$var.data.vector[, 2]) + sym.var$var.data.vector[, 2]^2) -
        (1 / (4 * (sym.var$N)^2)) * sum(sym.var$var.data.vector[, 1] + sym.var$var.data.vector[
          ,
          2
        ])^2)
    } else {
      stop("Impossible to compute the variance for this type of variable with this method")
    }
  }
  if (method == "modal") {
    if (sym.var$var.type == "$M") {
      return(sapply(sym.var$var.data.vector, var))
    } else {
      stop("Impossible to compute the variance for this type of variable with this method")
    }
  }
}
#line 1 "/private/var/folders/x1/bc7ln59d11jddyfmvq0f4mwm0000gn/T/RtmpK8STdo/R.INSTALL582a7c381cc/RSDA/R/transpose.sym.r"
transpose.sym <- function(sym.data) {
  M <- sym.data$M
  N <- sym.data$N
  sym.obj.names <- sym.data$sym.obj.names
  sym.var.names <- sym.data$sym.var.names
  data <- sym.data$data

  data.sal <- as.data.frame(matrix(rep(0, 2 * M * N), nrow = M))

  seq.min <- seq(from = 1, by = 2, length.out = N)
  seq.max <- seq(from = 2, by = 2, length.out = N)

  for (i in 1:M)
  {
    indx.i <- (2 * i - 1):(2 * i)
    for (j in 1:N)
    {
      ind.j <- (2 * j - 1):(2 * j)
      data.sal[i, ind.j] <- data[j, indx.i]
    }
  }

  row.names(data.sal) <- sym.var.names
  colnames(data.sal)[seq.min] <- sym.obj.names
  colnames(data.sal)[seq.max] <- paste0(sym.obj.names, ".1")
  return(data.frame.to.RSDA.inteval.table(data.sal))
}
#line 1 "/private/var/folders/x1/bc7ln59d11jddyfmvq0f4mwm0000gn/T/RtmpK8STdo/R.INSTALL582a7c381cc/RSDA/R/var.sym.data.table.R"
#' Generic function for the Variance
#' @name var
#' @aliases var
#' @author Oldemar Rodriguez Rojas
#' @description Compute the symbolic variance.
#' @param x The symbolic variable.
#' @param y NULL (default) or a vector, matrix or data frame with
#' compatible dimensions to x. The default is equivalent to y = x (but more efficient).
#' @param use an optional character string giving a method for computing covariances
#' in the presence of missing values. This must be (an abbreviation of) one of the
#' strings 'everything', 'all.obs', 'complete.obs', 'na.or.complete',
#' or 'pairwise.complete.obs'.
#' @param method The method to be use.
#' @param na.rm logical. Should missing values be removed?
#' @param ... As in R median function.
#'
#' @return Return a real number.
#' @references
#' Billard L. and  Diday E. (2006).
#' Symbolic data analysis: Conceptual statistics and data mining. Wiley, Chichester.
#'
#' Rodriguez, O. (2000).
#' Classification et Modeles Lineaires en Analyse des Donnees Symboliques. Ph.D. Thesis,
#' Paris IX-Dauphine University.
#'
#' @examples
#' data(example3)
#' sym.data<-example3
#' var(sym.data[,1])
#' var(sym.data[,2])
#' var(sym.data[,6])
#' var(sym.data[,6], method='interval')
#' var(sym.data[,6], method='billard')
#' var(sym.data[,3], method='modal')
#' @keywords Symbolic Variance
#' @export
#'
var <- function(x, ...) {
  UseMethod("var", x)
}

#' @rdname var
#' @export
var.default <- function(x, y = NULL, na.rm = FALSE, use, ...) {
  stats::var(x, y, na.rm, use)
}

#' @rdname var
#' @export
var.sym.data.table <- function(x, method = c("centers", "interval", "billard", "modal"),
                               na.rm = FALSE, ...) {
  error.message <- "Impossible to compute the variance for this type of variable with this method"
  method <- match.arg(method)
  if (method == "centers") {
    if (x$sym.var.types == "$C") {
      return(var(x$data[, 1]))
    }
    if (x$sym.var.types == "$I") {
      return(var(x$data[, 1] + x$data[, 2]) / 2)
    } else {
      stop(error.message)
    }
  }
  if (method == "interval") {
    if (x$sym.var.types == "$I") {
      return(sapply(x$data, var))
    } else {
      stop(error.message)
    }
  }
  if (method == "billard") {
    if (x$sym.var.types == "$I") {
      return((1 / (3 * x$N)) * sum(x$data[, 1]^2 + (x$data[, 1] * x$data[, 2]) +
        x$data[, 2]^2) - (1 / (4 * (x$N)^2)) * sum(x$data[, 1] + x$data[, 2])^2)
    } else {
      stop(error.message)
    }
  }

  if (method == "modal") {
    if (x$sym.var.types == "$M") {
      return(sapply(x$data, var))
    } else {
      stop(error.message)
    }
  }
}
#line 1 "/private/var/folders/x1/bc7ln59d11jddyfmvq0f4mwm0000gn/T/RtmpK8STdo/R.INSTALL582a7c381cc/RSDA/R/variance.princ.curve.R"
#' Variance of the principal curve
#' @name variance.princ.curve
#' @aliases  variance.princ.curve
#' @author Jorge Arce.
#' @description Variance of the principal curve
#' @usage variance.princ.curve(data,curve)
#' @param data Classic data table.
#' @param curve The principal curve.
#' @return The variance of the principal curve.
#' @references
#' Arce J. and Rodriguez O. (2015) 'Principal Curves and Surfaces
#' to Interval Valued Variables'. The 5th Workshop on Symbolic
#' Data Analysis, SDA2015, Orleans, France, November.
#'
#' Hastie,T. (1984).
#' Principal Curves and Surface. Ph.D Thesis Stanford University.
#'
#' Hastie,T. \& Weingessel,A. (2014).
#' princurve - Fits a Principal Curve in Arbitrary Dimension.R package version 1.1--12
#' http://cran.r-project.org/web/packages/princurve/index.html.
#'
#' Hastie,T. \& Stuetzle, W. (1989). Principal Curves.
#' Journal of the American Statistical Association, Vol. 84-406, 502--516.
#'
#' Hastie, T., Tibshirani, R. \& Friedman, J. (2008).
#' The Elements of Statistical Learning; Data Mining, Inference and Prediction. Springer, New York.
#' @seealso sym.interval.pc
#' @keywords Principal Curve
#' @import princurve
#' @export
#'
variance.princ.curve <- function(data, curve) {
  var.data <- diag(var(data))
  var.curve <- diag(var(curve))
  dist <- sum((data - curve)^2) / dim(data)[1]
  ord <- order(x = var.data, decreasing = TRUE)
  var.data.cum <- cumsum(var.data[ord])
  var.curve.cum <- cumsum(var.curve[ord])
  return(list(
    var.data = var.data, var.data.cum = var.data.cum, var.curve = var.curve,
    var.curve.cum = var.curve.cum, dist = dist, var.order = ord
  ))
}
#line 1 "/private/var/folders/x1/bc7ln59d11jddyfmvq0f4mwm0000gn/T/RtmpK8STdo/R.INSTALL582a7c381cc/RSDA/R/vertex.interval.R"
#' Vertex of the intervals
#' @name vertex.interval
#' @aliases vertex.interval
#' @author Jorge Arce.
#' @description Vertex of the intervals
#' @usage vertex.interval(sym.data)
#' @param sym.data Symbolic interval data table.
#'
#' @return Vertices of the intervals.
#' @references
#' Arce J. and Rodriguez O. (2015) 'Principal Curves and Surfaces
#' to Interval Valued Variables'. The 5th Workshop on Symbolic
#' Data Analysis, SDA2015, Orleans, France, November.
#'
#' Hastie,T. (1984).
#' Principal Curves and Surface. Ph.D Thesis Stanford University.
#'
#' Hastie,T. \& Weingessel,A. (2014).
#' princurve - Fits a Principal Curve in Arbitrary Dimension.R package version 1.1--12
#' http://cran.r-project.org/web/packages/princurve/index.html.
#'
#' Hastie,T. \& Stuetzle, W. (1989). Principal Curves.
#' Journal of the American Statistical Association, Vol. 84-406, 502--516.
#'
#' Hastie, T., Tibshirani, R. \& Friedman, J. (2008).
#' The Elements of Statistical Learning; Data Mining, Inference and Prediction. Springer, New York.
#' @seealso sym.interval.pc
#' @keywords Principal Curve
#' @import princurve
#'
#'
#'
vertex.interval <- function(sym.data) {
  if ((sym.data$sym.var.types[1] != "$I")) {
    stop("Variables have to be continuos or Interval")
  } else {
    nn <- sym.data$N
    mm <- sym.data$M
    num.vertex <- rep(-1, nn)
    vertex <- matrix(0, 1, mm)
    vertex <- as.data.frame(vertex)
    colnames(vertex) <- sym.data$sym.var.names
    sym.text <- "as.matrix(sym.data$data["
    for (i in 1:nn) {
      current.row <- as.character(i)
      previous <- "1:2"
      command <- paste0(sym.text, current.row, ",", previous, "])")
      for (j in 2:mm) {
        col.current.min <- 2 * j - 1
        col.current.max <- 2 * j
        nxt.grid <- paste0(as.character(col.current.min), ":", as.character(col.current.max))
        command <- paste0(
          command, ",", sym.text, current.row, ",", nxt.grid,
          "])"
        )
      }
      command <- paste0("expand.grid(", command, ")")
      aux <- eval(parse(text = command))
      aux <- sqldf("select distinct * from aux")
      num.vertex[i] <- dim(aux)[1]
      colnames(aux) <- sym.data$sym.var.names
      vertex <- rbind(vertex, aux)
    }
    num.vertexf <- dim(vertex)[1]
    return(list(vertex = vertex[2:num.vertexf, ], num.vertex = num.vertex))
  }
}
#line 1 "/private/var/folders/x1/bc7ln59d11jddyfmvq0f4mwm0000gn/T/RtmpK8STdo/R.INSTALL582a7c381cc/RSDA/R/vertex.interval.new.j.r"
#' vertex.interval.new.j
#' @keywords internal
vertex.interval.new.j <- function(sym.data) {
  if ((sym.data$sym.var.types[1] != "$I")) {
    # stop('Variables have to be continuos or Interval')
    stop("Variables have to be Interval")
  } else {
    nn <- sym.data$N
    mm <- sym.data$M
    num.vertex <- rep(-1, nn)
    vertex <- matrix(0, 1, mm)
    vertex <- as.data.frame(vertex)
    colnames(vertex) <- sym.data$sym.var.names
    sym.text <- "as.matrix(sym.data$data["
    for (i in 1:nn) {
      current.row <- as.character(i)
      previous <- "1:2"
      command <- paste0(sym.text, current.row, ",", previous, "])")
      for (j in 2:mm) {
        col.current.min <- 2 * j - 1
        col.current.max <- 2 * j
        nxt.grid <- paste0(as.character(col.current.min), ":", as.character(col.current.max))
        command <- paste0(
          command, ",", sym.text, current.row, ",", nxt.grid,
          "])"
        )
      }
      command <- paste0("expand.grid(", command, ")")
      aux <- eval(parse(text = command))
      aux <- sqldf("select distinct * from aux")
      num.vertex[i] <- dim(aux)[1]
      colnames(aux) <- sym.data$sym.var.names
      vertex <- rbind(vertex, aux)
    }
    num.vertexf <- dim(vertex)[1]
    return(list(vertex = vertex[2:num.vertexf, ], num.vertex = num.vertex))
  }
}
#line 1 "/private/var/folders/x1/bc7ln59d11jddyfmvq0f4mwm0000gn/T/RtmpK8STdo/R.INSTALL582a7c381cc/RSDA/R/vertex.pca.j.r"
#' vertex.pca.j
#' @keywords internal
vertex.pca.j <- function(data.sym) {
  data.sym.vertex <- vertex.interval.new.j(data.sym)
  data.sym.center <- centers.interval.j(data.sym)
  data.sym.center <- data.sym.center$centers
  data.sym.center <- scale(data.sym.center)
  mean.var <- attr(data.sym.center, "scaled:center")
  desv.var <- attr(data.sym.center, "scaled:scale")
  N <- data.sym$N
  M <- data.sym$M
  sym.data.vertex.matrix.cent <- data.sym.vertex$vertex
  for (i in 1:M) {
    sym.data.vertex.matrix.cent[, i] <- (sym.data.vertex.matrix.cent[, i] - mean.var[i]) / desv.var[i]
  }
  dim.vertex <- dim(data.sym.vertex$vertex)[1]
  tot.individuals <- N + dim.vertex
  data.sym.matrix <- rbind(data.sym.center, sym.data.vertex.matrix.cent)
  pca.centers <- FactoMineR::PCA(X = data.sym.matrix, scale.unit = FALSE, ind.sup = (N +
    1):tot.individuals, ncp = M, graph = FALSE)
  data.sym.cent <- data.frame.to.RSDA.inteval.table.j(sym.scale.interval(
    data.sym,
    mean.var, desv.var
  ))
  res <- sym.interval.vertex.pca.j(data.sym.cent)
  class(res$Sym.Components) <- "sym.data.table"
  return(res)
}
#line 1 "/private/var/folders/x1/bc7ln59d11jddyfmvq0f4mwm0000gn/T/RtmpK8STdo/R.INSTALL582a7c381cc/RSDA/R/whiskers.j.r"
#' whiskers
#' @keywords internal
whiskers <- function(from, to, col = "red") {
  segments(from[, 1], from[, 2], to[, 1], to[, 2], col = col)
}
#line 1 "/private/var/folders/x1/bc7ln59d11jddyfmvq0f4mwm0000gn/T/RtmpK8STdo/R.INSTALL582a7c381cc/RSDA/R/write.sym.table.R"
#' Write Symbolic Data Table
#'
#' @name write.sym.table
#' @author Oldemar Rodriguez Rojas
#' @aliases write.sym.table
#' @description This function write (save) a symbolic data table from a CSV data file.
#' @usage write.sym.table(sym.data, file, sep, dec, row.names = NULL, col.names = NULL)
#' @param sym.data Symbolic data table
#' @param file The name of the CSV file.
#' @param sep As in R function read.table
#' @param dec As in R function read.table
#' @param row.names As in R function read.table
#' @param col.names As in R function read.table
#' @return Write in CSV file the symbolic data table.
#' @references Bock H-H. and Diday E. (eds.) (2000). Analysis of Symbolic Data.
#' Exploratory methods for extracting statistical information from complex data. Springer, Germany.
#' @seealso read.sym.table
#'
#' @examples
#' \dontrun{
#' data(example1)
#' write.sym.table(example1, file='temp4.csv', sep='|',dec='.', row.names=TRUE, col.names=TRUE)
#' ex1 <- read.sym.table('temp4.csv', header=TRUE, sep='|',dec='.', row.names=1)
#' }
#'
#'
write.sym.table <- function(sym.data, file, sep, dec, row.names = NULL, col.names = NULL) {
  write.table(sym.data$meta, file,
    sep = as.character(sep), dec = dec, quote = FALSE,
    row.names = c(row.names), col.names = c(col.names)
  )
}
